[[running-tests]]
== テストを実行する

[[running-tests-ide]]
=== IDE でテストを実行する

[[running-tests-ide-intellij-idea]]
==== IntelliJ IDEA

// IntelliJ IDEA supports running tests on the JUnit Platform since version 2016.2. For
// details please see the
// https://blog.jetbrains.com/idea/2016/08/using-junit-5-in-intellij-idea/[post on theIntelliJ IDEA blog]. Note, however, that it is recommended to use IDEA 2017.3 or newer
// since these newer versions of IDEA will download the following JARs automatically based
// on the API version used in the project: `junit-platform-launcher`,
// `junit-jupiter-engine`, and `junit-vintage-engine`.
IntelliJ IDEA は 2016.2 から JUnit Platform でテストを実行できるようになりました。
詳しくは https://blog.jetbrains.com/idea/2016/08/using-junit-5-in-intellij-idea/[IntelliJ IDEA ブログの投稿] を参照してください。
ただし、実際には IntelliJ IDEA 2017.3 より新しいバージョンを使うことを推奨します。
プロジェクトで使用している `junit-platform-launcher, junit-jupiter-engine, junit-vintage-engine` のバージョンに対応した jar ファイルを自動的にダウンロードして使用するようになっているからです。

// WARNING: IntelliJ IDEA releases prior to IDEA 2017.3 bundle specific versions of JUnit 5.
// Thus, if you want to use a newer version of JUnit Jupiter, execution of tests within the
// IDE might fail due to version conflicts. In such cases, please follow the instructions
// below to use a newer version of JUnit 5 than the one bundled with IntelliJ IDEA.
WARNING: 2017.3 より前のバージョンの IntelliJ IDEA は特定バージョンの JUnit 5 が同梱しています。
ですから、それより新しいバージョンの JUnit Jupiter でテストを実行すると、異なるバージョンのライブラリが同時に存在することになり、衝突してしまうからです。
そういう場合は、次の手順に従って、IntelliJ IDEA の同梱する JUnit 5 より新しいバージョンを使うようにしてください。

// In order to use a different JUnit 5 version (e.g., {jupiter-version}), you may need to
// include the corresponding versions of the `junit-platform-launcher`,
// `junit-jupiter-engine`, and `junit-vintage-engine` JARs in the classpath.
IDE の同梱する JUnit 5 と異なるバージョン（例えば {jupiter-version}）を使用するには、対応するバージョンの `junit-platform-launcher, junit-jupiter-engine, junit-vintage-engine` の jar ファイルをクラスパスに配置しなければなりません。

// .Additional Gradle Dependencies
.Gradle の依存ライブラリを追加する
[source,groovy]
[subs=attributes+]
----
testImplementation(platform("org.junit:junit-bom:{bom-version}"))
// Only needed to run tests in a version of IntelliJ IDEA that bundles older versions
testRuntimeOnly("org.junit.platform:junit-platform-launcher")
testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine")
testRuntimeOnly("org.junit.vintage:junit-vintage-engine")
----

// .Additional Maven Dependencies
.Maven の依存ライブラリを追加する
[source,xml]
[subs=attributes+]
----
<!-- ... -->
<dependencies>
	<!-- Only needed to run tests in a version of IntelliJ IDEA that bundles older versions -->
	<dependency>
		<groupId>org.junit.platform</groupId>
		<artifactId>junit-platform-launcher</artifactId>
		<scope>test</scope>
	</dependency>
	<dependency>
		<groupId>org.junit.jupiter</groupId>
		<artifactId>junit-jupiter-engine</artifactId>
		<scope>test</scope>
	</dependency>
	<dependency>
		<groupId>org.junit.vintage</groupId>
		<artifactId>junit-vintage-engine</artifactId>
		<scope>test</scope>
	</dependency>
</dependencies>
<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>org.junit</groupId>
			<artifactId>junit-bom</artifactId>
			<version>{bom-version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>
----

[[running-tests-ide-eclipse]]
==== Eclipse

// Eclipse IDE offers support for the JUnit Platform since the Eclipse Oxygen.1a (4.7.1a)
// release.
Eclipse IDE は Eclipse Oxygen.1a (4.7.1a) から JUnit Platform でテストを実行できるようになりました。

// For more information on using JUnit 5 in Eclipse consult the official _Eclipse support
// for JUnit 5_ section of the
// https://www.eclipse.org/eclipse/news/4.7.1a/#junit-5-support[Eclipse Project Oxygen.1a (4.7.1a) - New and Noteworthy] documentation.
詳しい使い方は公式ドキュメントの https://www.eclipse.org/eclipse/news/4.7.1a/#junit-5-support[Eclipse Project Oxygen.1a (4.7.1a) - New and Noteworthy] _Eclipse support for JUnit 5_ を参照してください。

[[running-tests-ide-netbeans]]
==== NetBeans

// NetBeans offers support for JUnit Jupiter and the JUnit Platform since the
// https://netbeans.apache.org/download/nb100/nb100.html[Apache NetBeans 10.0 release].
NetBeans は https://netbeans.apache.org/download/nb100/nb100.html[Apache NetBeans 10.0 release] から JUnit Platform で JUnit Jupiter のテストを実行できるようになりました。

// For more information consult the JUnit 5 section of the
// https://netbeans.apache.org/download/nb100/index.html#_junit_5[Apache NetBeans 10.0
// release notes].
詳しい使い方は公式ドキュメントの https://netbeans.apache.org/download/nb100/index.html#_junit_5[Apache NetBeans 10.0 release notes] _JUnit 5_ を参照してください。

[[running-tests-ide-vscode]]
==== Visual Studio Code

// https://code.visualstudio.com/[Visual Studio Code] supports JUnit Jupiter and the JUnit
// Platform via the
// https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-test[Java Test
// Runner] extension which is installed by default as part of the
// https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java
// Extension Pack].
https://code.visualstudio.com/[Visual Studio Code] では、 https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-test[Java Test Runner 拡張] を使うと JUnit Platform で JUnit Jupiter のテストを実行できます。
Java Test Runner 拡張は https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack] の一部として一緒にインストールできます。

// For more information consult the _Testing_ section of the
// https://code.visualstudio.com/docs/languages/java#_testing[Java in Visual Studio Code]
// documentation.
詳しい使い方は公式ドキュメントの https://code.visualstudio.com/docs/languages/java#_testing[Java in Visual Studio Code] _Testing_ を参照してください。

[[running-tests-ide-other]]
==== 他の IDE

// If you are using an editor or IDE other than one of those listed in the previous sections,
// the JUnit team provides two alternative solutions to assist you in using JUnit 5. You can
// use the <<running-tests-console-launcher>> manually -- for example, from the command line
// -- or execute tests with a <<running-tests-junit-platform-runner,JUnit 4 based Runner>> if
// your IDE has built-in support for JUnit 4.
前述した以外のエディターや IDE を使用する場合のため、JUnit チームは JUnit 5 の使用を支援する2種類の方法を提供しています。
1つは <<running-tests-console-launcher>> をコマンドラインで実行する方法です。
もう1つは <<running-tests-junit-platform-runner,JUnit 4 based Runner>> を実行する方法で、こちらはエディタや IDE が JUnit 4 に対応している場合に使用できる方法です。

[[running-tests-build]]
=== ビルドツールでテストを実行する

[[running-tests-build-gradle]]
==== Gradle

// [WARNING]
// .The JUnit Platform Gradle Plugin has been discontinued
[WARNING]
.JUnit Platform Gradle プラグインの開発は修了しました
====
// The `junit-platform-gradle-plugin` developed by the JUnit team was deprecated in JUnit
// Platform 1.2 and discontinued in 1.3. Please switch to Gradle's standard `test` task.
JUnit チームの開発していた `junit-platform-gradle-plugin` は JUnit Platform 1.2 で廃止予定になり、1.3 の開発は中止しました。
代わりに Gradle の標準 `test` タスクを使用してください。
====

// Starting with https://docs.gradle.org/4.6/release-notes.html[version 4.6], Gradle provides
// https://docs.gradle.org/current/userguide/java_testing.html#using_junit5[native support]
// for executing tests on the JUnit Platform. To enable it, you just need to specify
// `useJUnitPlatform()` within a `test` task declaration in `build.gradle`:
Gradle は https://docs.gradle.org/4.6/release-notes.html[4.6] から JUnit Platform で https://docs.gradle.org/current/userguide/java_testing.html#using_junit5[直接的にテストを実行できる] ようになりました。
この機能を使用するには `build.gradle` の `test` タスクで `useJUnitPlatform()` を呼び出すようにします。

[source,groovy,indent=0]
[subs=attributes+]
----
test {
	useJUnitPlatform()
}
----

// Filtering by <<running-tests-tags, tags>>,
// <<running-tests-tag-expressions, tag expressions>>, or engines is also supported:
<<running-tests-tags, タグ>> や <<running-tests-tag-expressions, タグ記法>> で実行するテストを選択したり、テスト実行エンジンを指定できます。

[source,groovy,indent=0]
[subs=attributes+]
----
test {
	useJUnitPlatform {
		includeTags("fast", "smoke & feature-a")
		// excludeTags("slow", "ci")
		includeEngines("junit-jupiter")
		// excludeEngines("junit-vintage")
	}
}
----

// Please refer to the
// https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_test[official Gradle documentation]
// for a comprehensive list of options.
使用可能な全ての設定項目については https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_test[公式ドキュメント] を参照してください。

[[running-tests-build-gradle-config-params]]
===== 設定パラメータの構成

// The standard Gradle `test` task currently does not provide a dedicated DSL to set JUnit
// Platform <<running-tests-config-params, configuration parameters>> to influence test
// discovery and execution. However, you can provide configuration parameters within the
// build script via system properties (as shown below) or via the
// `junit-platform.properties` file.
現在の Gradle の標準 `test` タスクには、JUnit Platform がテストを発見したり実行したりするための <<running-tests-config-params, 設定パラメータ>> を指定する DSL が存在しません。
代わりにシステムプロパティや `junit-platform.properties` ファイルで指定します。

[source,groovy,indent=0]
----
test {
	// ...
	systemProperty("junit.jupiter.conditions.deactivate", "*")
	systemProperty("junit.jupiter.extensions.autodetection.enabled", true)
	systemProperty("junit.jupiter.testinstance.lifecycle.default", "per_class")
	// ...
}
----

[[running-tests-build-gradle-engines-configure]]
===== テスト実行エンジンの構成

// In order to run any tests at all, a `TestEngine` implementation must be on the classpath.
1度に複数のテストを実行するには、クラスパスに `TestEngine` の実装クラスが存在しなければなりません。

// To configure support for JUnit Jupiter based tests, configure a `testImplementation` dependency
// on the dependency-aggregating JUnit Jupiter artifact similar to the following.
JUnit Jupiter で作成したテストを実行するには、JUnit Jupiter の集約アーティファクトを `testImplementation` 依存関係で指定しなければなりません。

[source,groovy,indent=0]
[subs=attributes+]
----
dependencies {
	testImplementation("org.junit.jupiter:junit-jupiter:{jupiter-version}")
}
----

// The JUnit Platform can run JUnit 4 based tests as long as you configure a `testImplementation`
// dependency on JUnit 4 and a `testRuntimeOnly` dependency on the JUnit Vintage `TestEngine`
// implementation similar to the following.
JUnit 4 で作成したテストを JUnit Platform で実行するには、JUnit 4 のアーティファクトを `testImplementation` 依存関係に指定するだけでなく、JUnit Vintage のアーティファクトを `testRuntimeOnly` 依存関係に指定しなければなりません。

[source,groovy,indent=0]
[subs=attributes+]
----
dependencies {
	testImplementation("junit:junit:{junit4-version}")
	testRuntimeOnly("org.junit.vintage:junit-vintage-engine:{vintage-version}")
}
----

[[running-tests-build-gradle-logging]]
===== ログ出力の設定（任意）

// JUnit uses the Java Logging APIs in the `java.util.logging` package (a.k.a. _JUL_) to
// emit warnings and debug information. Please refer to the official documentation of
// `{LogManager}` for configuration options.
JUnit は警告情報やデバッグ情報を出力するため、Java の標準ログ API （`java.util.logging` パッケージ、_JUL_ と呼ばれる）を使用します。
`{LogManager}` の設定方法について詳しくは https://docs.oracle.com/en/java/javase/11/docs/api/java.logging/java/util/logging/LogManager.html[公式ドキュメント] を参照してください。

// Alternatively, it's possible to redirect log messages to other logging frameworks such as
// {Log4j} or {Logback}. To use a logging framework that provides a custom implementation of
// `{LogManager}`, set the `java.util.logging.manager` system property to the _fully
// qualified class name_ of the `{LogManager}` implementation to use. The example below
// demonstrates how to configure Log4j{nbsp}2.x (see {Log4j_JDK_Logging_Adapter} for
// details).
JUL のログ出力は {Log4j} や {Logback} のようなロギングフレームワークへ転送できます。
使用するロギングフレームワークが `{LogManager}` の実装クラスを提供している場合、システムプロパティの `java.util.logging.manager` へ _完全修飾クラス名_ を指定してください。
Log4j{nbsp}2.x を使用する場合は次のように記述します（詳しくは {Log4j_JDK_Logging_Adapter} を参照）。

[source,groovy,indent=0]
[subs=attributes+]
----
test {
	systemProperty("java.util.logging.manager", "org.apache.logging.log4j.jul.LogManager")
}
----

// Other logging frameworks provide different means to redirect messages logged using
// `java.util.logging`. For example, for {Logback} you can use the
// https://www.slf4j.org/legacy.html#jul-to-slf4j[JUL to SLF4J Bridge] by adding an
// additional dependency to the runtime classpath.
ロギングフレームワークとして {Logback} を使用するなら、`runtime` 依存関係に https://www.slf4j.org/legacy.html#jul-to-slf4j[JUL to SLF4J Bridge] を追加するといいでしょう。


[[running-tests-build-maven]]
==== Maven

// [WARNING]
// .The JUnit Platform Maven Surefire Provider has been discontinued
[WARNING]
.JUnit Platform Maven Surefire Provider プラグインの開発は修了しました
====
// The `junit-platform-surefire-provider`, which was originally developed by the JUnit team,
// was deprecated in JUnit Platform 1.3 and discontinued in 1.4. Please use Maven Surefire's
// native support instead.
JUnit チームの開発していた `junit-platform-surefire-provider` は JUnit Platform 1.3 で廃止予定になり、1.4 の開発は中止しました。
代わりに Maven Surefire で直接的に実行するようにしてください。
====

// Starting with https://issues.apache.org/jira/browse/SUREFIRE-1330[version 2.22.0], Maven
// Surefire and Maven Failsafe provide
// https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit-platform.html[native support]
// for executing tests on the JUnit Platform. The `pom.xml` file in the
// `{junit5-jupiter-starter-maven}` project demonstrates how to use the Maven Surefire plugin
// and can serve as a starting point for configuring your Maven build.
Maven Surefire および Maven Failsafe では https://issues.apache.org/jira/browse/SUREFIRE-1330[2.22.0] から JUnit Platform で https://maven.apache.org/surefire/maven-surefire-plugin/examples/junit-platform.html[直接的にテストを実行できる] ようになりました。
`{junit5-jupiter-starter-maven}` プロジェクトの `pom.xml` ファイルを見ると、Maven Surefire プラグインをどのように設定するのか分かります。

[[running-tests-build-maven-engines-configure]]
===== テスト実行エンジンの構成

// In order to have Maven Surefire or Maven Failsafe run any tests at all, at least one
// `TestEngine` implementation must be added to the test classpath.
Maven Surefire や Maven Failsafe で1度に複数のテストを実行するには、クラスパスに `TestEngine` の実装クラスが存在しなければなりません。

// To configure support for JUnit Jupiter based tests, configure `test` scoped dependencies
// on the JUnit Jupiter API and the JUnit Jupiter `TestEngine` implementation similar to the
// following.
JUnit Jupiter で作成したテストを実行するには、JUnit Jupiter API と JUnit Jupiter `TestEngine` （の実装クラス）の依存ライブラリを `test` スコープで追加しなければなりません。

[source,xml,indent=0]
[subs=attributes+]
----
	<!-- ... -->
	<dependencies>
		<!-- ... -->
		<dependency>
			<groupId>org.junit.jupiter</groupId>
			<artifactId>junit-jupiter</artifactId>
			<version>{jupiter-version}</version>
			<scope>test</scope>
		</dependency>
		<!-- ... -->
	</dependencies>
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>{surefire-version}</version>
			</plugin>
			<plugin>
				<artifactId>maven-failsafe-plugin</artifactId>
				<version>{surefire-version}</version>
			</plugin>
		</plugins>
	</build>
	<!-- ... -->
----

// Maven Surefire and Maven Failsafe can run JUnit 4 based tests alongside Jupiter tests as
// long as you configure `test` scoped dependencies on JUnit 4 and the JUnit Vintage
// `TestEngine` implementation similar to the following.
JUnit 4 で作成したテストを JUnit Jupiter で作成したテストと一緒に実行するには、JUnit 4 と JUnit Vintage `TestEngine` （の実装クラス）の依存ライブラリを `test` スコープで追加しなければなりません。

[source,xml,indent=0]
[subs=attributes+]
----
	<!-- ... -->
	<dependencies>
		<!-- ... -->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<version>{junit4-version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.junit.vintage</groupId>
			<artifactId>junit-vintage-engine</artifactId>
			<version>{vintage-version}</version>
			<scope>test</scope>
		</dependency>
		<!-- ... -->
	</dependencies>
	<!-- ... -->
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>{surefire-version}</version>
			</plugin>
			<plugin>
				<artifactId>maven-failsafe-plugin</artifactId>
				<version>{surefire-version}</version>
			</plugin>
		</plugins>
	</build>
	<!-- ... -->
----

[[running-tests-build-maven-filter-test-class-names]]
===== 名前でテストクラスを選択する

// The Maven Surefire Plugin will scan for test classes whose fully qualified names match
// the following patterns.
Maven Surefire プラグインは、完全修飾クラス名が次のようなパス文字列パターンに一致するテストクラスを探索します。

- +++**/Test*.java+++
- +++**/*Test.java+++
- +++**/*Tests.java+++
- +++**/*TestCase.java+++

// Moreover, it will exclude all nested classes (including static member classes) by default.
さらに、初期設定では全ての入れ子クラス（`static` メンバークラスも含めて）を無視します。

// Note, however, that you can override this default behavior by configuring explicit
// `include` and `exclude` rules in your `pom.xml` file. For example, to keep Maven Surefire
// from excluding static member classes, you can override its exclude rules as follows.
しかし、この振る舞いは明示的に `pom.xml` へ `include` ルールと `exclude` ルールを追加することで変更できます。
例えば、`static` メンバークラスを無視する振る舞いを止めさせるには次のように `exclude` ルールを記述します。

[source,xml,indent=0]
[subs=attributes+]
// .Overriding exclude rules of Maven Surefire
.Maven Surefire の `exclude` ルールを上書きする
----
	<!-- ... -->
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>{surefire-version}</version>
				<configuration>
					<excludes>
						<exclude/>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>
	<!-- ... -->
----

// Please see the
// https://maven.apache.org/surefire/maven-surefire-plugin/examples/inclusion-exclusion.html[Inclusions and Exclusions of Tests]
// documentation for Maven Surefire for details.
詳しくは公式ドキュメントの https://maven.apache.org/surefire/maven-surefire-plugin/examples/inclusion-exclusion.html[Inclusions and Exclusions of Tests] を参照してください。

[[running-tests-build-maven-filter-tags]]
===== タグでテストクラスを選択する

// You can filter tests by <<running-tests-tags, tags>> or
// <<running-tests-tag-expressions, tag expressions>> using the following configuration
// properties.
<<running-tests-tags, タグ>> や <<running-tests-tag-expressions, タグ記法>> で実行するテストを選択できます。

// - to include _tags_ or _tag expressions_, use `groups`.
// - to exclude _tags_ or _tag expressions_, use `excludedGroups`.
- _タグ_ や _タグ記法_ を含むテストクラスを選択するには `groups` を使用します
- _タグ_ や _タグ記法_ を含むテストクラスを除外するには `excludedGroups` を使用します

[source,xml,indent=0]
[subs=attributes+]
----
	<!-- ... -->
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>{surefire-version}</version>
				<configuration>
					<groups>acceptance | !feature-a</groups>
					<excludedGroups>integration, regression</excludedGroups>
				</configuration>
			</plugin>
		</plugins>
	</build>
	<!-- ... -->
----

[[running-tests-build-maven-config-params]]
===== 設定パラメータの構成

// You can set JUnit Platform <<running-tests-config-params, configuration parameters>> to
// influence test discovery and execution by declaring the `configurationParameters`
// property and providing key-value pairs using the Java `Properties` file syntax (as shown
// below) or via the `junit-platform.properties` file.
JUnit Platform がテストを発見したり実行したりするための <<running-tests-config-params, 設定パラメータ>> は `configurationParameters` で指定します。
`configurationProperties` には、 Java の `Properties` 記法でキーと値の対を記述します。
`junit-platform.properties` ファイルでも指定できます。


[source,xml,indent=0]
[subs=attributes+]
----
	<!-- ... -->
	<build>
		<plugins>
			<plugin>
				<artifactId>maven-surefire-plugin</artifactId>
				<version>{surefire-version}</version>
				<configuration>
					<properties>
						<configurationParameters>
							junit.jupiter.conditions.deactivate = *
							junit.jupiter.extensions.autodetection.enabled = true
							junit.jupiter.testinstance.lifecycle.default = per_class
						</configurationParameters>
					</properties>
				</configuration>
			</plugin>
		</plugins>
	</build>
	<!-- ... -->
----

[[running-tests-build-ant]]
==== Ant

Starting with version `1.10.3` of link:https://ant.apache.org/[Ant], a new
link:https://ant.apache.org/manual/Tasks/junitlauncher.html[`junitlauncher`] task has
been introduced to provide native support for launching tests on the JUnit Platform. The
`junitlauncher` task is solely responsible for launching the JUnit Platform and passing
it the selected collection of tests. The JUnit Platform then delegates to registered test
engines to discover and execute the tests.

The `junitlauncher` task attempts to align as close as possible with native Ant
constructs such as
link:https://ant.apache.org/manual/Types/resources.html#collection[resource collections]
for allowing users to select the tests that they want executed by test engines. This
gives the task a consistent and natural feel when compared to many other core Ant tasks.

Starting with version `1.10.6` of Ant, the `junitlauncher` task supports
link:https://ant.apache.org/manual/Tasks/junitlauncher.html#fork[forking the tests in a separate JVM].

The `build.xml` file in the `{junit5-jupiter-starter-ant}` project demonstrates how to use
the task and can serve as a starting point.

===== Basic Usage

The following example demonstrates how to configure the `junitlauncher` task to select a
single test class (i.e., `org.myapp.test.MyFirstJUnit5Test`).

[source,xml,indent=0]
----
	<path id="test.classpath">
		<!-- The location where you have your compiled classes -->
		<pathelement location="${build.classes.dir}" />
	</path>

	<!-- ... -->

	<junitlauncher>
		<classpath refid="test.classpath" />
		<test name="org.myapp.test.MyFirstJUnit5Test" />
	</junitlauncher>
----

The `test` element allows you to specify a single test class that you want to be selected
and executed. The `classpath` element allows you to specify the classpath to be used to
launch the JUnit Platform. This classpath will also be used to locate test classes that
are part of the execution.

The following example demonstrates how to configure the `junitlauncher` task to select
test classes from multiple locations.

[source,xml,indent=0]
----
	<path id="test.classpath">
		<!-- The location where you have your compiled classes -->
		<pathelement location="${build.classes.dir}" />
	</path>
	<!-- ... -->
	<junitlauncher>
		<classpath refid="test.classpath" />
		<testclasses outputdir="${output.dir}">
			<fileset dir="${build.classes.dir}">
				<include name="org/example/**/demo/**/" />
			</fileset>
			<fileset dir="${some.other.dir}">
				<include name="org/myapp/**/" />
			</fileset>
		</testclasses>
	</junitlauncher>
----

In the above example, the `testclasses` element allows you to select multiple test
classes that reside in different locations.

For further details on usage and configuration options please refer to the official Ant
documentation for the
link:https://ant.apache.org/manual/Tasks/junitlauncher.html[`junitlauncher` task].

[[running-tests-console-launcher]]
=== コンソールランチャー

// The `{ConsoleLauncher}` is a command-line Java application that lets you launch the JUnit
// Platform from the console. For example, it can be used to run JUnit Vintage and JUnit
// Jupiter tests and print test execution results to the console.
`{ConsoleLauncher}` はコマンドラインから JUnit Platform を実行するための Java アプリケーションです。
JUnit Jupiter のテストを実行した結果をコンソールに出力できるし、JUnit Vintage のテスト実行エンジンも使用できます。

// An executable `junit-platform-console-standalone-{platform-version}.jar` with all
// dependencies included is published in the {Maven_Central} repository under the
// https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone[junit-platform-console-standalone]
// directory. You can https://docs.oracle.com/javase/tutorial/deployment/jar/run.html[run]
// the standalone `ConsoleLauncher` as shown below.
依存ライブラリを一緒にした実行可能 jar ファイル `junit-platform-console-standalone-{platform-version}.jar` は {Maven_Central} で公開されています。
JUnit Platform リポジトリの https://repo1.maven.org/maven2/org/junit/platform/junit-platform-console-standalone[junit-platform-console-standalone] ディレクトリを参照してください。
jar ファイルは次のように実行します。

`java -jar junit-platform-console-standalone-{platform-version}.jar <<<running-tests-console-launcher-options>>>`

// Here's an example of its output:
実行結果は次のようになるでしょう。

....
├─ JUnit Vintage
│  └─ example.JUnit4Tests
│     └─ standardJUnit4Test ✔
└─ JUnit Jupiter
   ├─ StandardTests
   │  ├─ succeedingTest() ✔
   │  └─ skippedTest() ↷ for demonstration purposes
   └─ A special test case
      ├─ Custom test name containing spaces ✔
      ├─ ╯°□°)╯ ✔
      └─ 😱 ✔

Test run finished after 64 ms
[         5 containers found      ]
[         0 containers skipped    ]
[         5 containers started    ]
[         0 containers aborted    ]
[         5 containers successful ]
[         0 containers failed     ]
[         6 tests found           ]
[         1 tests skipped         ]
[         5 tests started         ]
[         0 tests aborted         ]
[         5 tests successful      ]
[         0 tests failed          ]
....

// .Exit Code
// NOTE: The `{ConsoleLauncher}` exits with a status code of `1` if any containers or tests
// failed. If no tests are discovered and the `--fail-if-no-tests` command-line option is
// supplied, the `ConsoleLauncher` exits with a status code of `2`. Otherwise the exit code
// is `0`.
.終了コード
NOTE: テストコンテナやテストが1つでも失敗すると `{ConsoleLauncher}` はステータスコード `1` で終了します。
コマンドラインオプションで `--fail-if-no-tests` フラグを指定した場合、1つもテストが見つからないときは、ステータスコード `2` で終了します。
それ以外の場合、ステータスコード `0` で終了します。

[[running-tests-console-launcher-options]]
==== コンソールランチャーの引数（フラグ）

----
include::{consoleLauncherOptionsFile}[]
----

[[running-tests-console-launcher-argument-files]]
==== コンソールランチャーの引数（@-files）

// On some platforms you may run into system limitations on the length of a command line
// when creating a command line with lots of options or with long arguments.
OSによっては、実行するコマンドライン文字列の長さが上限値に達してしまう場合があります。

// Since version 1.3, the `ConsoleLauncher` supports _argument files_, also known as
// _@-files_. Argument files are files that themselves contain arguments to be passed to the
// command. When the underlying https://github.com/remkop/picocli[picocli] command line
// parser encounters an argument beginning with the character `@`, it expands the contents
// of that file into the argument list.
JUnit Platform 1.3 から `ConsoleLauncher` は _引数ファイル_ を渡せるようになりました（_@-files_ と呼ばれています）。
引数ファイルはコマンドライン引数を羅列したテキストファイルです。
この機能は https://github.com/remkop/picocli[picocli] のコマンドライン文字列パーサーで実装されており、コマンドライン引数に `@` で始まる項目があれば、対応するファイルの内容をコマンドライン引数に追加するようになっています。

// The arguments within a file can be separated by spaces or newlines. If an argument
// contains embedded whitespace, the whole argument should be wrapped in double or single
// quotes -- for example, `"-f=My Files/Stuff.java"`.
引数ファイルでは、それぞれの引数を空白文字や改行文字で分割します。
引数自体に空白文字を含めるには、その引数全体を一重引用符や二重引用符で囲まなければなりません。
例えば `"-f=My Files/Stuff.java"` のように記述します。

// If the argument file does not exist or cannot be read, the argument will be treated
// literally and will not be removed. This will likely result in an "unmatched argument"
// error message. You can troubleshoot such errors by executing the command with the
// `picocli.trace` system property set to `DEBUG`.
指定した引数ファイルが存在しないか、読み取れない場合、ただの1引数として扱います。
おそらく「使用できない引数」という警告メッセージが出力されるでしょう。
コマンドを実行するとき、システムプロパティ `picocli.trace` に `DEBUG` を指定すると問題の解決に役立つ情報が出力されるでしょう。

// Multiple _@-files_ may be specified on the command line. The specified path may be
// relative to the current directory or absolute.
複数の引数ファイルを使用するときはコマンドライン引数に _@-files_ を複数指定します。
ファイル名を完全パスで指定した場合以外は、実行時ディレクトリからの相対パスとして解釈します。

// You can pass a real parameter with an initial `@` character by escaping it with an
// additional `@` symbol. For example, `@@somearg` will become `@somearg` and will not be
// subject to expansion.
`@` から始まるフラグ名を使いたいときは、`@@` のように2つ続けて記述します。
例えば `@@somearg` は `@somearg` として扱われるようになります（引数ファイルとして展開しません）。

[[running-tests-junit-platform-runner]]
=== JUnit 4 で JUnit Platform を実行する

// [WARNING]
// .The `JUnitPlatform` runner has been deprecated
[WARNING]
.`JUnitPlatform` ランナーは廃止予定です
====
// The `JUnitPlatform` runner was developed by the JUnit team as an interim solution for
// running test suites and tests on the JUnit Platform in a JUnit 4 environment.
JUnit チームが `JUnitPlatform` ランナーを開発したのは、JUnit 4 で作成したテスト（テストスイート）を実行するための暫定措置です。

// In recent years, all mainstream build tools and IDEs provide built-in support for running
// tests directly on the JUnit Platform.
ここ数年の間に、さまざまなビルドツールや IDE は JUnit Platform を直接的に実行できるようになりました。

// In addition, the introduction of `@Suite` support provided by the
// `junit-platform-suite-engine` module makes the `JUnitPlatform` runner obsolete. See
// <<junit-platform-suite-engine>> for details.
また、`junit-platform-suite-engine` モジュールで `@Suite` が使えるようになったため、`JUnitPlatform` ランナーは不要になりました。
詳しくは <<junit-platform-suite-engine>> を参照してください。

// The `JUnitPlatform` runner has therefore been deprecated in JUnit Platform 1.8 and will be
// removed in JUnit Platform 2.0.
以上の理由により、JUnit Platform 1.8 から `JUnitPlatform` ランナーは廃止予定になりました。
おそらく JUnit Platform 2.0 で削除するでしょう。

// If you are using the `JUnitPlatform` runner, please migrate to the `@Suite` support.
`JUnitPlatform` ランナーを使用している場合は `@Suite` に対応した `junit-platform-suite-engine` モジュールへ移行してください。
====

// The `JUnitPlatform` runner is a JUnit 4 based `Runner` which enables you to run any test
// whose programming model is supported on the JUnit Platform in a JUnit 4 environment --
// for example, a JUnit Jupiter test class.
`JUnitPlatform` ランナーは、JUnit Platform の提供するプログラミングモデルで作成したテストを、JUnit 4 の環境で実行するテストランナーです。

// Annotating a class with `@RunWith(JUnitPlatform.class)` allows it to be run with IDEs and
// build systems that support JUnit 4 but do not yet support the JUnit Platform directly.
テストクラスを `@RunWith(JUnitPlatform.class)` で修飾すれば、JUnit Platform には対応していないけど JUnit 4 に対応した IDE やビルドツールからテストを実行できるようになります。

// NOTE: Since the JUnit Platform has features that JUnit 4 does not have, the runner is
// only able to support a subset of the JUnit Platform functionality, especially with regard
// to reporting (see <<running-tests-junit-platform-runner-technical-names>>).
NOTE: JUnit Platform には JUnit 4 にない機能が存在します。
したがって `JUnitPlatform` ランナーは JUnit Platform の提供する機能の一部だけしか対応していません。
特にテスト結果のレポート機能には違いがあります（<<running-tests-junit-platform-runner-technical-names>> を参照）。

[[running-tests-junit-platform-runner-setup]]
==== 準備

// You need the following artifacts and their dependencies on the classpath. See
// <<dependency-metadata>> for details regarding group IDs, artifact IDs, and versions.
`JUnitPlatform` ランナーを使用するには以降で説明するアーティファクトや依存ライブラリをクラスパスに配置しなければなりません。
具体的なグループID、アーティファクトID、バージョンについては <<dependency-metadata>> を参照してください。

[[running-tests-junit-platform-runner-setup-explicit-dependencies]]
===== 明示的な依存関係

// * `junit-platform-runner` in _test_ scope: location of the `JUnitPlatform` runner
// * `junit-{junit4-version}.jar` in _test_ scope: to run tests using JUnit 4
// * `junit-jupiter-api` in _test_ scope: API for writing tests using JUnit Jupiter,
//   including `@Test`, etc.
// * `junit-jupiter-engine` in _test runtime_ scope: implementation of the `TestEngine` API
//   for JUnit Jupiter
* `junit-platform-runner` `test` スコープ。`JUnitPlatform` ランナーそのものです
* `junit-{junit4-version}.jar` `test` スコープ。JUnit 4 です
* `junit-jupiter-api` `test` スコープ。JUnit Jupiter でテストを作成するための API です
* `junit-jupiter-engine` `testRuntime` スコープ。JUnit Jupiter のための `TestEngine` 実装です

[[running-tests-junit-platform-runner-setup-transitive-dependencies]]
===== 推移的依存関係

// * `junit-platform-suite-api` in _test_ scope
// * `junit-platform-suite-commons` in _test_ scope
// * `junit-platform-launcher` in _test_ scope
// * `junit-platform-engine` in _test_ scope
// * `junit-platform-commons` in _test_ scope
// * `opentest4j` in _test_ scope
* `junit-platform-suite-api` `test` スコープ。
* `junit-platform-suite-commons` `test` スコープ。
* `junit-platform-launcher` `test` スコープ。
* `junit-platform-engine` `test` スコープ。
* `junit-platform-commons` `test` スコープ。
* `opentest4j` `test` スコープ。

[[running-tests-junit-platform-runner-technical-names]]
==== 表示名と部品名

// To define a custom _display name_ for the class run via `@RunWith(JUnitPlatform.class)`
// annotate the class with `@SuiteDisplayName` and provide a custom value.
`@RunWith(JUnitPlatform.class)` で修飾したテストクラスを実行するときの _表示名_ を変更するには、テストクラスを `@SuiteDisplayName` で修飾して、設定します。

// By default, _display names_ will be used for test artifacts; however, when the
// `JUnitPlatform` runner is used to execute tests with a build tool such as Gradle or
// Maven, the generated test report often needs to include the _technical names_ of test
// artifacts — for example, fully qualified class names — instead of shorter display names
// like the simple name of a test class or a custom display name containing special
// characters. To enable technical names for reporting purposes, declare the
// `@UseTechnicalNames` annotation alongside `@RunWith(JUnitPlatform.class)`.
初期設定では、テストアーティファクトの _表示名_ を使うようになっています。
しかし、Gradle や Maven 等のビルドツールで `JUnitPlatform` ランナーを実行して、テスト結果のレポートを作成するときは、テストアーティファクトの _部品名_ が必要になります。
例えば、テストクラスの省略形（表示名）や特殊文字を含む表示名ではなく、完全修飾クラス名が必要になる、といった具合です。
テスト結果のレポートを作成するときに部品名を使用できるようにするには、テストクラスを `@UseTechnicalNames` で修飾してください。

// Note that the presence of `@UseTechnicalNames` overrides any custom display name
// configured via `@SuiteDisplayName`.
テストクラスを `@UseTechnicalNames` で修飾すると、`@SuiteDisplayName` で指定した表示名を上書きします。

[[running-tests-junit-platform-runner-single-test]]
==== 単独のテストクラス

// One way to use the `JUnitPlatform` runner is to annotate a test class with
// `@RunWith(JUnitPlatform.class)` directly. Please note that the test methods in the
// following example are annotated with `org.junit.jupiter.api.Test` (JUnit Jupiter), not
// `org.junit.Test` (JUnit 4). Moreover, in this case the test class must be `public`;
// otherwise, some IDEs and build tools might not recognize it as a JUnit 4 test class.
テストクラスを `@RunWith(JUnitPlatform.class)` で修飾するのは `JUnitPlatform` ランナーを使用する方法の1つです。
次のコード例ではテストメソッドを JUnit Jupiter の `@Test` で修飾しているのがポイントです（ `org.junit.Test` ではなく `org.junit.jupiter.api.Test` を使用しています）。
さらに、テストクラスの可視性が `public` になっているのもポイントです。
そうしないと JUnit 4 のテストクラスとして認識しない IDE やビルドツールがあるからです。

[source,java,indent=0]
----
include::{testDir}/example/JUnitPlatformClassDemo.java[tags=user_guide]
----

[[running-tests-junit-platform-runner-test-suite]]
==== テストスイート

// If you have multiple test classes you can create a test suite as can be seen in the
// following example.
次のコード例のように、複数のテストクラスをまとめたテストスイートがあるとします。

[source,java,indent=0]
----
include::{testDir}/example/JUnitPlatformSuiteDemo.java[tags=user_guide]
----

// The `JUnitPlatformSuiteDemo` will discover and run all tests in the `example` package and
// its subpackages. By default, it will only include test classes whose names either begin
// with `Test` or end with `Test` or `Tests`.
`JUnitPlatformSuiteDemo` クラスは `example` パッケージとそのサブパッケージに配置した全てのテストクラスを発見し、実行します。
初期設定では `Test` で始まるか、`Test` や `Tests` で終わる名前のクラスが対象になります。

// .Additional Configuration Options
// NOTE: There are more configuration options for discovering and filtering tests than just
// `@SelectPackages`. Please consult the Javadoc of the `{suite-api-package}` package for
// further details.
.さらに細かい設定
NOTE: `@SelectPackages` 以外にもテストを発見したり選択したりするための設定項目があります。
詳しくは `{suite-api-package}` の Javadoc を参照してください。

// WARNING: Test classes and suites annotated with `@RunWith(JUnitPlatform.class)`
// **cannot** be executed directly on the JUnit Platform (or as a "JUnit 5" test as
// documented in some IDEs). Such classes and suites can only be executed using JUnit 4
// infrastructure.
WARNING: `@RunWith(JUnitPlatform.class)` で修飾したテストスイートクラスやテストクラスは JUnit Platform から直接的に実行 **できません** （IDE のドキュメントに記載されている "JUnit 5" テストとしても実行できません）。
JUnit 4 でしか実行できません。

[[running-tests-config-params]]
=== 設定パラメータの構成

// In addition to instructing the platform which test classes and test engines to include,
// which packages to scan, etc., it is sometimes necessary to provide additional custom
// configuration parameters that are specific to a particular test engine, listener, or
// registered extension. For example, the JUnit Jupiter `TestEngine` supports _configuration
// parameters_ for the following use cases.
テストクラスの選択や、テスト実行エンジンの指定、テストクラスを探索するパッケージの指定といった基盤機能の説明に加えて、特定のテスト実行エンジンやリスナー、拡張機能に固有の設定パラメータについても理解しておいたほうがいいでしょう。
例えば、JUnit Jupiter テスト実行エンジンには次のようなユースケースを想定した設定パラメータが用意されています。

- <<writing-tests-test-instance-lifecycle-changing-default>>
- <<extensions-registration-automatic-enabling>>
- <<extensions-conditions-deactivation>>
- <<writing-tests-display-name-generator-default>>

// _Configuration Parameters_ are text-based key-value pairs that can be supplied to test
// engines running on the JUnit Platform via one of the following mechanisms.
_設定パラメータ_ は文字列ベースのキーと値の対の集合です。
JUnit Platform を実行するときは次のように注入します。

// 1. The `configurationParameter()` and `configurationParameters()` methods in the
//   `LauncherDiscoveryRequestBuilder` which is used to build a request supplied to the
//   <<launcher-api, `Launcher` API>>. When running tests via one of the tools provided
//   by the JUnit Platform you can specify configuration parameters as follows:
//   * <<running-tests-console-launcher,Console Launcher>>: use the `--config`
//     command-line option.
//   * <<running-tests-build-gradle-config-params,Gradle>>: use the
//     `systemProperty` or `systemProperties` DSL.
//   * <<running-tests-build-maven-config-params,Maven Surefire provider>>: use the
//     `configurationParameters` property.
// 2. JVM system properties.
// 3. The JUnit Platform configuration file: a file named `junit-platform.properties` in the
//   root of the class path that follows the syntax rules for a Java `Properties` file.
1. <<launcher-api, `Launcher` API>> のパラメータを構築する `LauncherDiscoveryRequestBuilder` の `configurationParameter()` メソッドや `configurationParameters()` メソッドを使用します。
  JUnit Platform を実行するツールによって渡し方は異なります。
  * <<running-tests-console-launcher>>: `--config` フラグを使用します。
  * <<running-tests-build-gradle-config-params>>: DSL を使用します（`systemProperty` や `systemProperties`）。
  * <<running-tests-build-maven-config-params>>: `configurationParameters` 要素を使用します。
2. JVM のシステムプロパティを使用します。
3. JUnit Platform の独自設定ファイルを使用します。Java の `Properties` ファイルとして作成した `junit-platform.properties` をクラスパスの最上位に配置します。

// NOTE: Configuration parameters are looked up in the exact order defined above.
// Consequently, configuration parameters supplied directly to the `Launcher` take
// precedence over those supplied via system properties and the configuration file.
// Similarly, configuration parameters supplied via system properties take precedence over
// those supplied via the configuration file.
NOTE: 設定パラメータを読み取る順序は固定されています。
つまり、`Launcher` に直接指定したパラメータは、システムプロパティや設定ファイルなど他の方法で指定したパラメータを上書きするのです。
同様に、システムプロパティで指定したパラメータは、設定ファイルで指定したパラメータを上書きします。

[[running-tests-config-params-deactivation-pattern]]
==== パターンマッチ記法

// This section describes the pattern matching syntax that is applied to the _configuration
// parameters_ used for the following features.
このセクションでは、次のような機能のために _設定パラメータ_ へ記述するパターンマッチの記法を説明します。

- <<extensions-conditions-deactivation>>
- <<launcher-api-listeners-custom-deactivation>>

// If the value for the given _configuration parameter_ consists solely of an asterisk
// (`+*+`), the pattern will match against all candidate classes. Otherwise, the value will
// be treated as a comma-separated list of patterns where each pattern will be matched
// against the fully qualified class name (_FQCN_) of each candidate class. Any dot (`.`) in
// a pattern will match against a dot (`.`) or a dollar sign (`$`) in a FQCN. Any asterisk
// (`+*+`) will match against one or more characters in a FQCN. All other characters in a
// pattern will be matched one-to-one against a FQCN.
設定値の文字列パターンがアスタリスク {asterisk} 1つだけなら、全ての候補クラスにマッチします。
そうでなければ、設定値をカンマ区切り文字列（それぞれの文字列パターンは完全修飾クラス名（FQCN））と見做して、それぞれの文字列パターンと候補クラスが一致するか評価します。
文字列パターン中のドット（`.`）は、FQCN 中のドット（`.`）か、＄マーク（`$`）とマッチします。
文字列パターン中のアスタリスク（{asterisk}）は、FQCN 中の連続する任意の1文字以上の文字列とマッチします。
それ以外の文字は、FQCN 中の同じ文字とマッチします。

// Examples:
具体例です。

// - `+*+`: matches all candidate classes.
// - `+org.junit.*+`: matches all candidate classes under the `org.junit` base package and
//   any of its subpackages.
// - `+*.MyCustomImpl+`: matches every candidate class whose simple class name is exactly
//   `MyCustomImpl`.
// - `+*System*+`: matches every candidate class whose FQCN contains `System`.
// - `+*System*+, +*Unit*+`: matches every candidate class whose FQCN contains `System` or
//   `Unit`.
// - `org.example.MyCustomImpl`: matches the candidate class whose FQCN is exactly
//   `org.example.MyCustomImpl`.
// - `org.example.MyCustomImpl, org.example.TheirCustomImpl`: matches candidate classes whose
//   FQCN is exactly `org.example.MyCustomImpl` or `org.example.TheirCustomImpl`.
- {asterisk}: 全ての候補クラスとマッチします
- org.junit.{asterisk}: `org.junit` パッケージとそのサブパッケージに配置した全ての候補クラスとマッチします
  any of its subpackages.
- {asterrisk}.MyCustomImpl: 単純クラス名が `MyCustomImpl` になる全ての候補クラスとマッチします
- {asterrisk}System{asterrisk}: FQCN に `System` を含む全ての候補クラスとマッチします
- {asterrisk}System{asterrisk}, {asterrisk}Unit{asterrisk}: FQCN に `System` あるいは `Unit` を含む全ての候補クラスとマッチします
- `org.example.MyCustomImpl`: FQCN が完全に `org.example.MyCustomImpl` と一致する候補クラスとマッチします
- `org.example.MyCustomImpl, org.example.TheirCustomImpl`: FQCN が完全に `org.example.MyCustomImpl` と一致する、あるいは `org.example.TheirCustomImpl` と一致する候補クラスとマッチします

[[running-tests-tags]]
=== タグ

// Tags are a JUnit Platform concept for marking and filtering tests. The programming model
// for adding tags to containers and tests is defined by the testing framework. For example,
// in JUnit Jupiter based tests, the `@Tag` annotation (see
// <<writing-tests-tagging-and-filtering>>) should be used. For JUnit 4 based tests, the
// Vintage engine maps `@Category` annotations to tags (see
// <<migrating-from-junit4-categories-support>>). Other testing frameworks may define their
// own annotation or other means for users to specify tags.
タグはテストクラスに印を付けたり、テストクラスを選択するための機能です。
テストコンテナやテストクラスにタグを追加するためのプログラミングモデルは、テストフレームワークが提供しています。
例えば、JUnit Jupiter でテストを作成するなら `@Tag` アノテーション（<<writing-tests-tagging-and-filtering>> を参照）を使用し、JUnit 4 で作成したテストなら Vintage テスト実行エンジンが `@Category` アノテーションをタグに写像します（<<migrating-from-junit4-categories-support>> を参照）。
他のテストフレームワークも、ユーザーがタグを定義するために使用できる独自のアノテーションを提供しているでしょう。

[[running-tests-tag-syntax-rules]]
==== タグの構文規則

// Regardless how a tag is specified, the JUnit Platform enforces the following rules:
タグを指定する方法がなんであれ、JUnit Platform は次の規則で解釈します。

// * A tag must not be `null` or _blank_.
// * A _trimmed_ tag must not contain whitespace.
// * A _trimmed_ tag must not contain ISO control characters.
// * A _trimmed_ tag must not contain any of the following _reserved characters_.
// - `,`: _comma_
// - `(`: _left parenthesis_
// - `)`: _right parenthesis_
// - `&`: _ampersand_
// - `|`: _vertical bar_
// - `!`: _exclamation point_
* `null` や _空白文字_ は使用できません
* トリムしたタグ値には、空白文字を使用できません
* トリムしたタグ値には、ISO 制御文字を使用できません
* トリムしたタグ値には、次のいずれかの文字（_予約文字_）を使用できません
- `,`: _カンマ_
- `(`: _開き括弧_
- `)`: _閉じ括弧_
- `&`: _アンパサンド_
- `|`: _縦線_
- `!`: _感嘆符_

NOTE: In the above context, "trimmed" means that leading and trailing whitespace
characters have been removed.
NOTE: 「トリムした」というのは、文字列の先頭や末尾から連続する1文字以上の空白文字を削除するということです。

[[running-tests-tag-expressions]]
==== タグ記法

// Tag expressions are boolean expressions with the operators `!`, `&` and `|`. In addition,
// `(` and `)` can be used to adjust for operator precedence.
タグ記法は `!` と `&` と `|` を演算子として使用するブール式です。
`(` と `)` で演算子の優先度を変更できるようになっています。

// Two special expressions are supported, `any()` and `none()`, which select all tests _with_
// any tags at all, and all tests _without_ any tags, respectively.
// These special expressions may be combined with other expressions just like normal tags.
特殊記法として `any()` と `none()` を使用できます。
前者はあらゆるタグと _一致する_ ことを評価し、後者はあらゆるタグと _一致しない_ ことを評価します。
これらの特殊記法は通常のタグ記法と組み合わせて使用できます。

// .Operators (in descending order of precedence)
// |===
// | Operator | Meaning | Associativity
//
// | `!`      | not     | right
// | `&`      | and     | left
// | `\|`     | or      | left
// |===
.演算子の優先度（降順：上のほうが優先）
|===
| 演算子   | 意味    | 結合の方向

| `!`      | 否定    | 右
| `&`      | かつ    | 左
| `\|`     | あるいは| 左
|===

// If you are tagging your tests across multiple dimensions, tag expressions help you to
// select which tests to execute. When tagging by test type (e.g., _micro_, _integration_,
// _end-to-end_) and feature (e.g., *product*, *catalog*, *shipping*), the following tag
// expressions can be useful.
テストを複数の軸でタグ付けしているときは、タグ記法を使うと実行するテストを選択するのに役立ちます。
タグでテスト種類（_micro_、_integration_、_end-to-end_ など）や機能（*product*、*catalog*、*shipping* など）を説明しているときは、次のように使用できます。

// [%header,cols="40,60"]
// |===
// | Tag Expression
// | Selection

// | +product+
// | all tests for *product*

// | +catalog \| shipping+
// | all tests for *catalog* plus all tests for *shipping*

// | +catalog & shipping+
// | all tests for the intersection between *catalog* and *shipping*

// | +product & !end-to-end+
// | all tests for *product*, but not the _end-to-end_ tests

// | +(micro \| integration) & (product \| shipping)+
// | all _micro_ or _integration_ tests for *product* or *shipping*
// |===
|===
| タグ記法
| 選択されたテストクラス

| +product+
| *product* を指定したテストクラス

| +catalog \| shipping+
| *catalog* あるいは *shipping* を指定したテストクラス

| +catalog & shipping+
| *catalog* と *shipping* を指定したテストクラス

| +product & !end-to-end+
| *product* を指定したテストクラスの中で *end-to-end* を指定していないもの

| +(micro \| integration) & (product \| shipping)+
| _micro_ あるいは _integration_ を指定したテストクラスの中で *product* あるいは *shipping* を指定しているもの
|===

[[running-tests-capturing-output]]
=== 標準出力や標準エラー出力をキャプチャーする

// Since version 1.3, the JUnit Platform provides opt-in support for capturing output
// printed to `System.out` and `System.err`. To enable it, set the
// `junit.platform.output.capture.stdout` and/or `junit.platform.output.capture.stderr`
// <<running-tests-config-params, configuration parameter>> to `true`. In addition, you may
// configure the maximum number of buffered bytes to be used per executed test or container
// using `junit.platform.output.capture.maxBuffer`.
JUnit Platform は 1.3 から `System.out` と `System.err` に出力した内容をキャプチャーする機能をオプトイン方式で提供しています。
この機能を有効化するには、システムプロパティや設定ファイル（<<running-tests-config-params>> を参照）で `junit.platform.output.capture.stdout` あるいは `junit.platform.output.capture.stderr` に `true` を設定します。
また、実行時の出力バッファサイズをテストコンテナやテストクラスごとに変更するときは `junit.platform.output.capture.maxBuffer` を設定します。

// If enabled, the JUnit Platform captures the corresponding output and publishes it as a
// report entry using the `stdout` or `stderr` keys to all registered
// `{TestExecutionListener}` instances immediately before reporting the test or container as
// finished.
この機能を有効化すると、JUnit Platform は標準出力（標準エラー出力）をキャプチャーします。
キャプチャーした内容は、登録済みの `{TestExecutionListener}` へ発行するレポート情報のキー `stdout`（`stderr`）で参照できます。
リスナーインスタンスは、テストコンテナやテストクラスの実行が完了する前に、レポート情報を参照できます。

// Please note that the captured output will only contain output emitted by the thread that
// was used to execute a container or test. Any output by other threads will be omitted
// because particularly when
// <<writing-tests-parallel-execution, executing tests in parallel>> it would be impossible
// to attribute it to a specific test or container.
なお、テストコンテナやテストクラスを実行したスレッドが標準出力（標準エラー出力）に出力した内容しかキャプチャーできません。
他のスレッドが出力した内容は無視されてしまいますし、特に <<writing-tests-parallel-execution, 並列実行>> させている場合は、どのテストコンテナやテストクラスが出力した内容なのか、後から区別できません。

[[running-tests-listeners]]
=== リスナーを使用する

// The JUnit Platform provides the following listener APIs that allow JUnit, third parties,
// and custom user code to react to events fired at various points during the discovery and
// execution of a `TestPlan`.
JUnit Platform の提供するリスナーAPIを使用すると、`TestPlan` がテストを発見したり実行したりする途中のさまざまなポイントで発火するイベントに、JUnit やサードパーティライブラリだけでなく、ユーザーの作成したコードが反応できるようになります。

// * `{LauncherSessionListener}`: receives events when a `{LauncherSession}` is opened and
//   closed.
// * `{LauncherDiscoveryListener}`: receives events that occur during test discovery.
// * `{TestExecutionListener}`: receives events that occur during test execution.
* `{LauncherSessionListener}`: `{LauncherSession}` が開かれた、あるいは、閉じられたイベントを受信します
* `{LauncherDiscoveryListener}`: テストの探索中に発生したイベントを受信します
* `{TestExecutionListener}`: テストの実行中に発生したイベントを受信します

// The `LauncherSessionListener` API is typically implemented by build tools or IDEs and
// registered automatically for you in order to support some feature of the build tool or IDE.
基本的に `LauncherDiscoveryListener` API を使用するのはビルドツールや IDE が独自の機能を提供するためです。
テスト実行時に自動的に登録する場合が多いでしょう。

// The `LauncherDiscoveryListener` and `TestExecutionListener` APIs are often implemented in
// order to produce some form of report or to display a graphical representation of the test
// plan in an IDE. Such listeners may be implemented and automatically registered by a build
// tool or IDE, or they may be included in a third-party library – potentially registered
// for you automatically. You can also implement and register your own listeners.
`LauncherDiscoveryListener` と `TestExecutionListener` API を使用することが多いのは、任意の形式のテスト結果レポートを生成したり、IDE 内の GUI でテストの実行計画を表示したりする場合です。
やはりビルドツールや IDE の提供する実装クラスを実行時に自動的に登録する場合が多いでしょう。
サードパーティライブラリを含む場合もあるようです（いずれにしても自動的に登録するようになっています）。
独自のリスナーを実装、登録することもできます。

// For details on registering and configuring listeners, see the following sections of this
// guide.
リスナーを登録したり構成したりする方法については次のドキュメントを参照してください。

* <<launcher-api-launcher-session-listeners-custom>>
* <<launcher-api-launcher-discovery-listeners-custom>>
* <<launcher-api-listeners-custom>>
* <<launcher-api-listeners-config>>
* <<launcher-api-listeners-custom-deactivation>>

// The JUnit Platform provides the following listeners which you may wish to use with your
// test suite.
JUnit Platform は次のようなリスナーを提供しています。

// <<running-tests-listeners-flight-recorder>> ::
//   `FlightRecordingExecutionListener` and `FlightRecordingDiscoveryListener` that generate
//   Java Flight Recorder events during test discovery and execution.
//
// `{LegacyXmlReportGeneratingListener}` ::
//   `TestExecutionListener` that generates XML reports compatible with the de facto
//   standard for JUnit 4 based test reports. See <<junit-platform-reporting>> for
//   details.
//
// `{LoggingListener}` ::
//   `TestExecutionListener` for logging informational messages for all events via a
//   `BiConsumer` that consumes `Throwable` and `Supplier<String>`.
//
// `{SummaryGeneratingListener}` ::
//   `TestExecutionListener` that generates a summary of the test execution which can be
//   printed via a `PrintWriter`.
//
// `{UniqueIdTrackingListener}` ::
//   `TestExecutionListener` that that tracks the unique IDs of all tests that were skipped
//   or executed during the execution of the `TestPlan` and generates a file containing the
//   unique IDs once execution of the `TestPlan` has finished.
<<running-tests-listeners-flight-recorder>> ::
  `FlightRecordingExecutionListener` と `FlightRecordingDiscoveryListener`。
  テストの探索時と実行時に Java Flight Recorder のイベントを発行します。

`{LegacyXmlReportGeneratingListener}` ::
  `TestExecutionListener` が、JUnit 4 のテスト結果レポート形式として事実上の標準になっている XML 形式のテスト結果レポートを生成します。
  詳しくは <<junit-platform-reporting>> を参照してください。

`{LoggingListener}` ::
  `TestExecutionListener` の生成する全てのログメッセージを `BiConsumer` の消費するイベントとして生成します（`Throwable` と `Supplier<String>` として渡します）。

`{SummaryGeneratingListener}` ::
  `TestExecutionListener` が実行したテストの概要を `PrintWriter` で（標準出力に）出力します。

`{UniqueIdTrackingListener}` ::
  `TestExecutionListener` の実行する `TestPlan` がスキップおよび実行した全てのテストそれぞれに固有の ID を割り当てて追跡し、 `TestPlan` が完了したら追跡した全ての ID をファイルに記録します。

[[running-tests-listeners-flight-recorder]]
==== Java Flight Recorder を使用する

// Since version 1.7, the JUnit Platform provides opt-in support for generating Flight
// Recorder events. https://openjdk.java.net/jeps/328[JEP 328] describes the Java Flight
// Recorder (JFR) as:
JUnit Platform は 1.7 から Java Flight Recorder のイベントを生成する機能をオプトイン方式で提供しています。
https://openjdk.java.net/jeps/328[JEP 328] は Java Flight Recorder（JFR）を次のように説明しています。

// NOTE: Flight Recorder records events originating from applications, the JVM and the OS.
// Events are stored in a single file that can be attached to bug reports and examined by
// support engineers, allowing after-the-fact analysis of issues in the period leading up
// to a problem.
NOTE: Flight Recorder はアプリケーション（JVM や OS）の生成したイベントを記録します。
イベントは単一ファイルへ記録します。
イベントを記録したファイルはバグ報告へ添付したり、サポートエンジニアが調査するために使用したりできるので、問題が発生するまでに起きていたことを後から分析できます。

// In order to record Flight Recorder events generated while running tests, you need to:
テストを実行しながら Flight Recorder イベントを記録するには次のような設定をしなければなりません。

// 1. Ensure that you are using either Java 8 Update 262 or higher or Java 11 or later.
// 2. Provide the `org.junit.platform.jfr` module (`junit-platform-jfr-{platform-version}.jar`)
//    on the class-path or module-path at test runtime.
// 3. Start flight recording when launching a test run. Flight Recorder can be started via
//    java command line option:
//
//    -XX:StartFlightRecording:filename=...
1. Java 8 Update 262 以降、あるいは Java 11 以降を使用します。
2. `org.junit.platform.jfr` モジュール（`junit-platform-jfr-{platform-version}.jar`）を、テストランタイムの参照できるクラスパスやモジュールパスへ配置します。
3. テストを実行するときにフライトレコード機能を有効化します。具体的には JVM のコマンドライン引数に次のようなフラグを指定します。

   -XX:StartFlightRecording:filename=...

// Please consult the manual of your build tool for the appropriate commands.
適切なコマンドライン引数を構成するには、使用しているビルドツールのドキュメントを参照してください。

// To analyze the recorded events, use the
// https://docs.oracle.com/en/java/javase/14/docs/specs/man/jfr.html[jfr]
// command line tool shipped with recent JDKs or open the recording file with
// https://jdk.java.net/jmc/[JDK Mission Control].
JDK と一緒に配布されているコマンドラインツールの https://docs.oracle.com/en/java/javase/14/docs/specs/man/jfr.html[jfr] や、https://jdk.java.net/jmc/[JDK Mission Control] を使用すれば、記録したイベントを分析できます。

// WARNING: Flight Recorder support is currently an _experimental_ feature. You're invited to
// give it a try and provide feedback to the JUnit team so they can improve and eventually
// <<api-evolution, promote>> this feature.
WARNING: 今のところ Flight Recorder のイベント記録機能は _実験的な機能です_。
JUnit チームがこの機能を改善して、正式機能へ <<api-evolution, 昇格>> できるよう、試用してフィードバックを提供してください。
