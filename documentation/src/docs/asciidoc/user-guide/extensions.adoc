[[extensions]]
== 拡張モデル

[[extensions-overview]]
=== 概要

// In contrast to the competing `Runner`, `TestRule`, and `MethodRule` extension points in
// JUnit 4, the JUnit Jupiter extension model consists of a single, coherent concept: the
// `Extension` API. Note, however, that `Extension` itself is just a marker interface.
JUnit 4 の拡張ポイントである `Runner` や `TestRule` や `MethodRule` に比べると、JUnit Jupiter の拡張モデル `Extension` API は単純で分かりやすい考え方になっています。
なお、`Extension` 自体はただのマーカーインターフェイスです。

[[extensions-registration]]
=== 拡張機能を登録する

// Extensions can be registered _declaratively_ via
// <<extensions-registration-declarative,`@ExtendWith`>>, _programmatically_ via
// <<extensions-registration-programmatic,`@RegisterExtension`>>, or _automatically_ via
// Java's <<extensions-registration-automatic,`ServiceLoader`>> mechanism.
拡張機能を登録する方法は3種類あります。
<<extensions-registration-declarative,`@ExtendWith`>> を使用する _宣言的な_ 登録と、<<extensions-registration-programmatic,`@RegisterExtension`>> を使用する _手続き的な_ 登録と、Java の <<extensions-registration-automatic,`ServiceLoader`>> を使用する _自動的な_ 登録です。

[[extensions-registration-declarative]]
==== 宣言的に登録する方法

// Developers can register one or more extensions _declaratively_ by annotating a test
// interface, test class, test method, or custom _<<writing-tests-meta-annotations,composed
// annotation>>_ with `@ExtendWith(...)` and supplying class references for the extensions to
// register. As of JUnit Jupiter 5.8, `@ExtendWith` may also be declared on fields or on
// parameters in test class constructors, in test methods, and in `@BeforeAll`, `@AfterAll`,
// `@BeforeEach`, and `@AfterEach` lifecycle methods.
開発者は `@ExtendWith(...)` に（あるいは自作の <<writing-tests-meta-annotations, 合成アノテーション>> に）登録する拡張機能のクラス参照を指定することで、テストインターフェイスやテストクラスやテストメソッドへ1つ以上の拡張機能を登録できます。
JUnit Jupiter の 5.8 からは、フィールドや、テストクラスのコンストラクタあるいはテストメソッドあるいはライフサイクルメソッドのメソッド引数を `@ExtendWith` で修飾できるようになりました。

// For example, to register a `WebServerExtension` for a particular test method, you would
// annotate the test method as follows. We assume the `WebServerExtension` starts a local web
// server and injects the server's URL into parameters annotated with `@WebServerUrl`.
例えば、`WebServerExtension` をテストメソッドへ登録するときは次のように記述します。
ここでは、`WebServerExtension` が HTTP サーバーを起動し、`@WebServerUrl` で修飾したメソッド引数へサーバーのURLを注入することを想定しています。

[source,java,indent=0]
----
@Test
@ExtendWith(WebServerExtension.class)
void getProductList(@WebServerUrl String serverUrl) {
	WebClient webClient = new WebClient();
	// Use WebClient to connect to web server using serverUrl and verify response
	assertEquals(200, webClient.get(serverUrl + "/products").getResponseStatus());
}
----

// To register the `WebServerExtension` for all tests in a particular class and its
// subclasses, you would annotate the test class as follows.
あるクラスやそのサブクラスに定義した全てのテストメソッドで使用するために `WebServerExtension` を登録するには、テストクラスを次のように修飾します。

[source,java,indent=0]
----
@ExtendWith(WebServerExtension.class)
class MyTests {
	// ...
}
----

// Multiple extensions can be registered together like this:
`@ExtendWith` には複数の拡張機能（クラス参照）を登録できます。

[source,java,indent=0]
----
@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })
class MyFirstTests {
	// ...
}
----

// As an alternative, multiple extensions can be registered separately like this:
それぞれの拡張機能ごとに `@ExtendWith` を記述することもできます。

[source,java,indent=0]
----
@ExtendWith(DatabaseExtension.class)
@ExtendWith(WebServerExtension.class)
class MySecondTests {
	// ...
}
----

// [TIP]
// .Extension Registration Order
[TIP]
.拡張機能の登録順序
====
// Extensions registered declaratively via `@ExtendWith` at the class level, method level, or
// parameter level will be executed in the order in which they are declared in the source
// code. For example, the execution of tests in both `MyFirstTests` and `MySecondTests` will
// be extended by the `DatabaseExtension` and `WebServerExtension`, **in exactly that order**.
クラスやメソッドやメソッド引数について宣言的に登録した拡張は、ソースコードに記述したとおりの順番で登録されます。
例えば、前のコード例の `MyFirstTest` と `MySecondTests` なら、どちらも `DatabaseExtension` と `WebServerExtension` の **見た目の順番通り** に拡張機能を登録します。
====

// If you wish to combine multiple extensions in a reusable way, you can define a custom
// _<<writing-tests-meta-annotations,composed annotation>>_ and use `@ExtendWith` as a
// _meta-annotation_ as in the following code listing. Then `@DatabaseAndWebServerExtension`
// can be used in place of `@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })`.
複数の拡張機能の組み合わせを再利用できるようにしたければ、`@ExtendWith` を _メタアノテーション_ として使用する独自の _<<writing-tests-meta-annotations, 合成アノテーション>>_ を作成すればいいでしょう。
そうすれば、`@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })` を `@DatabaseAndWebServerExtension` に置き換えられます。

[source,java,indent=0]
----
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@ExtendWith({ DatabaseExtension.class, WebServerExtension.class })
public @interface DatabaseAndWebServerExtension {
}
----

// The above examples demonstrate how `@ExtendWith` can be applied at the class level or at
// the method level; however, for certain use cases it makes sense for an extension to be
// registered declaratively at the field or parameter level. Consider a
// `RandomNumberExtension` that generates random numbers that can be injected into a field or
// via a parameter in a constructor, test method, or lifecycle method. If the extension
// provides a `@Random` annotation that is meta-annotated with
// `@ExtendWith(RandomNumberExtension.class)` (see listing below), the extension can be used
// transparently as in the following `RandomNumberDemo` example.
前の例ではクラスやメソッドを `@ExtendWith` で修飾していました。
しかし、フィールドやメソッド引数に対して拡張機能を登録するほうが役に立つ場合があるのです。
乱数を生成する拡張機能があるとして、生成した乱数をフィールドやコンストラクタ引数、テストメソッドの引数、ライフサイクルメソッドの引数に注入できる場合を考えてみましょう。
なお、この拡張機能は `@ExtendWith(RandomNumberExtension.class)` をメタアノテーションとする `@Random` アノテーションを提供するものとします。
この拡張機能は次のように使用できるでしょう。

[source,java,indent=0]
----
include::{testDir}/example/extensions/Random.java[tags=user_guide]
----

[source,java,indent=0]
----
include::{testDir}/example/extensions/RandomNumberDemo.java[tags=user_guide]
----

// [TIP]
// .Extension Registration Order for `@ExtendWith` on Fields
[TIP]
.フィールドを `@ExtendWith` で修飾した場合の拡張機能の登録順序
====
// Extensions registered declaratively via `@ExtendWith` on fields will be ordered relative
// to `@RegisterExtension` fields and other `@ExtendWith` fields using an algorithm that is
// deterministic but intentionally nonobvious. However, `@ExtendWith` fields can be ordered
// using the `@Order` annotation. See the <<extensions-registration-programmatic-order,
// Extension Registration Order>> tip for `@RegisterExtension` fields for details.
フィールドを `@ExtendWith` で修飾して宣言的に登録した拡張機能の登録順は、`@RegisterExtension` で修飾したフィールドや `@ExtendWith` で修飾した他のフィールドの相対的な関係性を考慮する、意図的にわかりにくくした決定論的アルゴリズムによって決まります。
しかし、`@ExtendWith` で修飾したフィールド（の登録する拡張機能）の順序は `@Order` アノテーションで変更できます。
詳しくは `@RegisterExtension` で修飾したフィールドに関する <<extensions-registration-programmatic-order, 拡張機能の登録順序>> の説明を参照してください。
====

// NOTE: `@ExtendWith` fields may be either `static` or non-static. The documentation on
// <<extensions-registration-programmatic-static-fields, Static Fields>> and
// <<extensions-registration-programmatic-instance-fields, Instance Fields>> for
// `@RegisterExtension` fields also applies to `@ExtendWith` fields.
NOTE: `@ExtendWith` は `static` 宣言したフィールドとしなかったフィールドのどちらも修飾できます。
`@RegisterExtension` で修飾するフィールドを <<extensions-registration-programmatic-static-fields, static 宣言する場合>> と <<extensions-registration-programmatic-instance-fields, static 宣言しない場合>> と同じ規則になります。

[[extensions-registration-programmatic]]
==== 手続き的に登録する方法

// Developers can register extensions _programmatically_ by annotating fields in test classes
// with `{RegisterExtension}`.
開発者はテストクラスのフィールドを `{RegisterExtension}` で修飾することで、手続き的に拡張機能を登録できます。

// When an extension is registered _declaratively_ via
// <<extensions-registration-declarative,`@ExtendWith`>>, it can typically only be configured
// via annotations. In contrast, when an extension is registered via `@RegisterExtension`, it
// can be configured _programmatically_ -- for example, in order to pass arguments to the
// extension's constructor, a static factory method, or a builder API.
<<extensions-registration-declarative,`@ExtendWith`>> で _宣言的に登録する_ 場合、アノテーションを使用するしか設定を変更する方法がありませんでした。
しかし、`@RegisterExtension` で _手続き的に登録する_ 場合、拡張機能のコンストラクタや `static` 宣言したファクトリメソッドやビルダー API で設定を変更できます。

// [[extensions-registration-programmatic-order]]
// [TIP]
.Extension Registration Order
[[extensions-registration-programmatic-order]]
[TIP]
.拡張機能の登録順序
====
// By default, extensions registered programmatically via `@RegisterExtension` or
// declaratively via `@ExtendWith` on fields will be ordered using an algorithm that is
// deterministic but intentionally nonobvious. This ensures that subsequent runs of a test
// suite execute extensions in the same order, thereby allowing for repeatable builds.
// However, there are times when extensions need to be registered in an explicit order. To
// achieve that, annotate `@RegisterExtension` fields or `@ExtendWith` fields with `{Order}`.
初期設定では、`@RegisterExtension` で手続き的に登録する場合や、フィールドを `@ExtendWith` で修飾して宣言的に登録する場合、その登録順は意図的にわかりにくくした決定論的アルゴリズムで決まるようになっています。
したがって、再びテストスイートを実行しても、同じ登録順になることが保証されています。再現可能なビルド（プロセス）を保証するためです。
とはいえ、拡張機能の登録順序を明示したい場合もあるでしょう。
そういう場合、`@RegisterExtension` や `@ExtendWith` で修飾したフィールドへ `{Order}` を追加します。

// Any `@RegisterExtension` field or `@ExtendWith` field not annotated with `@Order` will be
// ordered using the _default_ order which has a value of `Integer.MAX_VALUE / 2`. This
// allows `@Order` annotated extension fields to be explicitly ordered before or after
// non-annotated extension fields. Extensions with an explicit order value less than the
// default order value will be registered before non-annotated extensions. Similarly,
// extensions with an explicit order value greater than the default order value will be
// registered after non-annotated extensions. For example, assigning an extension an explicit
// order value that is greater than the default order value allows _before_ callback
// extensions to be registered last and _after_ callback extensions to be registered first,
// relative to other programmatically registered extensions.
`@Order` で修飾しなかったフィールドの相対位置は _default_ すなわち `Integer.MAX_VALUE / 2` になります。
`@Order` で修飾したフィールドによる拡張機能の登録順を、`@Order` で修飾しなかったフィールドによる拡張機能の前あるいは後にできるようにするためです。
`default` 値より小さい相対位置を指定したフィールド（の拡張機能）は、`@Order` で修飾しなかったフィールド（の拡張機能）より前に登録します。
同様に、`default` 値より大きい相対位置を指定したフィールド（の拡張機能）は、`@Order` で修飾しなかったフィールド（の拡張機能）より後に登録します。
例えば、_事前処理_ を提供する拡張機能を `default` 値より大きな相対位置で登録すれば最後に登録するようにできるし、_事後処理_ を提供する拡張機能を `default` 値より小さな相対位置で登録すれば最初に登録するようにできます。
====

// NOTE: `@RegisterExtension` fields must not be `null` (at evaluation time) but may be
// either `static` or non-static.
NOTE: `@RegisterExtension` で修飾するフィールドは決して `null` にしてはいけません（参照するとき）。`static` 宣言したフィールドとしなかったフィールドのどちらも修飾できます。

[[extensions-registration-programmatic-static-fields]]
===== static 宣言したフィールドで拡張機能を登録する

// If a `@RegisterExtension` field is `static`, the extension will be registered after
// extensions that are registered at the class level via `@ExtendWith`. Such _static
// extensions_ are not limited in which extension APIs they can implement. Extensions
// registered via static fields may therefore implement class-level and instance-level
// extension APIs such as `BeforeAllCallback`, `AfterAllCallback`,
// `TestInstancePostProcessor`, and `TestInstancePreDestroyCallback` as well as method-level
// extension APIs such as `BeforeEachCallback`, etc.
`@RegisterExtension` で修飾するフィールドを `static` 宣言する場合、テストクラスを修飾する `@ExtendWith` より後に拡張機能を登録します。
このように _クラスレベルで登録した拡張機能_ は、どのような拡張APIでも実装できることになっています（制限はありません）。
クラスレベルのAPIである `BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor, TestInstancePreDestroyCallback` を実装できますし、メソッドレベルのAPIである `BeforeEachCallback` なども実装できるのです。

// In the following example, the `server` field in the test class is initialized
// programmatically by using a builder pattern supported by the `WebServerExtension`. The
// configured `WebServerExtension` will be automatically registered as an extension at the
// class level -- for example, in order to start the server before all tests in the class
// and then stop the server after all tests in the class have completed. In addition, static
// lifecycle methods annotated with `@BeforeAll` or `@AfterAll` as well as `@BeforeEach`,
// `@AfterEach`, and `@Test` methods can access the instance of the extension via the
// `server` field if necessary.
次のコード例では、テストクラスのフィールド `server` を、`WebServerExtension` のビルダー API で手続き的に初期化しています。
`WebServerExtension` は自動的にクラスレベルの拡張として登録されます。
ここでは、テストクラスの全てのテストを実行する前に HTTP サーバーを開始し、全てのテストが完了してから HTTP サーバーを停止することになります。
さらに、`static` 宣言したライフサイクルメソッド `@BeforeAll` や `@AfterAll` は、`@BeforeEach` や `@AfterEach` や `@Test` と同じく `server` フィールドを介して拡張機能のインスタンスを参照できます。

[source,java,indent=0]
// .Registering an extension via a static field in Java
.static フィールドで拡張機能を登録する（Java）
----
include::{testDir}/example/registration/WebServerDemo.java[tags=user_guide]
----

[[extensions-registration-programmatic-static-fields-kotlin]]
====== Kotlin における static フィールドの扱い

// The Kotlin programming language does not have the concept of a `static` field. However,
// the compiler can be instructed to generate a `private static` field using the `@JvmStatic`
// annotation in Kotlin. If you want the Kotlin compiler to generate a `public static` field,
// you can use the `@JvmField` annotation instead.
Kotlin には `static` フィールドという考え方がありません。
しかし、`@JvmStatic` アノテーションを使うと、コンパイラに `private static` フィ－ルドを生成させられるようになっています。
`public static` フィールドを生成させたいときは `@JvmField` アノテーションを使用します。

// The following example is a version of the `WebServerDemo` from the previous section that
// has been ported to Kotlin.
次のコード例は前の `WebServerDemo` の Kotlin バージョンです。

// [source,kotlin,indent=0]
// .Registering an extension via a static field in Kotlin
[source,kotlin,indent=0]
.static フィールドで拡張機能を登録する（Kotlin）
----
include::{kotlinTestDir}/example/registration/KotlinWebServerDemo.kt[tags=user_guide]
----

[[extensions-registration-programmatic-instance-fields]]
===== インスタンスフィールドで拡張機能を登録する

// If a `@RegisterExtension` field is non-static (i.e., an instance field), the extension
// will be registered after the test class has been instantiated and after each registered
// `TestInstancePostProcessor` has been given a chance to post-process the test instance
// (potentially injecting the instance of the extension to be used into the annotated
// field). Thus, if such an _instance extension_ implements class-level or instance-level
// extension APIs such as `BeforeAllCallback`, `AfterAllCallback`, or
// `TestInstancePostProcessor`, those APIs will not be honored. By default, an instance
// extension will be registered _after_ extensions that are registered at the method level
// via `@ExtendWith`; however, if the test class is configured with
// `@TestInstance(Lifecycle.PER_CLASS)` semantics, an instance extension will be registered
// _before_ extensions that are registered at the method level via `@ExtendWith`.
`@RegisterExtension` で修飾したフィールドがインスタンスフィールドの場合、テストクラスをインスタンス化し、登録済みの全ての `TestInstancePostProcessor` が後処理を実行し（拡張機能が自身のインスタンスをフィールドに注入する可能性もあります）、それから拡張機能を登録します。
したがって _インスタンスレベルの拡張機能_ が `BeforeAllCallback, AfterAllCallback, TestInstancePostProcessor` のような API を実装していたとしても、呼び出される機会はありません。
初期設定ではインスタンスレベルの拡張機能が登録されるのは、メソッドを修飾した `@ExtendWith` の拡張機能より _後_ になります。
ただし、テストクラスのセマンティクスをクラス単位（per-class）にしている場合、メソッドを修飾した `@ExtendWith` の拡張機能より _前_ に登録します。

// In the following example, the `docs` field in the test class is initialized
// programmatically by invoking a custom `lookUpDocsDir()` method and supplying the result
// to the static `forPath()` factory method in the `DocumentationExtension`. The configured
// `DocumentationExtension` will be automatically registered as an extension at the method
// level. In addition, `@BeforeEach`, `@AfterEach`, and `@Test` methods can access the
// instance of the extension via the `docs` field if necessary.
次のコード例ではインスタンスフィールド `docs` を手続き的に初期化しています。
独自の `lookUpDocsDir()` メソッドの返り値を `DocumentExtension` のファクトリメソッド `forPath()` の引数にしているのです。
`DocumentationExtension` はメソッドレベルで自動的に登録される拡張機能ということになります。
さらに、`@BeforeEach, @AfterEach, @Test` で修飾したメソッドから、`docs` フィールドを介して拡張機能のインスタンスを参照できます。

// [source,java,indent=0]
// .An extension registered via an instance field
[source,java,indent=0]
.インスタンスフィールドで拡張機能を登録する
----
include::{testDir}/example/registration/DocumentationDemo.java[tags=user_guide]
----

[[extensions-registration-automatic]]
==== 自動的に拡張機能を登録する

// In addition to <<extensions-registration-declarative,declarative extension registration>>
// and <<extensions-registration-programmatic,programmatic extension registration>> support
// using annotations, JUnit Jupiter also supports _global extension registration_ via Java's
// `{ServiceLoader}` mechanism, allowing third-party extensions to be auto-detected and
// automatically registered based on what is available in the classpath.
JUnit Jupiter は <<extensions-registration-declarative, 宣言的な拡張機能の登録方法>> と <<extensions-registration-programmatic, 手続き的な拡張機能の登録方法>> に加えて、Java の `{ServiceLoader}` を使用する _大局的な拡張機能の登録方法_ に対応しています。
この方法を使用すると、クラスパスに配置したサードパーティの拡張機能を自動的に検出、登録することができます。

// Specifically, a custom extension can be registered by supplying its fully qualified class
// name in a file named `org.junit.jupiter.api.extension.Extension` within the
// `/META-INF/services` folder in its enclosing JAR file.
具体的には、拡張機能の実装と `/META-INF/services/org.junit.jupiter.api.extension.Extension` というファイルを jar ファイルに配置します。
`org.junit.jupiter.api.extension.Extension` には拡張機能の実装クラスの完全修飾クラス名を記述します。

[[extensions-registration-automatic-enabling]]
===== 拡張機能の自動検出を有効化する

// Auto-detection is an advanced feature and is therefore not enabled by default. To enable
// it, set the `junit.jupiter.extensions.autodetection.enabled` _configuration parameter_ to
// `true`. This can be supplied as a JVM system property, as a _configuration parameter_ in
// the `LauncherDiscoveryRequest` that is passed to the `Launcher`, or via the JUnit Platform
// configuration file (see <<running-tests-config-params>> for details).
自動検出機能は高度な機能なので、初期設定では無効化されています。
有効化するには _設定パラメータ_ `junit.jupiter.extensions.autodetection.enabled` に `true` を設定します。
`Launcher` に渡す `LauncherDiscoveryRequest` の値を、システムプロパティや設定ファイル（<<running-tests-config-params>> を参照）で指定できます。

// For example, to enable auto-detection of extensions, you can start your JVM with the
// following system property.
例えば、システムプロパティを指定するときは次のように実行します。

`-Djunit.jupiter.extensions.autodetection.enabled=true`

// When auto-detection is enabled, extensions discovered via the `{ServiceLoader}` mechanism
// will be added to the extension registry after JUnit Jupiter's global extensions (e.g.,
// support for `TestInfo`, `TestReporter`, etc.).
自動検出機能を有効にしている場合、JUnit Jupiter の基本拡張（`TestInfo` や `TestReporter` のための拡張機能）を登録した後に、`{ServiceLoader}` の検出した拡張機能を登録します。

[[extensions-registration-inheritance]]
==== 拡張機能の継承

// Registered extensions are inherited within test class hierarchies with top-down
// semantics. Similarly, extensions registered at the class-level are inherited at the
// method-level. Furthermore, a specific extension implementation can only be registered
// once for a given extension context and its parent contexts. Consequently, any attempt to
// register a duplicate extension implementation will be ignored.
登録した拡張機能は、テストクラスの階層構造をトップダウン方向に継承していきます。
また、クラスレベルで登録した拡張機能は、メソッドレベルに継承していきます。
さらに、特定の拡張機能はその拡張コンテキストと親のコンテキストについて1度しか登録できません。
後から同じ拡張機能を登録しようとした結果は無視されます。

[[extensions-conditions]]
=== 条件付きのテスト実行

// `{ExecutionCondition}` defines the `Extension` API for programmatic, _conditional test
// execution_.
`{ExecutionCondition}` は _条件付きのテスト実行_ を手続き的に実現する拡張APIです。

// An `ExecutionCondition` is _evaluated_ for each container (e.g., a test class) to
// determine if all the tests it contains should be executed based on the supplied
// `ExtensionContext`. Similarly, an `ExecutionCondition` is _evaluated_ for each test to
// determine if a given test method should be executed based on the supplied
// `ExtensionContext`.
`ExecutionCondition` はそれぞれのテストコンテナ（テストクラス）ごとに _評価され_、`ExtensionContext` よりそのコンテナに含まれる全てのテストを実行するかどうかを決定します。
同じように、`ExecutionCondition` はそれぞれのテストメソッドごとに _評価され_、`ExtensionContext` そのテストメソッドを実行するかどうかを決定します。

// When multiple `ExecutionCondition` extensions are registered, a container or test is
// disabled as soon as one of the conditions returns _disabled_. Thus, there is no guarantee
// that a condition is evaluated because another extension might have already caused a
// container or test to be disabled. In other words, the evaluation works like the
// short-circuiting boolean OR operator.
複数の `ExecutionCondition` を登録した場合、どちらかの評価結果が _disabled_ ならただちにそのテストコンテナ（あるいはテスト）を無効化します。
つまり、常に登録した全ての条件が評価されるわけではないということです（他の条件がテストを無効と判断しているかもしれません）。
ブール演算の OR 演算子のように短絡評価するのです。

// See the source code of `{DisabledCondition}` and `{Disabled}` for concrete examples.
具体例は `{DisabledCondition}` や `{Disabled}` のソースコードを参照してください。

[[extensions-conditions-deactivation]]
==== 条件を不活性にする

// Sometimes it can be useful to run a test suite _without_ certain conditions being active.
// For example, you may wish to run tests even if they are annotated with `@Disabled` in
// order to see if they are still _broken_. To do this, provide a pattern for the
// `junit.jupiter.conditions.deactivate` _configuration parameter_ to specify which
// conditions should be deactivated (i.e., not evaluated) for the current test run. The
// pattern can be supplied as a JVM system property, as a _configuration parameter_ in the
// `LauncherDiscoveryRequest` that is passed to the `Launcher`, or via the JUnit Platform
// configuration file (see <<running-tests-config-params>> for details).
想定した条件を _満たさない場合_ でもテストスイートを実行できるようになっていると便利なときがあります。
例えば、_成功しないことが分かっている_ としても `@Disabled` で修飾したテストを実行したい場合があるかもしれません。
そのためには、設定パラメータの `junit.jupiter.conditions.deactivate` で不活性にする（評価しない）条件を指定します。
`Launcher` に渡す `LauncherDiscoveryRequest` の値を、システムプロパティや設定ファイル（<<running-tests-config-params>> を参照）で指定できます。

// For example, to deactivate JUnit's `@Disabled` condition, you can start your JVM with the
// following system property.
例えば、`@Disabled` をシステムプロパティで不活性化するときは次のように実行します。

`-Djunit.jupiter.conditions.deactivate=org.junit.\*DisabledCondition`

[[extensions-conditions-deactivation-patterns]]
===== パターンマッチ記法

// Refer to <<running-tests-config-params-deactivation-pattern>> for details.
<<running-tests-config-params-deactivation-pattern>> を参照してください。

[[extensions-test-instance-factories]]
=== テストインスタンスファクトリ

// `{TestInstanceFactory}` defines the API for `Extensions` that wish to _create_ test class
// instances.
`{TestInstanceFactory}` はテストクラスのインスタンスを _作成する_ ための拡張APIです。

// Common use cases include acquiring the test instance from a dependency injection
// framework or invoking a static factory method to create the test class instance.
一般的な使い方として、DIフレームワークからテストインスタンスを取得したり、`static` ファクトリメソッドでテストインスタンスを作成することがあると思います。

// If no `TestInstanceFactory` is registered, the framework will invoke the _sole_
// constructor for the test class to instantiate it, potentially resolving constructor
// arguments via registered `ParameterResolver` extensions.
`TestInstanceFactory` が登録されていなければ、テストフレームワークはテストクラスをインスタンス化するため _唯一のコンストラクタ_ を使用します。
`ParameterResolver` でコンストラクタ引数を解決する場合があるかもしれません。

// Extensions that implement `TestInstanceFactory` can be registered on test interfaces,
// top-level test classes, or `@Nested` test classes.
`TestInstanceFactory` を実装した拡張機能を登録できるのは、テストインターフェイスやトップレベルクラス、`@Nested` で修飾した内部クラスです。

[WARNING]
====
// Registering multiple extensions that implement `TestInstanceFactory` for any single class
// will result in an exception being thrown for all tests in that class, in any subclass,
// and in any nested class. Note that any `TestInstanceFactory` registered in a superclass
// or _enclosing_ class (i.e., in the case of a `@Nested` test class) is _inherited_. It is
// the user's responsibility to ensure that only a single `TestInstanceFactory` is
// registered for any specific test class.
1つのテストクラスに対して複数の `TestInstaneFactory` を登録すると、そのクラスの全てのテストや、全ての派生クラス、全ての入れ子クラスについて例外をスローします。
既定クラスや _エンクロージングクラス_ （`@Nested` で修飾した内部クラス）が登録した `TestInstanceFactory` は全て _継承_ します。
`TestInstanceFactory` が一意になることを保証するのはユーザーの仕事なのです。
====

[[extensions-test-instance-post-processing]]
=== テストインスタンスを作成した後の処理

// `{TestInstancePostProcessor}` defines the API for `Extensions` that wish to _post
// process_ test instances.
`{TestInstancePostProcessor}` はテストクラスのインスタンスを作成した _後_ に実行する処理を実行するための拡張APIです。

// Common use cases include injecting dependencies into the test instance, invoking custom
// initialization methods on the test instance, etc.
一般的な使い方として、テストインスタンスに依存オブジェクトを注入したり、独自の初期化メソッドを呼び出すことがあると思います。

// For a concrete example, consult the source code for the `{MockitoExtension}` and the
// `{SpringExtension}`.
具体例は `{MockitoExtension}` や `{SpringExtension}` のソースコードを参照してください。

[[extensions-test-instance-pre-destroy-callback]]
=== テストインスタンスを破棄する前のコールバック

// `{TestInstancePreDestroyCallback}` defines the API for `Extensions` that wish to process
// test instances _after_ they have been used in tests and _before_ they are destroyed.
`{TestInstancePreDestroyCallback}` はテストクラスのインスタンスがテストを実行した _後_、インスタンスを破棄する _前_ に実行したい処理を実行するための拡張APIです。

// Common use cases include cleaning dependencies that have been injected into the
// test instance, invoking custom de-initialization methods on the test instance, etc.
一般的な使い方として、テストインスタンスの依存オブジェクトを後始末したり、独自の逆初期化メソッドを呼び出すことがあると思います。

[[extensions-parameter-resolution]]
=== パラメータの解決

// `{ParameterResolver}` defines the `Extension` API for dynamically resolving parameters at
// runtime.
`{ParameterResolver}` は実行時にいろいろなパラメータを解決するための拡張APIです。

// If a _test class_ constructor, _test method_, or _lifecycle method_ (see
// <<writing-tests-classes-and-methods>>) declares a parameter, the parameter must be
// _resolved_ at runtime by a `ParameterResolver`. A `ParameterResolver` can either be
// built-in (see `{TestInfoParameterResolver}`) or <<extensions-registration,registered by
// the user>>. Generally speaking, parameters may be resolved by _name_, _type_,
// _annotation_, or any combination thereof.
_テストクラス_ のコンストラクタ、_テストメソッド_、_ライフサイクルメソッド_（<<writing-tests-classes-and-methods>> を参照）に宣言した引数は、`ParameterResolver` により実行時に _解決_ しなければなりません。
使用できるのは組み込みの `ParameterResolver` （`{TestInfoParameterResolver}` など）か、<<extensions-registration, ユーザーの登録した拡張機能>> が提供する `ParameterResolver` です。
一般的には、引数の _名前_ や _型_ や _アノテーション_、あるいはそれらの組み合わせから解決することになるでしょう。

// If you wish to implement a custom `{ParameterResolver}` that resolves parameters based
// solely on the type of the parameter, you may find it convenient to extend the
// `{TypeBasedParameterResolver}` which serves as a generic adapter for such use cases.
総称型クラスのアダプターである `{TypeBasedParameterResolver}` を継承すると、特定の型に対する引数を解決する `{ParameterResolver}` を簡単に実装できます。

// For concrete examples, consult the source code for `{CustomTypeParameterResolver}`,
// `{CustomAnnotationParameterResolver}`, and `{MapOfListsTypeBasedParameterResolver}`.
具体例は `{CustomTypeParameterResolver}` や `{CustomAnnotationParameterResolver}` や `{MapOfListsTypeBasedParameterResolver}` のソースコードを参照してください。

[WARNING]
====
// Due to a bug in the byte code generated by `javac` on JDK versions prior to JDK 9,
// looking up annotations on parameters directly via the core `java.lang.reflect.Parameter`
// API will always fail for _inner class_ constructors (e.g., a constructor in a `@Nested`
// test class).
JDK 9 より前の JDK に付属する `javac` の生成するバイトコードに含まれるバグのせいで、_インナークラス_ のコンストラクタ（`@Nested` で修飾したテストクラスです）引数を修飾するアノテーションを、`java.lang.reflect.Parameter` API で直接的に取得する操作は常に失敗します。

// The `{ParameterContext}` API supplied to `ParameterResolver` implementations therefore
// includes the following convenience methods for correctly looking up annotations on
// parameters. Extension authors are strongly encouraged to use these methods instead of
// those provided in `java.lang.reflect.Parameter` in order to avoid this bug in the JDK.
`ParameterResolver` の実装クラスは `{ParameterContext}` API （メソッドのリストは以下）を使用できるので、引数を修飾するアノテーションを参照できます。
拡張機能の作者は、JDK のバグを回避するため `java.lang.refrect.Parameter` の代わりにこれらの API を使うことを強くお勧めします。

* `boolean isAnnotated(Class<? extends Annotation> annotationType)`
* `Optional<A> findAnnotation(Class<A> annotationType)`
* `List<A> findRepeatableAnnotations(Class<A> annotationType)`
====

[[extensions-test-result-processing]]
=== テスト結果の処理

// `{TestWatcher}` defines the API for extensions that wish to process the results of _test
// method_ executions. Specifically, a `TestWatcher` will be invoked with contextual
// information for the following events.
`{TestWatcher}` は _テストメソッド_ の実行結果を処理するための拡張APIです。
例えば、`TestWatcher` は実行時の状況に応じた次のようなイベントを受信します（メソッドを呼び出します）。

// * `testDisabled`: invoked after a disabled _test method_ has been skipped
// * `testSuccessful`: invoked after a _test method_ has completed successfully
// * `testAborted`: invoked after a _test method_ has been aborted
// * `testFailed`: invoked after a _test method_ has failed
* `testDisabled`: 無効化された _テストメソッド_ をスキップしたときに呼び出すメソッドです
* `testSuccessful`: _テストメソッド_ の実行が正常に終了した後に呼び出すメソッドです
* `testAborted`: _テストメソッド_ の実行が中断された後に呼び出すメソッドです
* `testFailed`: _テストメソッド_ の実行が失敗した後に呼び出すメソッドです

// NOTE: In contrast to the definition of "test method" presented in
// <<writing-tests-classes-and-methods>>, in this context _test method_ refers to any
// `@Test` method or `@TestTemplate` method (for example, a `@RepeatedTest` or
// `@ParameterizedTest`).
NOTE: <<writing-tests-classes-and-methods>> における「テストメソッド」の定義とは違って、このセクションの _テストメソッド_ は `@Test` や `@TestTemplate` で修飾したメソッドのことを指しています（`@RepeatedTest` や `@ParameterizedTest` も含みます）。

// Extensions implementing this interface can be registered at the method level or at the
// class level. In the latter case they will be invoked for any contained _test method_
// including those in `@Nested` classes.
`TestWatcher` の実装クラスを提供する拡張機能は、メソッドレベルかクラスレベルのいずれかで登録します。
拡張機能をクラスレベルで登録した場合、そこに含まれる全てのテストメソッドと、`@Nested` テストクラスに含まれる全てのテストメソッドが対象になります。

[WARNING]
====
// Any instances of `ExtensionContext.Store.CloseableResource` stored in the `Store` of the
// provided `{ExtensionContext}` will be closed _before_ methods in this API are invoked (see
// <<extensions-keeping-state>>). You can use the parent context's `Store` to work with such
// resources.
`{ExtensionContext}` の提供する `Store` に格納された全ての `ExtensionContext.Store.CloseableResource` のインスタンスは、この API より _前に_ 閉じられます（<<extensions-keeping-state>> を参照）。
閉じると困るリソースがあるなら、親のコンテキストの `Store` を使用するといいでしょう。
====

[[extensions-lifecycle-callbacks]]
=== ライフサイクルコールバック

// The following interfaces define the APIs for extending tests at various points in the
// test execution lifecycle. Consult the following sections for examples and the Javadoc for
// each of these interfaces in the `{extension-api-package}` package for further details.
次のインターフェイスはテストの実行時ライフサイクルにおけるさまざまな時点で呼び出される拡張APIです。
詳しくは、後に続くセクションの具体例や、それぞれのインターフェイスや `{extension-api-package}` パッケージの Javadoc を参照してください。

* `{BeforeAllCallback}`
** `{BeforeEachCallback}`
*** `{BeforeTestExecutionCallback}`
*** `{AfterTestExecutionCallback}`
** `{AfterEachCallback}`
* `{AfterAllCallback}`

// .Implementing Multiple Extension APIs
// NOTE: Extension developers may choose to implement any number of these interfaces
// within a single extension. Consult the source code of the `{SpringExtension}` for a
// concrete example.
.複数の拡張APIを実装する
NOTE: 拡張機能の作者は1つの実装クラスで複数の拡張API（インターフェイス）を実装できます。
具体例として `{SpringExtension}` のソースコードを参照してください。

[[extensions-lifecycle-callbacks-before-after-execution]]
==== テスト実行の前、および、後のコールバック

// `{BeforeTestExecutionCallback}` and `{AfterTestExecutionCallback}` define the APIs for
// `Extensions` that wish to add behavior that will be executed _immediately before_ and
// _immediately after_ a test method is executed, respectively. As such, these callbacks are
// well suited for timing, tracing, and similar use cases. If you need to implement
// callbacks that are invoked _around_ `@BeforeEach` and `@AfterEach` methods, implement
// `BeforeEachCallback` and `AfterEachCallback` instead.
`{BeforeTestExecutionCallback}` と `{AfterTestExecutionCallback}` は、（相対的に）テストメソッドを実行する _直前_ あるいは _直後_ に任意の振る舞いを追加する拡張APIです。
時間を計測したり、トレースを記録したりするような場面で役立ちます。
`@BeforeEach` メソッドの前後や、`@AfterEach` メソッドの前後に振る舞いを追加したいときは、`BeforeEachCallback` や `AfterEachCallback` を実装します。

// The following example shows how to use these callbacks to calculate and log the execution
// time of a test method. `TimingExtension` implements both `BeforeTestExecutionCallback`
// and `AfterTestExecutionCallback` in order to time and log the test execution.
次のコード例では、テストメソッドの実行時間を計算してログに出力するため、`TimingExtension` が `BeforeTestExecutionCallback` と `AfterTestExecutionCallback` を実装しています。

[[extensions-lifecycle-callbacks-timing-extension]]
[source,java,indent=0]
// .An extension that times and logs the execution of test methods
.テストメソッドの実行時間を計算してログに出力する拡張機能
----
include::{testDir}/example/timing/TimingExtension.java[tags=user_guide]
----

// Since the `TimingExtensionTests` class registers the `TimingExtension` via `@ExtendWith`,
// its tests will have this timing applied when they execute.
`TimingExtensionTests` では `TimingExtension` を `@ExtendWith` で登録しているので、それぞれのテストメソッドの実行時間が計測されています。

[source,java,indent=0]
// .A test class that uses the example TimingExtension
.`TimingExtension` を使用するテストクラス
----
include::{testDir}/example/timing/TimingExtensionTests.java[tags=user_guide]
----

// The following is an example of the logging produced when `TimingExtensionTests` is run.
実行すると、次のような出力を得られるでしょう。

....
INFO: Method [sleep20ms] took 24 ms.
INFO: Method [sleep50ms] took 53 ms.
....

[[extensions-exception-handling]]
=== 例外処理

// Exceptions thrown during the test execution may be intercepted and handled accordingly
// before propagating further, so that certain actions like error logging or resource releasing
// may be defined in specialized `Extensions`. JUnit Jupiter offers API for `Extensions` that
// wish to handle exceptions thrown during `@Test` methods via `{TestExecutionExceptionHandler}`
// and for those thrown during one of test lifecycle methods (`@BeforeAll`, `@BeforeEach`,
// `@AfterEach` and `@AfterAll`) via `{LifecycleMethodExecutionExceptionHandler}`.
テストを実行しているときに例外が発生したら、それを呼び出し元に伝播させる前に介入して、なんらかの処理をさせたい場合があります（エラーをログに出力したり、リソースを解法したり）。
JUnit Jupiter ではそのような拡張機能を作成するための拡張APIを提供しています。
`@Test` メソッドで発生した例外を処理する `{TestExecutionExceptionHandler}` と、ライフサイクルメソッド（`@BeforeAll, @BeforeEach, @AfterEach, @AfterAll`）で発生した例外を処理する `{LifecycleMethodExecutionExceptionHandler}` です。

// The following example shows an extension which will swallow all instances of `IOException`
// but rethrow any other type of exception.
次のコード例では、テストを実行しているときに発生した `IOException` 以外の例外を再スローする拡張機能を実装しています。

[source,java,indent=0]
// .An exception handling extension that filters IOExceptions in test execution
.テスト実行時に発生した `IOException` を隠す例外処理ハンドラーの拡張機能
----
include::{testDir}/example/exception/IgnoreIOExceptionExtension.java[tags=user_guide]
----

// Another example shows how to record the state of an application under test exactly at
// the point of unexpected exception being thrown during setup and cleanup. Note that unlike
// relying on lifecycle callbacks, which may or may not be executed depending on the test
// status, this solution guarantees execution immediately after failing `@BeforeAll`,
// `@BeforeEach`, `@AfterEach` or `@AfterAll`.
次のコード例では、準備や後始末をしているときに予期せぬ例外が発生した場合、テスト対象のアプリケーションの状態を記録する方法を示しています。
ライフサイクルメソッドのコールバックを使用する場合と違って、例外処理ハンドラーを実行するかどうかは実行したテストの内容によって異なります。
この例のような使い方をすると、`@BeforeALl, @BeforeEach, @AfterEach, @AfterAll` が失敗した直後に呼び出されることが保証されています。

[source,java,indent=0]
.An exception handling extension that records application state on error
----
include::{testDir}/example/exception/RecordStateOnErrorExtension.java[tags=user_guide]
----

// Multiple execution exception handlers may be invoked for the same lifecycle method in
// order of declaration. If one of the handlers swallows the handled exception, subsequent
// ones will not be executed, and no failure will be propagated to JUnit engine, as if the
// exception was never thrown. Handlers may also choose to rethrow the exception or throw
// a different one, potentially wrapping the original.
同じライフサイクルメソッドの定義順によって、複数の例外処理ハンドラーを呼び出す可能性があります。
いずれかの例外処理ハンドラーが自分で処理した例外を隠してしまうと、後に続く例外処理ハンドラーは呼び出されなくなりますし、JUnit にも失敗が伝わりません。
例外が発生しなかったとように扱われてしまうのです。
例外処理ハンドラーは受け取った例外を再スローするか、（受け取った例外を内包する）新しい例外をスローするか選ぶことになるでしょう。

// Extensions implementing `{LifecycleMethodExecutionExceptionHandler}` that wish to handle
// exceptions thrown during `@BeforeAll` or `@AfterAll` need to be registered on a class level,
// while handlers for `BeforeEach` and `AfterEach` may be also registered for individual
// test methods.
`@BeforeAll, @AfterAll` で発生した例外を、`{LifecycleMethodExecutionExceptionHandler}` を実装した拡張機能で扱いたいときは、拡張機能をクラスレベルで登録しなければなりません。
この場合、それぞれのテストメソッドに対する `BeforeEach, AfterEach` にも例外処理ハンドラーが登録されます。

[source,java,indent=0]
// .Registering multiple exception handling extensions
.複数の例外処理ハンドラーを登録する
----
include::{testDir}/example/exception/MultipleHandlersTestCase.java[tags=user_guide]
----

[[extensions-intercepting-invocations]]
=== テストコードの呼び出しへの割り込み

// `{InvocationInterceptor}` defines the API for `Extensions` that wish to intercept calls to
// test code.
`{InvocationInterceptor}` はテストコードの呼び出しに割り込んで処理をさせたいときに使用する拡張APIです。

// The following example shows an extension that executes all test methods in Swing's Event
// Dispatch Thread.
次のコード例では、Swing のイベントディスパッチスレッドで全てのテストメソッドを実行しています。

[source,java,indent=0]
// .An extension that executes tests in a user-defined thread
.ユーザー定義スレッドでテストを実行する拡張機能
----
include::{testDir}/example/interceptor/SwingEdtInterceptor.java[tags=user_guide]
----

[[extensions-test-templates]]
=== テストテンプレートに呼び出し元のコンテキストを与える

// A `{TestTemplate}` method can only be executed when at least one
// `{TestTemplateInvocationContextProvider}` is registered. Each such provider is responsible
// for providing a `Stream` of `{TestTemplateInvocationContext}` instances. Each context may
// specify a custom display name and a list of additional extensions that will only be used
// for the next invocation of the `{TestTemplate}` method.
`{TestTemplate}` で修飾したメソッドを実行するには、少なくとも1つの `{TestTemplateInvocationContextProvider}` を登録しなければなりません。
このインターフェイスの実装クラスは `{TestTemplateInvocationContext}` を要素とする `Stream` を提供しなければなりません。
それぞれの要素には、独自の表示名や、直後の `{TestTemplate}` メソッドを呼び出すときにだけ使用する拡張機能のリストが含まれています。

// The following example shows how to write a test template as well as how to register and
// implement a `{TestTemplateInvocationContextProvider}`.
次のコード例では、テストテンプレートの書き方と、`{TestTemplateInvocationContextProvider}` の実装方法を説明しています。

[source,java,indent=0]
// .A test template with accompanying extension
.自作の拡張機能とテストテンプレート
----
include::{testDir}/example/TestTemplateDemo.java[tags=user_guide]
----

// In this example, the test template will be invoked twice. The display names of the
// invocations will be `apple` and `banana` as specified by the invocation context. Each
// invocation registers a custom `{ParameterResolver}` which is used to resolve the method
// parameter. The output when using the `ConsoleLauncher` is as follows.
前のコード例では、テストテンプレートは2回呼び出されるはずです。
それぞれの呼び出しについて、呼び出しコンテキストに指定された表示名は `apple` と `banana` になります。
また、メソッド引数を解決する独自の `{ParameterResolver}` も登録されています。
`ConsoleLauncher` でテストを実行すると、次のように出力されるでしょう。

....
└─ testTemplate(String) ✔
   ├─ apple ✔
   └─ banana ✔
....

// The `{TestTemplateInvocationContextProvider}` extension API is primarily intended for
// implementing different kinds of tests that rely on repetitive invocation of a test-like
// method albeit in different contexts — for example, with different parameters, by preparing
// the test class instance differently, or multiple times without modifying the context.
// Please refer to the implementations of <<writing-tests-repeated-tests>> or
// <<writing-tests-parameterized-tests>> which use this extension point to provide their
// functionality.
`{TestTemplateInvocationContextProvider}` API の主な目的は、さまざまなコンテキストで呼び出されるメソッドのように、繰り返し呼び出されることが前提の普通とは異なるテストを実現することです。
例えば、毎回違うパラメータで実行したり、テストクラスのインスタンスの状態を毎回変化させたり、状態を変化させずに何度も実行するなどです。
この API で実現されてる <<writing-tests-repeated-tests>> や <<writing-tests-parameterized-tests>> についても参照してください。

[[extensions-keeping-state]]
=== 拡張機能の状態を保存する

// Usually, an extension is instantiated only once. So the question becomes relevant: How do
// you keep the state from one invocation of an extension to the next? The
// `ExtensionContext` API provides a `Store` exactly for this purpose. Extensions may put
// values into a store for later retrieval. See the
// `<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>` for an example of
// using the `Store` with a method-level scope. It is important to remember that values
// stored in an `ExtensionContext` during test execution will not be available in the
// surrounding `ExtensionContext`. Since `ExtensionContexts` may be nested, the scope of
// inner contexts may also be limited. Consult the corresponding Javadoc for details on the
// methods available for storing and retrieving values via the `{ExtensionContext_Store}`.
普通なら拡張機能をインスタンス化するのは1度だけです。
だから「拡張機能が前に呼び出されたときの状態を残すにはどうしたらいいのか」という疑問が生じるのは当然です。
`ExtensionContext` API の `Store` インターフェイスはそのために使用します。
拡張機能が後から参照する値を登録するための API なのです。
メソッドレベルのスコープで `Store` を使用する具体例として `<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>` を見てください。
テストメソッドを実行しているときに `ExtensionContext` へ登録した値は、周辺の `ExtensionContext` からは参照できないことに注意してください。
`ExtensionContext` は入れ子構造にできるのですが、内側の可視性は制限されているのです。
値を登録したり参照したりするためのメソッドについては `{ExtensionContext_Store}` の Javadoc を参照してください。

.`ExtensionContext.Store.CloseableResource`
// NOTE: An extension context store is bound to its extension context lifecycle. When an
// extension context lifecycle ends it closes its associated store. All stored values
// that are instances of `CloseableResource` are notified by an invocation of their `close()`
// method in the inverse order they were added in.
NOTE: 拡張機能用コンテキストストアは、その拡張機能のコンテキストのライフサイクルに束縛されています。
その拡張機能のライフサイクルが終了になれば、結びつけられたストアも閉じられるのです。
登録したあらゆる `CloseableResource` のインスタンスに対して、登録した順序の逆順に `close()` メソッドを呼び出していきます。

[[extensions-supported-utilities]]
=== 拡張機能で利用できるユーティリティ

// The `junit-platform-commons` artifact exposes a package named
// `{junit-platform-support-package}` that contains _maintained_ utility methods for working
// with annotations, classes, reflection, and classpath scanning tasks. `TestEngine` and
// `Extension` authors are encouraged to use these supported methods in order to align with
// the behavior of the JUnit Platform.
`junit-platform-commons` アーティファクトの提供する `{junit-platform-support-package}` パッケージには、アノテーションやクラスやリフレクションに関連する操作や、クラスパスを探索する機能に関する、_保守されている_ 便利メソッドが含まれています。
テスト実行エンジンや拡張機能の作者は、JUnit Platform と一貫性のある操作を利用できるのです。

[[extensions-supported-utilities-annotations]]
==== アノテーション

// `AnnotationSupport` provides static utility methods that operate on annotated elements
// (e.g., packages, annotations, classes, interfaces, constructors, methods, and fields).
// These include methods to check whether an element is annotated or meta-annotated with a
// particular annotation, to search for specific annotations, and to find annotated methods
// and fields in a class or interface. Some of these methods search on implemented
// interfaces and within class hierarchies to find annotations. Consult the Javadoc for
// `{AnnotationSupport}` for further details.
`AnnotationSupport` は、アノテーションで修飾できる要素（パッケージ、アノテーション、クラス、インターフェイス、コンストラクタ、メソッド、フィールド）を操作する便利メソッドを提供します（`static` メソッドです）。
アノテーションで修飾されているか、任意のアノテーションでメタアノテーションされているか、特定のアノテーションの探索、アノテーションで修飾されたメソッド、フィールド、クラス、インターフェイスの探索など。
クラスの実装したインターフェイスや、クラス階層を渡り歩いてアノテーションを探索するメソッドもあります。
詳しくは `{AnnotationSupport}` の Javadoc を参照してください。

[[extensions-supported-utilities-classes]]
==== クラス

// `ClassSupport` provides static utility methods for working with classes (i.e., instances
// of `java.lang.Class`). Consult the Javadoc for `{ClassSupport}` for further details.
`ClassSupport` は、クラス（`java.lang.Class` のインスタンスなど）を操作する便利メソッドを提供します（`static` メソッドです）。
詳しくは `{ClassSupport}` の Javadoc を参照してください。

[[extensions-supported-utilities-reflection]]
==== リフレクション

// `ReflectionSupport` provides static utility methods that augment the standard JDK
// reflection and class-loading mechanisms. These include methods to scan the classpath in
// search of classes matching specified predicates, to load and create new instances of a
// class, and to find and invoke methods. Some of these methods traverse class hierarchies
// to locate matching methods. Consult the Javadoc for `{ReflectionSupport}` for further
// details.
`ReflectionSupport` は JDK の標準ライブラリが提供するリフレクション API やクラスロードの仕組みを拡張する便利メソッドを提供します（`static` メソッドです）。
クラスパスから任意の述語式にマッチするクラスを探索する、指定したクラスをロードして新しいインスタンスを作成する、メソッドを探索して実行する（クラス階層を渡り歩くなど）、など。
詳しくは `{ReflectionSupport}` の Javadoc を参照してください。

[[extensions-supported-utilities-modifier]]
==== 修飾子（Modifier）

// `ModifierSupport` provides static utility methods for working with member and class
// modifiers -- for example, to determine if a member is declared as `public`, `private`,
// `abstract`, `static`, etc. Consult the Javadoc for `{ModifierSupport}` for further
// details.
`ModifierSupport` はクラスのメンバーやクラス自体の修飾子を操作する便利メソッドを提供します。
メンバーの可視性が `public/private/abstract/static` のどれなのか、など。
詳しくは `{ModifierSupport}` の Javadoc を参照してください。

[[extensions-execution-order]]
=== ユーザーコードと拡張機能の相対的な実行順序

// When executing a test class that contains one or more test methods, a number of extension
// callbacks are called in addition to the user-supplied test and lifecycle methods.
1つ以上のテストメソッドを持つテストクラスを実行するとき、ユーザーの記述したテストとライフサイクルメソッドに加えて、いくつもの拡張機能（コールバック）が呼び出されることになります。

// NOTE: See also: <<writing-tests-test-execution-order>>
NOTE: <<writing-tests-test-execution-order>> も参照してください。

[[extensions-execution-order-overview]]
==== ユーザーコードと拡張機能の順序関係

// The following diagram illustrates the relative order of user-supplied code and extension
// code. User-supplied test and lifecycle methods are shown in orange, with callback code
// implemented by extensions shown in blue. The grey box denotes the execution of a single
// test method and will be repeated for every test method in the test class.
次の図はユーザーコードと拡張機能の相対的な順序を示しています。
ユーザーの記述したテストとライフサイクルメソッドはオレンジ色、拡張機能が実装したコールバックは青色です。
灰色は1つのテストメソッドを実行するとき、および、全てのテストメソッドについて繰り返し実行するときの範囲を示しています。

// :figure-caption: User code and extension code
:figure-caption: ユーザーコードと拡張機能の順序関係

[#extensions-execution-order-diagram,reftext='{figure-caption}']
image::extensions_lifecycle.png[caption='',title='{figure-caption}']

// The following table further explains the sixteen steps in the
// <<extensions-execution-order-diagram>> diagram.
次の表は <<extensions-execution-order-diagram>> を実行する16の手順を詳しく記述したものです。

[cols="5,15,80"]
|===
// | Step | Interface/Annotation | Description
| 手順 | インターフェイス／アノテーション | 説明

| 1
// | interface `org.junit.jupiter.api.extension.BeforeAllCallback`
// | extension code executed before all tests of the container are executed
| インターフェイス `org.junit.jupiter.api.extension.BeforeAllCallback`
| 拡張機能：テストコンテナのあらゆるテストメソッドより先に実行する

| 2
// | annotation `org.junit.jupiter.api.BeforeAll`
// | user code executed before all tests of the container are executed
| アノテーション `org.junit.jupiter.api.BeforeAll`
| ユーザーコード：テストコンテナのあらゆるテストメソッドより先に実行する

| 3
// | interface `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler#handleBeforeAllMethodExecutionException`
// | extension code for handling exceptions thrown from `@BeforeAll` methods
| インターフェイス `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler
#handleBeforeAllMethodExecutionException`
| 拡張機能：`@BeforeAll` メソッドがスローした例外を処理する例外処理ハンドラーを実行する

| 4
// | interface `org.junit.jupiter.api.extension.BeforeEachCallback`
// | extension code executed before each test is executed
| インターフェイス `org.junit.jupiter.api.extension.BeforeEachCallback`
| 拡張機能：テストコンテナのそれぞれのテストメソッドを実行する前に実行する

| 5
// | annotation `org.junit.jupiter.api.BeforeEach`
// | user code executed before each test is executed
| アノテーション `org.junit.jupiter.api.BeforeEach`
| ユーザーコード：テストコンテナのそれぞれのテストメソッドを実行する前に実行する

| 6
// | interface `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler#handleBeforeEachMethodExecutionException`
// | extension code for handling exceptions thrown from `@BeforeEach` methods
| インターフェイス `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler
#handleBeforeEachMethodExecutionException`
| 拡張機能：`@BeforeEach` メソッドがスローした例外を処理する例外処理ハンドラーを実行する

| 7
// | interface `org.junit.jupiter.api.extension.BeforeTestExecutionCallback`
// | extension code executed immediately before a test is executed
| インターフェイス `org.junit.jupiter.api.extension.BeforeTestExecutionCallback`
| 拡張機能：テストコンテナのそれぞれのテストメソッドを実行する直前に実行する

| 8
// | annotation `org.junit.jupiter.api.Test`
// | user code of the actual test method
| アノテーション `org.junit.jupiter.api.Test`
| ユーザーコード：テストコンテナのそれぞれのテストメソッドを実行する

| 9
// | interface `org.junit.jupiter.api.extension.TestExecutionExceptionHandler`
// | extension code for handling exceptions thrown during a test
| インターフェイス `org.junit.jupiter.api.extension.TestExecutionExceptionHandler`
| 拡張機能：テストメソッドがスローした例外を処理する例外処理ハンドラーを実行する

| 10
// | interface `org.junit.jupiter.api.extension.AfterTestExecutionCallback`
// | extension code executed immediately after test execution and its corresponding exception handlers
| インターフェイス `org.junit.jupiter.api.extension.AfterTestExecutionCallback`
| 拡張機能：テストコンテナのそれぞれのテストメソッドを実行した直後、あるいは、例外処理ハンドラーを実行した直後に実行する

| 11
// | annotation `org.junit.jupiter.api.AfterEach`
// | user code executed after each test is executed
| アノテーション `org.junit.jupiter.api.AfterEach`
| ユーザーコード：テストコンテナのそれぞれのテストメソッドを実行した後に実行する

| 12
// | interface `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler#handleAfterEachMethodExecutionException`
// | extension code for handling exceptions thrown from `@AfterEach` methods
| インターフェイス `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler
#handleAfterEachMethodExecutionException`
| 拡張機能：`@AfterEach` メソッドがスローした例外を処理する例外処理ハンドラーを実行する

| 13
// | interface `org.junit.jupiter.api.extension.AfterEachCallback`
// | extension code executed after each test is executed
| インターフェイス `org.junit.jupiter.api.extension.AfterEachCallback`
| 拡張機能：テストコンテナのそれぞれのテストメソッドより後に実行する

| 14
// | annotation `org.junit.jupiter.api.AfterAll`
// | user code executed after all tests of the container are executed
| アノテーション `org.junit.jupiter.api.AfterAll`
| ユーザーコード：テストコンテナの全てのテストメソッドより後に実行する

| 15
// | interface `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler#handleAfterAllMethodExecutionException`
// | extension code for handling exceptions thrown from `@AfterAll` methods
| インターフェイス `org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler
#handleAfterAllMethodExecutionException`
| 拡張機能：`@AfterAll` メソッドがスローした例外を処理する例外処理ハンドラーを実行する

| 16
// | interface `org.junit.jupiter.api.extension.AfterAllCallback`
// | extension code executed after all tests of the container are executed
| インターフェイス `org.junit.jupiter.api.extension.AfterAllCallback`
| 拡張機能：テストコンテナの全てのテストメソッドより後に実行する

|===

// In the simplest case only the actual test method will be executed (step 8); all other
// steps are optional depending on the presence of user code or extension support for the
// corresponding lifecycle callback. For further details on the various lifecycle callbacks
// please consult the respective Javadoc for each annotation and extension.
単純な場合はテストメソッドを実行するだけでしょう（手順8）。
他の手順を実行するかどうかは、ユーザーコードや拡張機能が、対応するライフサイクルメソッドを提供しているかどうかによって決まります。
ライフサイクルメソッドのコールバックについては、対応するインターフェイスや拡張機能の Javadoc を参照してください。

// All invocations of user code methods in the above table can additionally be intercepted
// by implementing <<extensions-intercepting-invocations, `InvocationInterceptor`>>.
全てのユーザーコード（メソッド）の呼び出しは、<<extensions-intercepting-invocations, `InvocationInterceptor`>> で割り込み可能です。

[[extensions-execution-order-wrapping-behavior]]
==== コールバックによる包み隠す振る舞い

// JUnit Jupiter always guarantees _wrapping_ behavior for multiple registered extensions
// that implement lifecycle callbacks such as `BeforeAllCallback`, `AfterAllCallback`,
// `BeforeEachCallback`, `AfterEachCallback`, `BeforeTestExecutionCallback`, and
// `AfterTestExecutionCallback`.
JUnit Jupiter は、複数のライフサイクルコールバック（`BeforeAllCallback, AfterAllCallback, BeforeEachCallback, AfterEachCallback, BeforeTestExecutionCallback, AfterTestExecutionCallback`）を登録した場合、それぞれの呼び出しを _包み隠す_ ことを保証します。

// That means that, given two extensions `Extension1` and `Extension2` with `Extension1`
// registered before `Extension2`, any "before" callbacks implemented by `Extension1` are
// guaranteed to execute **before** any "before" callbacks implemented by `Extension2`.
// Similarly, given the two same two extensions registered in the same order, any "after"
// callbacks implemented by `Extension1` are guaranteed to execute **after** any "after"
// callbacks implemented by `Extension2`. `Extension1` is therefore said to _wrap_
// `Extension2`.
例えば、`Extension1` と `Extension2` を順番に登録した場合、`Extension1` の提供する全ての "before" コールバックは、`Extension2` の提供する全ての "before" コールバックより **先に** 実行することが保証されています。
同様に、`Extension1` の提供する全ての "after" コールバックは、`Extension2` の提供する全ての "after" コールバックより **後に** 実行することが保証されています。
この関係を「`Extension1` は `Extension2` を _包み隠す_」と呼んでいます。

// JUnit Jupiter also guarantees _wrapping_ behavior within class and interface hierarchies
// for user-supplied _lifecycle methods_ (see <<writing-tests-classes-and-methods>>).
ユーザーコードの提供する _ライフサイクルメソッド_ （<<writing-tests-classes-and-methods>> を参照）は、クラス階層やインターフェイス階層についても _包み隠す_ 関係になることが保証されています。

// * `@BeforeAll` methods are inherited from superclasses as long as they are not _hidden_ or
//   _overridden_. Furthermore, `@BeforeAll` methods from superclasses will be executed
//   **before** `@BeforeAll` methods in subclasses.
// ** Similarly, `@BeforeAll` methods declared in an interface are inherited as long as they
//    are not _hidden_ or _overridden_, and `@BeforeAll` methods from an interface will be
//    executed **before** `@BeforeAll` methods in the class that implements the interface.
// * `@AfterAll` methods are inherited from superclasses as long as they are not _hidden_ or
//   _overridden_. Furthermore, `@AfterAll` methods from superclasses will be executed
//   **after** `@AfterAll` methods in subclasses.
// ** Similarly, `@AfterAll` methods declared in an interface are inherited as long as they
//    are not _hidden_ or _overridden_, and `@AfterAll` methods from an interface will be
//    executed **after** `@AfterAll` methods in the class that implements the interface.
// * `@BeforeEach` methods are inherited from superclasses as long as they are not
//   _overridden_. Furthermore, `@BeforeEach` methods from superclasses will be executed
//   **before** `@BeforeEach` methods in subclasses.
// ** Similarly, `@BeforeEach` methods declared as interface default methods are inherited as
//    long as they are not _overridden_, and `@BeforeEach` default methods will be executed
//    **before** `@BeforeEach` methods in the class that implements the interface.
// * `@AfterEach` methods are inherited from superclasses as long as they are not
//   _overridden_. Furthermore, `@AfterEach` methods from superclasses will be executed
//   **after** `@AfterEach` methods in subclasses.
// ** Similarly, `@AfterEach` methods declared as interface default methods are inherited as
//    long as they are not _overridden_, and `@AfterEach` default methods will be executed
//    **after** `@AfterEach` methods in the class that implements the interface.
* 基底クラスから継承した `@BeforeAll` メソッドは _隠蔽_ も _オーバーライド_ もできません。
  さらに、派生クラスの `@BeforeAll` メソッドより **先に** 実行します。
** 同様に、インターフェイスから継承した `@BeforeAll` メソッドは _隠蔽_ も _オーバーライド_ もできません。
  そして、実装クラスの `@BeforeAll` メソッドより **先に** 実行します。
* 基底クラスから継承した `@AfterAll` メソッドは _隠蔽_ も _オーバーライド_ もできません。
  さらに、派生クラスの `@AfterAll` メソッドより **後に** 実行します。
** 同様に、インターフェイスから継承した `@AfterAll` メソッドは _隠蔽_ も _オーバーライド_ もできません。
  そして、実装クラスの `@AfterAll` メソッドより **後に** 実行します。
* 基底クラスから継承した `@BeforeEach` メソッドは _オーバーライド_ できません。
  さらに、派生クラスの `@BeforeEach` メソッドより **先に** 実行します。
** 同様に、インターフェイスから継承した `@BeforeEach` メソッドは _オーバーライド_ できません。
  そして、実装クラスの `@BeforeEach` メソッドより **先に** 実行します。
* 基底クラスから継承した `@AfterEach` メソッドは _オーバーライド_ できません。
  さらに、派生クラスの `@AfterEach` メソッドより **後に** 実行します。
** 同様に、インターフェイスから継承した `@AfterEach` メソッドは _オーバーライド_ できません。
  そして、実装クラスの `@AfterEach` メソッドより **後に** 実行します。

// The following examples demonstrate this behavior. Please note that the examples do not
// actually do anything realistic. Instead, they mimic common scenarios for testing
// interactions with the database. All methods imported statically from the `Logger` class
// log contextual information in order to help us better understand the execution order of
// user-supplied callback methods and callback methods in extensions.
次のコード例はここまでに説明した振る舞いを示しています。
具体的になんらかの処理するようにはなっていませんが、テストがデータベースとやりとりする一般的なシナリオを再現しています。
`Logger` クラスから `static` インポートしているメソッドは、実行時の情報をログに出力するようになっているため、ユーザーコードと拡張機能のどちらで実装しているコールバックなのか分かりやすくなっています。

[source,java,indent=0]
.Extension1
----
include::{testDir}/example/callbacks/Extension1.java[tags=user_guide]
----

[source,java,indent=0]
.Extension2
----
include::{testDir}/example/callbacks/Extension2.java[tags=user_guide]
----

[source,java,indent=0]
.AbstractDatabaseTests
----
include::{testDir}/example/callbacks/AbstractDatabaseTests.java[tags=user_guide]
----

[source,java,indent=0]
.DatabaseTestsDemo
----
include::{testDir}/example/callbacks/DatabaseTestsDemo.java[tags=user_guide]
----

// When the `DatabaseTestsDemo` test class is executed, the following is logged.
`DatabaseTestsDemo` を実行すると、次のように出力されるでしょう。

----
@BeforeAll AbstractDatabaseTests.createDatabase()
@BeforeAll DatabaseTestsDemo.beforeAll()
  Extension1.beforeEach()
  Extension2.beforeEach()
    @BeforeEach AbstractDatabaseTests.connectToDatabase()
    @BeforeEach DatabaseTestsDemo.insertTestDataIntoDatabase()
      @Test DatabaseTestsDemo.testDatabaseFunctionality()
    @AfterEach DatabaseTestsDemo.deleteTestDataFromDatabase()
    @AfterEach AbstractDatabaseTests.disconnectFromDatabase()
  Extension2.afterEach()
  Extension1.afterEach()
@BeforeAll DatabaseTestsDemo.afterAll()
@AfterAll AbstractDatabaseTests.destroyDatabase()
----

// The following sequence diagram helps to shed further light on what actually goes on within
// the `JupiterTestEngine` when the `DatabaseTestsDemo` test class is executed.
次のシーケンス図は `DatabaseTestDemo` を実行したとき、`JupiterTestEngine` の内部で行われている処理を（大部分省略して）示したものです。

////
PNG generated using ZenUML: https://app.zenuml.com

See corresponding *.txt file in images folder for the source.
////
image::extensions_DatabaseTestsDemo.png[caption='',title='DatabaseTestsDemo']

// JUnit Jupiter does **not** guarantee the execution order of multiple lifecycle methods
// that are declared within a _single_ test class or test interface. It may at times appear
// that JUnit Jupiter invokes such methods in alphabetical order. However, that is not
// precisely true. The ordering is analogous to the ordering for `@Test` methods within a
// single test class.
JUnit Jupiter では _単独の_ クラスやインターフェイスに宣言された複数のライフサイクルメソッドの実行順序を保証 **しません**。
一見するとアルファベット順に見えるかもしれませんが、正確にはそうではありません。
`@Test` メソッドの実行順序と同じようになっているのです。

[NOTE]
====
// Lifecycle methods that are declared within a _single_ test class or test interface will be
// ordered using an algorithm that is deterministic but intentionally non-obvious. This
// ensures that subsequent runs of a test suite execute lifecycle methods in the same order,
// thereby allowing for repeatable builds.
_単独の_ クラスやインターフェイスに宣言した複数のライフサイクルメソッドの実行順序は、意図的に分かりにくくした決定論的アルゴリズムによって決まります。
したがって、再びテストスイートを実行しても、同じ登録順になることが保証されています。再現可能なビルド（プロセス）を保証するためです。
====

// In addition, JUnit Jupiter does **not** support _wrapping_ behavior for multiple lifecycle
// methods declared within a single test class or test interface.
さらに、_単独の_ クラスやインターフェイスに宣言した複数のライフサイクルメソッドが _包み隠す_ 関係になることを保証 **しません**。

// The following example demonstrates this behavior. Specifically, the lifecycle method
// configuration is _broken_ due to the order in which the locally declared lifecycle methods
// are executed.
次のコード例は、テストクラスに定義したライフサイクルメソッドの（間違った）実行順序に依存しているせいでいろいろ _壊れています_。

// * Test data is inserted _before_ the database connection has been opened, which results in
//   a failure to connect to the database.
// * The database connection is closed _before_ deleting the test data, which results in a
//   failure to connect to the database.
* データベース接続を `open()` する _前に_ テストデータを `insert` しています。おそらくデータベース接続エラーが発生するでしょう。
* テストデータを `delete` する _前に_ データベース接続を `close()` しています。おそらくデータベース接続エラーが発生するでしょう。

[source,java,indent=0]
.BrokenLifecycleMethodConfigDemo
----
include::{testDir}/example/callbacks/BrokenLifecycleMethodConfigDemo.java[tags=user_guide]
----

// When the `BrokenLifecycleMethodConfigDemo` test class is executed, the following is logged.
`BrokenLifecycleMethodConfigDemo` を実行すると、次のように出力されるでしょう。

----
Extension1.beforeEach()
Extension2.beforeEach()
  @BeforeEach BrokenLifecycleMethodConfigDemo.insertTestDataIntoDatabase()
  @BeforeEach BrokenLifecycleMethodConfigDemo.connectToDatabase()
    @Test BrokenLifecycleMethodConfigDemo.testDatabaseFunctionality()
  @AfterEach BrokenLifecycleMethodConfigDemo.disconnectFromDatabase()
  @AfterEach BrokenLifecycleMethodConfigDemo.deleteTestDataFromDatabase()
Extension2.afterEach()
Extension1.afterEach()
----

// The following sequence diagram helps to shed further light on what actually goes on within
// the `JupiterTestEngine` when the `BrokenLifecycleMethodConfigDemo` test class is executed.
次のシーケンス図は `BrokenLifecycleMethodConfigDemo` を実行したとき、`JupiterTestEngine` の内部で行われている処理を（大部分省略して）示したものです。

////
PNG generated using ZenUML: https://app.zenuml.com

See corresponding *.txt file in images folder for the source.
////
image::extensions_BrokenLifecycleMethodConfigDemo.png[caption='',title='BrokenLifecycleMethodConfigDemo']

[TIP]
====
// Due to the aforementioned behavior, the JUnit Team recommends that developers declare at
// most one of each type of _lifecycle method_ (see <<writing-tests-classes-and-methods>>)
// per test class or test interface unless there are no dependencies between such lifecycle
// methods.
このセクションで説明した振る舞いが前提になるため、JUnit チームとしては、テストクラスやテストインターフェイスに定義するライフサイクルメソッド（<<writing-tests-classes-and-methods>> を参照）は、それぞれの種類ごとに1つだけ定義するようにして、お互いに依存しないようにすることをお勧めします。
====
