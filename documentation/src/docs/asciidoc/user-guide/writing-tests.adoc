[[writing-tests]]
== テストを作成する

// The following example provides a glimpse at the minimum requirements for writing a test in
// JUnit Jupiter. Subsequent sections of this chapter will provide further details on all
// available features.
次のコード例は、JUnit Jupiter で作成した最小限のテストです。
この章では全ての機能を説明していきます。

// [source,java,indent=0]
// .A first test case
[source,java,indent=0]
.最小限のテストケース
----
include::{testDir}/example/MyFirstJUnitJupiterTests.java[tags=user_guide]
----

[[writing-tests-annotations]]
=== アノテーション

// JUnit Jupiter supports the following annotations for configuring tests and extending the
// framework.
JUnit Jupiter はテストを書いたりフレームワークを拡張するためのアノテーションを提供しています。

// Unless otherwise stated, all core annotations are located in the `{api-package}` package
// in the `junit-jupiter-api` module.
明記しない限り、全ての主要なアノテーションは `junit-jupiter-api` モジュールの `{api-package}` パッケージにあります。

[cols="20,80"]
// |===
// | Annotation               | Description

// | `@Test`                  | Denotes that a method is a test method. Unlike JUnit 4's `@Test` annotation, this annotation does not declare any attributes, since test extensions in JUnit Jupiter operate based on their own dedicated annotations. Such methods are _inherited_ unless they are _overridden_.
// | `@ParameterizedTest`     | Denotes that a method is a <<writing-tests-parameterized-tests, parameterized test>>. Such methods are _inherited_ unless they are _overridden_.
// | `@RepeatedTest`          | Denotes that a method is a test template for a <<writing-tests-repeated-tests, repeated test>>. Such methods are _inherited_ unless they are _overridden_.
// | `@TestFactory`           | Denotes that a method is a test factory for <<writing-tests-dynamic-tests, dynamic tests>>. Such methods are _inherited_ unless they are _overridden_.
// | `@TestTemplate`          | Denotes that a method is a <<writing-tests-test-templates, template for test cases>> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <<extensions-test-templates, providers>>. Such methods are _inherited_ unless they are _overridden_.
// | `@TestClassOrder`        | Used to configure the <<writing-tests-test-execution-order-classes, test class execution order>> for `@Nested` test classes in the annotated test class. Such annotations are _inherited_.
// | `@TestMethodOrder`       | Used to configure the <<writing-tests-test-execution-order-methods, test method execution order>> for the annotated test class; similar to JUnit 4's `@FixMethodOrder`. Such annotations are _inherited_.
// | `@TestInstance`          | Used to configure the <<writing-tests-test-instance-lifecycle, test instance lifecycle>> for the annotated test class. Such annotations are _inherited_.
// | `@DisplayName`           | Declares a custom <<writing-tests-display-names,display name>> for the test class or test method. Such annotations are not _inherited_.
// | `@DisplayNameGeneration` | Declares a custom <<writing-tests-display-name-generator,display name generator>> for the test class. Such annotations are _inherited_.
// | `@BeforeEach`            | Denotes that the annotated method should be executed _before_ *each* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, or `@TestFactory` method in the current class; analogous to JUnit 4's `@Before`. Such methods are _inherited_ unless they are _overridden_.
// | `@AfterEach`             | Denotes that the annotated method should be executed _after_ *each* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, or `@TestFactory` method in the current class; analogous to JUnit 4's `@After`. Such methods are _inherited_ unless they are _overridden_.
// | `@BeforeAll`             | Denotes that the annotated method should be executed _before_ *all* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and `@TestFactory` methods in the current class; analogous to JUnit 4's `@BeforeClass`. Such methods are _inherited_ (unless they are _hidden_ or _overridden_) and must be `static` (unless the "per-class" <<writing-tests-test-instance-lifecycle, test instance lifecycle>> is used).
// | `@AfterAll`              | Denotes that the annotated method should be executed _after_ *all* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and `@TestFactory` methods in the current class; analogous to JUnit 4's `@AfterClass`. Such methods are _inherited_ (unless they are _hidden_ or _overridden_) and must be `static` (unless the "per-class" <<writing-tests-test-instance-lifecycle, test instance lifecycle>> is used).
// | `@Nested`                | Denotes that the annotated class is a non-static <<writing-tests-nested,nested test class>>. `@BeforeAll` and `@AfterAll` methods cannot be used directly in a `@Nested` test class unless the "per-class" <<writing-tests-test-instance-lifecycle, test instance lifecycle>> is used. Such annotations are not _inherited_.
// | `@Tag`                   | Used to declare <<writing-tests-tagging-and-filtering,tags for filtering tests>>, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are _inherited_ at the class level but not at the method level.
// | `@Disabled`              | Used to <<writing-tests-disabling,disable>> a test class or test method; analogous to JUnit 4's `@Ignore`. Such annotations are not _inherited_.
// | `@Timeout`               | Used to fail a test, test factory, test template, or lifecycle method if its execution exceeds a given duration. Such annotations are _inherited_.
// | `@ExtendWith`            | Used to <<extensions-registration-declarative,register extensions declaratively>>. Such annotations are _inherited_.
// | `@RegisterExtension`     | Used to <<extensions-registration-programmatic,register extensions programmatically>> via fields. Such fields are _inherited_ unless they are _shadowed_.
// | `@TempDir`               | Used to supply a <<writing-tests-built-in-extensions-TempDirectory,temporary directory>> via field injection or parameter injection in a lifecycle method or test method; located in the `org.junit.jupiter.api.io` package.
// |===
|===
| アノテーション           | 内容

| `@Test`                  | そのメソッドがテストメソッドであることを示します。JUnit 4 の `@Test` と違って、何も属性が定義されていません。JUnit Jupiter ではテストの振る舞いを拡張する個別のアノテーションを提供しています。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@ParameterizedTest`     | そのメソッドが <<writing-tests-parameterized-tests, パラメタライズドテスト>> であることを示します。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@RepeatedTest`          | そのメソッドが <<writing-tests-repeated-tests, 繰り返し実行するテスト>> のテンプレートであることを示します。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@TestFactory`           | そのメソッドが <<writing-tests-dynamic-tests, 動的に生成するテスト>> のファクトリメソッドであることを示します。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@TestTemplate`          | そのメソッドが <<writing-tests-test-templates, テストケースのテンプレート>> であることを示します。登録した <<extensions-test-templates, テンプレートプロバイダー>> の返す呼び出しコンテキストの数に応じて、複数回実行するために設計します。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@TestClassOrder`        | `@Nested` で修飾した <<writing-tests-test-execution-order-classes, テストクラスの実行順序>> を変更します。アノテーションは _継承_ します。
| `@TestMethodOrder`       | このアノテーションで修飾したクラスにおける <<writing-tests-test-execution-order-methods, テストメソッドの実行順序>> を変更します。JUnit 4 の `@FixMethodOrder` と同じように機能します。アノテーションは _継承_ します。
| `@TestInstance`          | このアノテーションで修飾したクラスにおける<<writing-tests-test-instance-lifecycle, インスタンスのライフサイクル>> を変更します。アノテーションは _継承_ しません。
| `@DisplayName`           | テストクラスやテストメソッドに独自の <<writing-tests-display-names, 表示名>> を設定します。アノテーションは _継承_ しません。
| `@DisplayNameGeneration` | テストクラスに独自の <<writing-tests-display-name-generator, 表示名生成ロジック>> を設定します。アノテーションは _継承_ します。
| `@BeforeEach`            | 当該テストクラスについて、`@Test, @RepeatedTest, @ParameterizedTest, @TestFactory` で修飾されたメソッドを実行する *それぞれの* タイミングで、このメソッドを _先に_ 実行することを保証します。JUnit 4 では `@Before` を使用していました。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@AfterEach`             | 当該テストクラスについて、`@Test, @RepeatedTest, @ParameterizedTest, @TestFactory` で修飾されたメソッドを実行する *それぞれの* タイミングで、このメソッドを _後から_ 実行することを保証します。JUnit 4 では `@Before` を使用していました。_オーバーライド_ しなかったメソッドは _継承_ します。
| `@BeforeAll`             | 当該テストクラスについて、`@Test, @RepeatedTest, @ParameterizedTest, @TestFactory` で修飾された *全ての* メソッドより _先に_ 、このメソッドを実行することを保証します。JUnit 4 では `@BeforeClass` を使用していました。このアノテーションで修飾したメソッドは _隠蔽_ されたり _オーバーライド_ されたりしなければ _継承_ します。また、当該クラスが「クラス単位（per-class）」で <<writing-tests-test-instance-lifecycle, インスタンスのライフサイクル>> を管理していないなら、このアノテーションで修飾するメソッドは `static` で宣言しなければなりません。
| `@AfterAll`              | 当該テストクラスについて、`@Test, @RepeatedTest, @ParameterizedTest, @TestFactory` で修飾された *全ての* メソッドより _後に_ 、このメソッドを実行することを保証します。JUnit 4 では `@AfterClass` を使用していました。このアノテーションで修飾したメソッドは _隠蔽_ されたり _オーバーライド_ されたりしなければ _継承_ します。また、当該クラスが「クラス単位（per-class）」で <<writing-tests-test-instance-lifecycle, インスタンスのライフサイクル>> を管理していないなら、このアノテーションで修飾するメソッドは `static` で宣言しなければなりません。
| `@Nested`                | その内部クラスが <<writing-tests-nested, ネストテストクラス>> であることを示します。「クラス単位（per-class）」で <<writing-tests-test-instance-lifecycle, インスタンスのライフサイクル>> を管理していないなら、ネストテストクラスには `@BeforeAll` や `@AfterAll` で修飾したメソッドを定義できません。アノテーションは _継承_ しません。
| `@Tag`                   | クラスやメソッドのいずれかに、 <<writing-tests-tagging-and-filtering, テストを選択するためのタグ>> を定義します。TestNG におけるテストグループ、JUnit 4 におけるカテゴリーに相当します。このアノテーションでクラスを修飾した場合は _継承_ します。メソッドの場合は _継承_ しません。
| `@Disabled`              | そのクラスやメソッドが <<writing-tests-disabling, 無効>> であることを示します。JUnit 4 では `@Ignore` を使用していました。アノテーションは _継承_ しません。
| `@Timeout`               | `@Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate` で修飾されたメソッドの実行時間が指定した時間を超過したら失敗させます。アノテーションは _継承_ します。
| `@ExtendWith`            | クラスを修飾して、 <<extensions-registration-declarative, 登録する拡張機能を宣言的に記述>> します。アノテーションは _継承_ します。
| `@RegisterExtension`     | フィールドを修飾して、 <<extensions-registration-programmatic, 登録する拡張機能を手続き的に記述>> します。フィールドは _隠蔽_ されない限り _継承_ します。
| `@TempDir`               | フィールドや、テストメソッドおよびライフサイクルメソッドの引数へ、 <<writing-tests-built-in-extensions-TempDirectory, 一時ディレクトリ>> の情報を注入します。パッケージは `org.junit.jupiter.api.io` です。
|===


// WARNING: Some annotations may currently be _experimental_. Consult the table in
// <<api-evolution-experimental-apis>> for details.
WARNING: 一部のアノテーションは _実験的な機能_ です。詳しい状態は <<api-evolution-experimental-apis>> を参照してください。

[[writing-tests-meta-annotations]]
==== メタアノテーションと合成アノテーション

// JUnit Jupiter annotations can be used as _meta-annotations_. That means that you can
// define your own _composed annotation_ that will automatically _inherit_ the semantics of
// its meta-annotations.
JUnit Jupiter のアノテーションは _メタアノテーション_ として使用できます。
つまり、自分で定義した _合成アノテーション_ は、使用したメタアノテーションのセマンティクスを自動的に _継承_ できるのです。

// For example, instead of copying and pasting `@Tag("fast")` throughout your code base (see
// <<writing-tests-tagging-and-filtering>>), you can create a custom _composed annotation_
// named `@Fast` as follows. `@Fast` can then be used as a drop-in replacement for
// `@Tag("fast")`.
例えば、コードベースのあちこちに `@Tag("fast")` というコード片をコピーペーストで量産する代わりに、`@Fast` という _合成アノテーション_ を定義できるのです。
そうすれば、もともと `@Tag("fast")` と記述していた部分をそのまま置換できます。

[source,java,indent=0]
----
include::{testDir}/example/Fast.java[tags=user_guide]
----

// The following `@Test` method demonstrates usage of the `@Fast` annotation.
`@Fast` アノテーションは次のように使用できます。

[source,java,indent=0]
----
@Fast
@Test
void myFastTest() {
    // ...
}
----

// You can even take that one step further by introducing a custom `@FastTest` annotation
// that can be used as a drop-in replacement for `@Tag("fast")` _and_ `@Test`.
もう一歩先に進めて、 `@Tag("fast")` と `@Test` を置き換える `@FastTest` アノテーションを定義できます。

[source,java,indent=0]
----
include::{testDir}/example/FastTest.java[tags=user_guide]
----

// JUnit automatically recognizes the following as a `@Test` method that is tagged with
// "fast".
JUnit は `@FastTest` アノテーションで修飾したメソッドを、`@Test` アノテーションと "fast" タグを指定したメソッドとして自動的に認識します。

[source,java,indent=0]
----
@FastTest
void myFastTest() {
    // ...
}
----

[[writing-tests-classes-and-methods]]
=== テストクラスとテストメソッド

// **Test Class**: any top-level class, `static` member class, or <<writing-tests-nested,
// `@Nested` class>> that contains at least one _test method_.
**テストクラス**: 1つ以上の _テストメソッド_ を含む任意のトップレベルクラス、`static` 宣言したメンバークラス、<<writing-tests-nested, ネストテストクラス>>

// Test classes must not be `abstract` and must have a single constructor.
抽象クラスはテストクラスにできません。
また、テストクラスに定義できるコンストラクタは1つだけです。

// **Test Method**: any instance method that is directly annotated or meta-annotated with
// `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, or `@TestTemplate`.
**テストメソッド**: `@Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate` のいずれかのアノテーションで直接、あるいは、間接的に修飾されたインスタンスメソッド

// **Lifecycle Method**: any method that is directly annotated or meta-annotated with
// `@BeforeAll`, `@AfterAll`, `@BeforeEach`, or `@AfterEach`.
**ライフサイクルメソッド**: `@BeforeAll, @AfterAll, @BeforeEach, @AfterEach` のいずれかのアノテーションで直接、あるいは、間接的に修飾されたインスタンスメソッド

// Test methods and lifecycle methods may be declared locally within the current test class,
// inherited from superclasses, or inherited from interfaces (see
// <<writing-tests-test-interfaces-and-default-methods>>). In addition, test methods and
// lifecycle methods must not be `abstract` and must not return a value (except `@TestFactory`
// methods which are required to return a value).
テストメソッドとライフサイクルメソッドは、基底クラスから継承することもできますし、インターフェイスから継承することもできます（<<writing-tests-test-interfaces-and-default-methods>> を参照）。
なお、どちらのメソッドも抽象メソッドにできませんし、返り値も宣言できません（ただし `@TestFactory` メソッドには返り値が必要です）。

[NOTE]
// .Class and method visibility
.クラスとメソッドの可視性
====
// Test classes, test methods, and lifecycle methods are not required to be `public`, but
// they must _not_ be `private`.
テストクラス、テストメソッド、ライフサイクルメソッドの可視性は `public` でなくても構いませんが、`private` に _してはいけません_ 。

// It is generally recommended to omit the `public` modifier for test classes, test methods,
// and lifecycle methods unless there is a technical reason for doing so – for example, when
// a test class is extended by a test class in another package. Another technical reason for
// making classes and methods `public` is to simplify testing on the module path when using
// the Java Module System.
他のパッケージのテストクラスを継承する場合など、技術的な必要性がない限り、基本的にはテストクラスやテストメソッドの可視性に `public` を指定しないほうがいいでしょう。
JPMS（Java Platform Module System）のモジュールパスを単純化したい場合は、可視性を `public` にする理由になるでしょう。
====

// The following test class demonstrates the use of `@Test` methods and all supported
// lifecycle methods. For further information on runtime semantics, see
// <<writing-tests-test-execution-order>> and
// <<extensions-execution-order-wrapping-behavior>>.
次のコード例は `@Test` メソッドと全てのライフサイクルメソッドを使用したものです。
実行時のセマンティクスについては <<writing-tests-test-execution-order>> と <<extensions-execution-order-wrapping-behavior>> を参照してください。

// [source,java,indent=0]
// .A standard test class
[source,java,indent=0]
.基本的なテストクラス
----
include::{testDir}/example/StandardTests.java[tags=user_guide]
----

[[writing-tests-display-names]]
=== 表示名

// Test classes and test methods can declare custom display names via `@DisplayName` -- with
// spaces, special characters, and even emojis -- that will be displayed in test reports and
// by test runners and IDEs.
テストクラスやテストメソッドには `@DisplayName` で空白文字や特殊文字や絵文字などを含む独自の表示名を宣言できます。
表示名はテストレポートや IDE で実行したテストランナーで使用できます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameDemo.java[tags=user_guide]
----

[[writing-tests-display-name-generator]]
==== 表示名生成ロジック

// JUnit Jupiter supports custom display name generators that can be configured via the
// `@DisplayNameGeneration` annotation. Values provided via `@DisplayName` annotations
// always take precedence over display names generated by a `DisplayNameGenerator`.
JUnit Jupiter は `@DisplayNameGeneration` アノテーションで独自の表示名生成ロジックを使用できます。
ただし、`DisplayNameGenerator` の生成した表示名より、`@DisplayName` アノテーションで宣言した値を優先して使用します。

// Generators can be created by implementing `DisplayNameGenerator`. Here are some default
// ones available in Jupiter:
表示名生成ロジックを作成するときは `DisplayNamaGenerator` インターフェイスを実装します。
Jupiter の提供する既存の実装は次のとおりです。

[cols="20,80"]
// |===
// | DisplayNameGenerator   | Behavior

// | `Standard`             | Matches the standard display name generation behavior in place since JUnit Jupiter 5.0 was released.
// | `Simple`               | Removes trailing parentheses for methods with no parameters.
// | `ReplaceUnderscores`   | Replaces underscores with spaces.
// | `IndicativeSentences`  | Generates complete sentences by concatenating the names of the test and the enclosing classes.
// |===
|===
| DisplayNameGenerator の実装クラス   | 振る舞い

| `Standard`             | JUnit Jupiter 5.0 で導入された標準的な表示名生成ロジックです。
| `Simple`               | 引数無しテストメソッドの括弧を除去します。
| `ReplaceUnderscores`   | アンダースコアを空白文字で置換します。
| `IndicativeSentences`  | エンクロージングクラスの名前と、テストクラスやテストメソッドの名前を連結して完全な文章を生成します。
|===

// Note that for `IndicativeSentences`, you can customize the separator and the
// underlying generator by using `@IndicativeSentencesGeneration` as shown in the
// following example.
`IndicativeSentences` については、区切り文字と内部で使用する表示名生成ロジックを `@IndicativeSentencesGeneration` アノテーションで設定できます。

[source,java,indent=0]
----
include::{testDir}/example/DisplayNameGeneratorDemo.java[tags=user_guide]
----

```
+-- DisplayNameGeneratorDemo [OK]
  +-- A year is not supported [OK]
  | +-- A negative value for year is not supported by the leap year computation. [OK]
  | | +-- For example, year -1 is not supported. [OK]
  | | '-- For example, year -4 is not supported. [OK]
  | '-- if it is zero() [OK]
  '-- A year is a leap year [OK]
    +-- A year is a leap year -> if it is divisible by 4 but not by 100. [OK]
    '-- A year is a leap year -> if it is one of the following years. [OK]
      +-- Year 2016 is a leap year. [OK]
      +-- Year 2020 is a leap year. [OK]
      '-- Year 2048 is a leap year. [OK]
```


[[writing-tests-display-name-generator-default]]
==== 表示名生成ロジックの初期値を変更する

// You can use the `junit.jupiter.displayname.generator.default`
// <<running-tests-config-params, configuration parameter>> to specify the fully qualified
// class name of the `DisplayNameGenerator` you would like to use by default. Just like for
// display name generators configured via the `@DisplayNameGeneration` annotation, the
// supplied class has to implement the `DisplayNameGenerator` interface. The default display
// name generator will be used for all tests unless the `@DisplayNameGeneration` annotation
// is present on an enclosing test class or test interface. Values provided via
// `@DisplayName` annotations always take precedence over display names generated by a
// `DisplayNameGenerator`.
`junit.jupiter.displayname.generator.default` という <<running-tests-config-params, 設定パラメータ>> で、JUnit Jupiter が `DisplayNameGenerator` の初期値として使用するクラスの完全修飾クラス名を指定できます。
`@DisplayNameGeneration` アノテーションで指定するのと同じように、`DisplayNameGenerator` インターフェイスの実装クラスを指定します。
エンクロージングクラスやインターフェイスを `@DisplayNameGeneration` アノテーションで修飾しない限り、常に `DisplayNameGenerator` の初期値を使用します。
そして、`@DisplayName` アノテーションで宣言した値は常に優先されます。

// For example, to use the `ReplaceUnderscores` display name generator by default, you should
// set the configuration parameter to the corresponding fully qualified class name (e.g., in
// `src/test/resources/junit-platform.properties`):
例えば、表示名生成ロジックの初期値として `ReplaceUnderscores` を使うには、プロパティファイル（例えば `src/test/resources/junit-platform.properties`）へ次のように記述します。

[source,properties,indent=0]
----
junit.jupiter.displayname.generator.default = \
    org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
----

// Similarly, you can specify the fully qualified name of any custom class that implements
// `DisplayNameGenerator`.
自分で作成した `DisplayNameGenerator` インターフェイスの実装クラスも同じように指定できます。

[[writing-tests-display-name-generator-precedence-rules]]
// In summary, the display name for a test class or method is determined according to the
// following precedence rules:
まとめると、テストクラスやテストメソッドの表示名は次の優先順位に従って決定されます。

// 1. value of the `@DisplayName` annotation, if present
// 2. by calling the `DisplayNameGenerator` specified in the `@DisplayNameGeneration`
//    annotation, if present
// 3. by calling the default `DisplayNameGenerator` configured via the configuration
//    parameter, if present
// 4. by calling `org.junit.jupiter.api.DisplayNameGenerator.Standard`

1. `@DisplayName` アノテーションで宣言した値
2. `@DisplayNameGeneration` で宣言した `DisplayNameGenerator` の返す値
3. プロパティフィルで指定した `DisplayNameGenerator` の初期値が返す値
4. `org.junit.jupiter.api.DisplayNameGenerator.Standard` が返す値

[[writing-tests-assertions]]
=== アサーション

// JUnit Jupiter comes with many of the assertion methods that JUnit 4 has and adds a few
// that lend themselves well to being used with Java 8 lambdas. All JUnit Jupiter assertions
// are `static` methods in the `{Assertions}` class.
JUnit Jupiter は大量のアサーションメソッドを提供します。
JUnit 4 でも提供していたメソッドに加えて、それらのメソッドを Java 8 のラムダ式で使えるようにしたメソッドが増えています。
全てのアサーションメソッドは `{Assertions}` クラスの `static` メソッドとして定義されています。

[source,java,indent=0]
----
include::{testDir}/example/AssertionsDemo.java[tags=user_guide]
----

[[writing-tests-assertions-preemptive-timeouts]]
// [WARNING]
// .Preemptive Timeouts with `assertTimeoutPreemptively()`
[WARNING]
.予防的なタイムアウトを `assertTimeoutPreemptively()` で記述する
====
// Contrary to <<writing-tests-declarative-timeouts, declarative timeouts>>, the various
// `assertTimeoutPreemptively()` methods in the `Assertions` class execute the provided
// `executable` or `supplier` in a different thread than that of the calling code. This
// behavior can lead to undesirable side effects if the code that is executed within the
// `executable` or `supplier` relies on `java.lang.ThreadLocal` storage.
<<writing-tests-declarative-timeouts, 宣言的タイムアウト>> と逆に、`Assertions` クラスの `assertTimeoutPreemptively()` メソッドは指定された `executable` あるいは `supplier` を、呼び出し元とは別のスレッドで実行します。
そのため、`executable` や `supplier` で `java.lang.ThreadLocal` を使用するコードを実行すると、予期せぬ副作用を引き起こす可能性があります。

// One common example of this is the transactional testing support in the Spring Framework.
// Specifically, Spring's testing support binds transaction state to the current thread (via
// a `ThreadLocal`) before a test method is invoked. Consequently, if an `executable` or
// `supplier` provided to `assertTimeoutPreemptively()` invokes Spring-managed components
// that participate in transactions, any actions taken by those components will not be rolled
// back with the test-managed transaction. On the contrary, such actions will be committed to
// the persistent store (e.g., relational database) even though the test-managed transaction
// is rolled back.
典型的な例の1つとして、Spring Framework の提供するトランザクション管理機能が挙げられます。
特に、テストメソッドを実行する前のトランザクション状態を `ThreadLocal` へ記録している場合に問題になります。
つまり、`assertTimeoutPreemptively()` メソッドに渡した `executable` あるいは `supplier` の実行する Spring のコンポーネントがトランザクションで行ったあらゆる操作を、テストの管理しているトランザクションとしてロールバックできないのです。
たとえテストの管理しているトランザクションをロールバックしても、コミットした結果は永続化されてしまいます。

// Similar side effects may be encountered with other frameworks that rely on
// `ThreadLocal` storage.
`ThreadLocal` を使用している他のフレームワークでも同じような副作用に悩まされるでしょう。
====

[[writing-tests-assertions-kotlin]]
==== Kotlin 用のアサーション

// JUnit Jupiter also comes with a few assertion methods that lend themselves well to being
// used in https://kotlinlang.org/[Kotlin]. All JUnit Jupiter Kotlin assertions are top-level
// functions in the `org.junit.jupiter.api` package.
JUnit Jupiter は https://kotlinlang.org/[Kotlin] から使用するためのアサーションメソッドを提供しています。
全てのアサーション関数は `org.junit.jupiter.api` パッケージのトップレベル関数として定義されています。

[source,kotlin,indent=0]
----
include::{kotlinTestDir}/example/KotlinAssertionsDemo.kt[tags=user_guide]
----

[[writing-tests-assertions-third-party]]
==== 外部のアサーションライブラリ

// Even though the assertion facilities provided by JUnit Jupiter are sufficient for many
// testing scenarios, there are times when more power and additional functionality such as
// _matchers_ are desired or required. In such cases, the JUnit team recommends the use of
// third-party assertion libraries such as {AssertJ}, {Hamcrest}, {Truth}, etc. Developers
// are therefore free to use the assertion library of their choice.
Junit Jupiter はたいていのテストを満足するアサーションの部品を提供していますが、_マッチャー_ のようにより強力で便利な機能が必要になる場合もあります。
そういう場合、JUnit チームとしては {AssertJ} や {Hamcrest} や {Truth} などの外部ライブラリを使用することをお勧めしています。
開発者は自由にアサーションライブラリを選択できるのです。

// For example, the combination of _matchers_ and a fluent API can be used to make
// assertions more descriptive and readable. However, JUnit Jupiter's `{Assertions}` class
// does not provide an
// https://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`]
// method like the one found in JUnit 4's `org.junit.Assert` class which accepts a Hamcrest
// https://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Matcher`]. Instead,
// developers are encouraged to use the built-in support for matchers provided by third-party
// assertion libraries.
例えば、_マッチャー_ を組み合わせたり、フルーエント API を使うことで、可読性や説明力の高いアサーションを表現できるようになります。
JUnit 4 の `org.junit.Assert` クラスが提供する
https://junit.org/junit4/javadoc/latest/org/junit/Assert.html#assertThat[`assertThat()`]
は、
https://junit.org/junit4/javadoc/latest/org/hamcrest/Matcher.html[`Hamcrest のマッチャー`]
を組み合わせて使用できるようになっていました。
しかし、JUnit Jupiter の `{Assertions}` クラスは `assertThat()` を提供していないため、開発者は外部アサーションライブラリの提供するマッチャーを使わなければなりません。

// The following example demonstrates how to use the `assertThat()` support from Hamcrest in
// a JUnit Jupiter test. As long as the Hamcrest library has been added to the classpath,
// you can statically import methods such as `assertThat()`, `is()`, and `equalTo()` and
// then use them in tests like in the `assertWithHamcrestMatcher()` method below.
次のコード例では、JUnit Jupiter のテストで Hamcrest の提供する `assertThat()` を使っています。
Hamcrest の jar ファイルがクラスパスに存在するなら、`assertThat(), is(), equalTo()` などの `static` メソッドを import して、`assertWithHamcrestMatcher()` テストメソッドで使用できます。

[source,java,indent=0]
----
include::{testDir}/example/HamcrestAssertionsDemo.java[tags=user_guide]
----

// Naturally, legacy tests based on the JUnit 4 programming model can continue using
// `org.junit.Assert#assertThat`.
JUnit 4 のプログラミングモデルで作成したテストなら引き続き `org.junit.Assert#assertThat` メソッドを使用できます。

[[writing-tests-assumptions]]
=== アサンプション（仮定）

// JUnit Jupiter comes with a subset of the assumption methods that JUnit 4 provides and
// adds a few that lend themselves well to being used with Java 8 lambda expressions and
// method references. All JUnit Jupiter assumptions are static methods in the
// `{Assumptions}` class.
JUnit Jupiter では、JUnit 4 で提供していたアサンプションメソッドの一部と、それらのメソッドを Java 8 のラムダ式でメソッド参照として使用できるようにしたメソッドを提供しています。
全てのアサンプションメソッドは `{Assumptions}` クラスの `static` メソッドとして定義されています。

[source,java,indent=0]
----
include::{testDir}/example/AssumptionsDemo.java[tags=user_guide]
----

// NOTE: As of JUnit Jupiter 5.4, it is also possible to use methods from JUnit 4's
// `org.junit.Assume` class for assumptions. Specifically, JUnit Jupiter supports JUnit 4's
// `AssumptionViolatedException` to signal that a test should be aborted instead of marked
// as a failure.
NOTE: JUnit Jupiter 5.4 から JUnit 4 の `org.junit.Assume` クラスのメソッドをアサンプションメソッドとして使えるようになりました。
例えば、JUnit 4 の `AssumptionViolatedException` で、本来失敗とするべきテストを中断できるようになっています。

[[writing-tests-disabling]]
=== テストを無効にする

// Entire test classes or individual test methods may be _disabled_ via the `{Disabled}`
// annotation, via one of the annotations discussed in
// <<writing-tests-conditional-execution>>, or via a custom <<extensions-conditions,
// `ExecutionCondition`>>.
<<writing-tests-conditional-execution>> で紹介した `{Disabled}` アノテーションで修飾したり、独自の <<extensions-conditions, `ExecutionCondition`>> を作成したりすることで、テストクラス全体あるいは一部のテストメソッドだけを _無効_ にできます。

// Here's a `@Disabled` test class.
次のコード例では `@Disabled` でテストクラスを無効にしています。

[source,java,indent=0]
----
include::{testDir}/example/DisabledClassDemo.java[tags=user_guide]
----

// And here's a test class that contains a `@Disabled` test method.
次のコード例では `@Disabled` でテストメソッドを無効にしています。

[source,java,indent=0]
----
include::{testDir}/example/DisabledTestsDemo.java[tags=user_guide]
----

// NOTE: `@Disabled` may be declared without providing a _reason_; however, the JUnit team
// recommends that developers provide a short explanation for why a test class or test
// method has been disabled. Consequently, the above examples both show the use of a reason
// -- for example, `@Disabled("Disabled until bug \#42 has been resolved")`. Some development
// teams even require the presence of issue tracking numbers in the _reason_ for automated
// traceability, etc.
NOTE: _理由（reason）_ を指定せずに `@Disabled` を記述する場合もあると思います。
しかし、JUnit チームとしては、簡単でいいからテストクラスやテストメソッドを無効にする理由を書いたほうがいいと考えています。
コード例では `@Disabled("Disabled until bug \#42 has been resolved")` のように理由を書いています。
開発チームによっては、課題管理ツールに登録した課題を自動的に追跡できるよう、課題番号を書いている場合もあるそうです。

[[writing-tests-conditional-execution]]
=== 条件に基づくテスト実行

// The <<extensions-conditions, `ExecutionCondition`>> extension API in JUnit Jupiter allows
// developers to either _enable_ or _disable_ a container or test based on certain
// conditions _programmatically_. The simplest example of such a condition is the built-in
// `{DisabledCondition}` which supports the `{Disabled}` annotation (see
// <<writing-tests-disabling>>). In addition to `@Disabled`, JUnit Jupiter also supports
// several other annotation-based conditions in the `org.junit.jupiter.api.condition`
// package that allow developers to enable or disable containers and tests _declaratively_.
// When multiple `ExecutionCondition` extensions are registered, a container or test is
// disabled as soon as one of the conditions returns _disabled_. If you wish to provide
// details about why they might be disabled, every annotation associated with these built-in
// conditions has a `disabledReason` attribute available for that purpose.
JUnit Jupiter の <<extensions-conditions, `ExecutionCondition`>> API を使うと、_手続き的に評価した条件_ に応じて、テストコンテナやテストの _有効_ と _無効_ を制御できます。
組み込みの `ExecutionCondition` の中でも分かりやすいのは、`{Disabled}` アノテーション（<<writing-tests-disabling>>）に対応する `{DisabledCondition}` です。
`org.junit.jupiter.api.condition` パッケージには、`@Disabled` 以外のさまざまなアノテーションに対応する `ExecutionCondition` があるため、開発者は _宣言的に_ テストクラスやテストメソッドの _有効_ や _無効_ を制御できます。
複数の `ExecutionCondition` を登録した場合、どれか1つでも条件を満たせばテストコンテナやテストは直ちに _無効_ になります。
組み込みの `ExecutionCondition` に対応する全てのアノテーションには `disabledReason` という属性があるため、テストを無効にした理由を提供できます。

// See <<extensions-conditions, `ExecutionCondition`>> and the following sections for
// details.
<<extensions-conditions, `ExecutionCondition`>> や、次のセクションも参照してください。

// [TIP]
// .Composed Annotations
[TIP]
.合成アノテーション
====
// Note that any of the _conditional_ annotations listed in the following sections may also
// be used as a meta-annotation in order to create a custom _composed annotation_. For
// example, the `@TestOnMac` annotation in the
// <<writing-tests-conditional-execution-os-demo, @EnabledOnOs demo>> shows how you can
// combine `@Test` and `@EnabledOnOs` in a single, reusable annotation.
次のセクションで説明している、_条件として使用できる_ 全てのアノテーションは、_合成アノテーション_ を作るためのメタアノテーションとして使用できます。
例えば、 <<writing-tests-conditional-execution-os-demo, @EnabledOnOs デモ>> では `@Test` と `@EnabledOnOs` を組み合わせて単一の再利用可能なアノテーション `@TestOnMac` の作り方を説明しています。
====

[WARNING]
====
// Unless otherwise stated, each of the _conditional_ annotations listed in the following
// sections can only be declared once on a given test interface, test class, or test method.
// If a conditional annotation is directly present, indirectly present, or meta-present
// multiple times on a given element, only the first such annotation discovered by JUnit will
// be used; any additional declarations will be silently ignored. Note, however, that each
// conditional annotation may be used in conjunction with other conditional annotations in
// the `org.junit.jupiter.api.condition` package.
特別な記載がない限り、次のセクションで説明している _条件として使用できる_ 全てのアノテーションは1度しか指定できません。
直接的に指定するだけでなく、継承やメタアノテーションにより間接的に指定する場合も含めて、JUnit は最初に発見したアノテーションだけを使用します。
他のアノテーションは無視されてしまうのです。
しかし、`org.junit.jupiter.api.condition` パッケージには、他のアノテーションと組み合わせたアノテーションもあるので注意してください。
====

[[writing-tests-conditional-execution-os]]
==== OS の条件指定

// A container or test may be enabled or disabled on a particular operating system via the
// `{EnabledOnOs}` and `{DisabledOnOs}` annotations.
`{EnabledOnOs}` や `{DisabledOnOs}` を使うと、指定した OS でテストコンテナやテストの有効と無効を制御できます。


[[writing-tests-conditional-execution-os-demo]]
[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_os]
----

[[writing-tests-conditional-execution-jre]]
==== Java 実行環境（JRE：Java Runtime Environment） の条件指定

// A container or test may be enabled or disabled on particular versions of the Java
// Runtime Environment (JRE) via the `{EnabledOnJre}` and `{DisabledOnJre}` annotations
// or on a particular range of versions of the JRE via the `{EnabledForJreRange}` and
// `{DisabledForJreRange}` annotations. The range defaults to `{JRE}.JAVA_8` as the lower
// border (`min`) and `{JRE}.OTHER` as the higher border (`max`), which allows usage of
// half open ranges.
`{EnabledOnJre}` や `{DisabledOnJre}` を使うと、指定した JRE でテストコンテナやテストの有効と無効を制御できます。
`{EnabledForJreRange}` や `{DisabledForJreRange}` を使うと、JRE のバージョンを範囲指定できます。
範囲指定の最小値（`min`）の初期値は `{JRE}.JAVA_8` で、最大値（`max`）の初期値は `{JRE}.OTHER` です。
範囲は半開区間として評価します。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_jre]
----

[[writing-tests-conditional-execution-system-properties]]
==== システムプロパティの条件指定

// A container or test may be enabled or disabled based on the value of the `named` JVM
// system property via the `{EnabledIfSystemProperty}` and `{DisabledIfSystemProperty}`
// annotations. The value supplied via the `matches` attribute will be interpreted as a
// regular expression.
`{EnabledIfSystemProperty}` や `{DisabledIfSystemProperty}` を使うと、指定したシステムプロパティでテストコンテナやテストの有効と無効を制御できます。
`matches` 属性に指定した値は正規表現として評価します。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_system_property]
----

[TIP]
====
// As of JUnit Jupiter 5.6, `{EnabledIfSystemProperty}` and `{DisabledIfSystemProperty}` are
// _repeatable annotations_. Consequently, these annotations may be declared multiple times
// on a test interface, test class, or test method. Specifically, these annotations will be
// found if they are directly present, indirectly present, or meta-present on a given element.
JUnit Jupiter 5.6 から、`{EnabledIfSystemProperty}` と `{DisabledIfSystemProperty}` は _繰り返し可能なアノテーション_ になりました。
その結果、これらのアノテーションはテストクラスやテストメソッドに複数回指定できるようになりました。
直接的に指定するだけでなく、継承やメタアノテーションにより間接的に指定する場合もあるでしょう。
====

[[writing-tests-conditional-execution-environment-variables]]
==== 環境変数の条件指定

// A container or test may be enabled or disabled based on the value of the `named`
// environment variable from the underlying operating system via the
// `{EnabledIfEnvironmentVariable}` and `{DisabledIfEnvironmentVariable}` annotations. The
// value supplied via the `matches` attribute will be interpreted as a regular expression.
`{EnabledIfEnvironmentVariable}` や `{DisabledIfEnvironmentVariable}` を使うと、指定したシステムプロパティでテストコンテナやテストの有効と無効を制御できます。
`matches` 属性に指定した値は正規表現として評価します。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_environment_variable]
----

[TIP]
====
// As of JUnit Jupiter 5.6, `{EnabledIfEnvironmentVariable}` and
// `{DisabledIfEnvironmentVariable}` are _repeatable annotations_. Consequently, these
// annotations may be declared multiple times on a test interface, test class, or test
// method. Specifically, these annotations will be found if they are directly present,
// indirectly present, or meta-present on a given element.
JUnit Jupiter 5.6 から、`{EnabledIfEnvironmentVariable}` と `{DisabledIfEnvironmentVariable}` は _繰り返し可能なアノテーション_ になりました。
その結果、これらのアノテーションはテストクラスやテストメソッドに複数回指定できるようになりました。
直接的に指定するだけでなく、継承やメタアノテーションにより間接的に指定する場合もあるでしょう。
====

[[writing-tests-conditional-execution-custom]]
==== 独自の条件指定

// A container or test may be enabled or disabled based on the boolean return of a
// method via the `{EnabledIf}` and `{DisabledIf}` annotations. The method is provided to
// the annotation via its name.
// If needed, the condition method can take a single parameter of type `ExtensionContext`.
`{EnabledIf}` や `{DisabledIf}` を使うと、指定した名前のメソッドを実行したときの返り値に応じて、テストコンテナやテストの有効と無効を制御できます。
指定するメソッドには単一の引数 `ExtensionContext` を渡すことができます。

[source,java,indent=0]
----
include::{testDir}/example/ConditionalTestExecutionDemo.java[tags=user_guide_custom]
----

// Alternatively, the condition method can be located outside the test class. In this case,
// it has to be referenced by its _fully qualified name_ as demonstrated in the following
// example.
一方、テストクラス以外の場所で定義されたメソッドを指定することもできます。
メソッド名は _完全修飾名_ で指定しなければなりません。

[source,java,indent=0]
----
package example;

include::{testDir}/example/ExternalCustomConditionDemo.java[tags=user_guide_external_custom_condition]
----

// NOTE: When `{EnabledIf}` or `{DisabledIf}` is used at class level, the condition method
// must always be `static`. Condition methods located in external classes must also be
// `static`. In any other case, you can use both static or instance methods.
NOTE: テストクラスに `{EnabledIf}` や `{EnabledIf}` を指定するときに指定できるメソッドは `static` 宣言しなければなりません。
テストクラス以外の場所で定義されたメソッドを指定するとして、そのメソッドも `static` 宣言しなければなりません。
それ以外の場合は `static` 宣言したメソッドと、インスタンスメソッドのどちらでも利用できます。

[[writing-tests-tagging-and-filtering]]
=== タグ付けと選択

// Test classes and methods can be tagged via the `@Tag` annotation. Those tags can later be
// used to filter <<running-tests, test discovery and execution>>. Please refer to the
// <<running-tests-tags>> section for more information about tag support in the JUnit
// Platform.
テストクラスやテストメソッドには `@Tag` アノテーションでタグ付けが可能です。
タグは <<running-tests, テストを検出して実行>> するときにテストを選択するための条件に使用できます。
<<running-tests-tags>> セクションでは JUnit Platform のタグ機能について説明しています。

[source,java,indent=0]
----
include::{testDir}/example/TaggingDemo.java[tags=user_guide]
----

// TIP: See <<writing-tests-meta-annotations>> for examples demonstrating how to create
// custom annotations for tags.
TIP: タグ付けのためのアノテーションを作成する方法については <<writing-tests-meta-annotations>> を参照してください。

[[writing-tests-test-execution-order]]
=== テストの実行順序

// By default, test classes and methods will be ordered using an algorithm that is
// deterministic but intentionally nonobvious. This ensures that subsequent runs of a test
// suite execute test classes and test methods in the same order, thereby allowing for
// repeatable builds.
初期設定では、テストクラスやテストメソッドの実行順序が、意図的に曖昧にした決定論的なアルゴリズムで決まるようになっています。
テストスイートが実行するテストクラスやテストメソッドの順番は変わらないことが保証されているため、繰り返し可能なビルド（repeatable build）を推進してくれます。

// NOTE: See <<writing-tests-classes-and-methods>> for a definition of _test method_ and
// _test class_.
NOTE: _テストクラス_ や _テストメソッド_ の定義については <<writing-tests-classes-and-methods>> を参照してください。

[[writing-tests-test-execution-order-methods]]
==== テストメソッドの実行順序

// Although true _unit tests_ typically should not rely on the order in which they are
// executed, there are times when it is necessary to enforce a specific test method execution
// order -- for example, when writing _integration tests_ or _functional tests_ where the
// sequence of the tests is important, especially in conjunction with
// `@TestInstance(Lifecycle.PER_CLASS)`.
本物の _ユニットテスト_ は普通ならどのような順番で実行しても同じ結果になるべきだと言われています。
しかし、どうしても実行する順番を指定しなければならないこともあります。
例えば、_統合テスト_ や _機能テスト_ を作成するときは順番が重要です。
特に `@TestInstance(Lifecycle.PER_CLASS)` も組み合わせているならなおのことです。

// To control the order in which test methods are executed, annotate your test class or test
// interface with `{TestMethodOrder}` and specify the desired `{MethodOrderer}`
// implementation. You can implement your own custom `MethodOrderer` or use one of the
// following built-in `MethodOrderer` implementations.
テストメソッドを実行する順番を制御するには、テストクラスやテストインターフェイスを `{TestMethodOrder}` アノテーションで修飾し、適切な `{MethodOrderer}` の実装を指定します。
`MethodOrderer` インターフェイスを自分で実装することもできますし、組み込みの実装を使うこともできます。

// * `{MethodOrderer_DisplayName}`: sorts test methods _alphanumerically_ based on their
//   display names (see <<writing-tests-display-name-generator-precedence-rules, display name
//   generation precedence rules>>)
// * `{MethodOrderer_MethodName}`: sorts test methods _alphanumerically_ based on their names
//   and formal parameter lists
// * `{MethodOrderer_OrderAnnotation}`: sorts test methods _numerically_ based on values
//   specified via the `{Order}` annotation
// * `{MethodOrderer_Random}`: orders test methods _pseudo-randomly_ and supports
//   configuration of a custom _seed_
// * `{MethodOrderer_Alphanumeric}`: sorts test methods _alphanumerically_ based on their
//   names and formal parameter lists; **deprecated in favor of `{MethodOrderer_MethodName}`,
//   to be removed in 6.0**
* `{MethodOrderer_DisplayName}`: テストメソッドの表示名に基づいて _英数字の昇順_ に並び替えます。<<writing-tests-display-name-generator-precedence-rules, 表示名の決定規則>> も参照してください
* `{MethodOrderer_MethodName}`: テストメソッドの名前と形式的な引数リストの名前に基づいて _英数字の昇順_ に並び替えます。
* `{MethodOrderer_OrderAnnotation}`: `{Order}` アノテーションに指定した整数値に基づいて _数字の昇順_ に並び替えます。
* `{MethodOrderer_Random}`: _疑似乱数_ に基づいて並び替えます。乱数の _シード_ を指定できます。
* `{MethodOrderer_Alphanumeric}`: テストメソッドの名前と形式的な引数リストの名前に基づいて _英数字の昇順_ に並び替えます。**`{MethodOrderer_MethodName}` を導入したため非推奨になりました。6.0 をリリースするときに削除されます。**

// NOTE: See also: <<extensions-execution-order-wrapping-behavior>>
NOTE: <<extensions-execution-order-wrapping-behavior>> も参照してください。

// The following example demonstrates how to guarantee that test methods are executed in the
// order specified via the `@Order` annotation.
次のコード例は `@Order` アノテーションでテストメソッドの実行順序を指定しています。

[source,java,indent=0]
----
include::{testDir}/example/OrderedTestsDemo.java[tags=user_guide]
----

[[writing-tests-test-execution-order-methods-default]]
===== テストメソッドの実行順序の初期値を変更する

// You can use the `junit.jupiter.testmethod.order.default` <<running-tests-config-params,
// configuration parameter>> to specify the fully qualified class name of the
// `{MethodOrderer}` you would like to use by default. Just like for the orderer configured
// via the `{TestMethodOrder}` annotation, the supplied class has to implement the
// `MethodOrderer` interface. The default orderer will be used for all tests unless the
// `@TestMethodOrder` annotation is present on an enclosing test class or test interface.
`junit.jupiter.testmethod.order.default` という <<running-tests-config-params, 設定パラメータ>> で、JUnit Jupiter が初期値として使用する `{MethodOrderer}` の実装クラスの完全修飾クラス名を指定できます。
エンクロージングクラスやインターフェイスを `{TestMethodOrder}` アノテーションで修飾しない限り、常に `MethodOrderer` の初期値を使用します。
そして、`@TestMethodOrder` アノテーションで指定した順序決定ルールは常に優先されます。

// For example, to use the `{MethodOrderer_OrderAnnotation}` method orderer by default, you
// should set the configuration parameter to the corresponding fully qualified class name
// (e.g., in `src/test/resources/junit-platform.properties`):
初期値を `{MethodOrderer_OrderAnnotation}` へ変更するには、プロパティファイル（例えば `src/test/resources/junit-platform.properties`）へ次のように記述します。

[source,properties,indent=0]
----
junit.jupiter.testmethod.order.default = \
    org.junit.jupiter.api.MethodOrderer$OrderAnnotation
----

// Similarly, you can specify the fully qualified name of any custom class that implements
// `MethodOrderer`.
自分で作成した `MethodOrderer` インターフェイスの実装クラスも同じように指定できます。

[[writing-tests-test-execution-order-classes]]
==== テストクラスの実行順序

// Although test classes typically should not rely on the order in which they are executed,
// there are times when it is desirable to enforce a specific test class execution order. You
// may wish to execute test classes in a random order to ensure there are no accidental
// dependencies between test classes, or you may wish to order test classes to optimize build
// time as outlined in the following scenarios.
普通ならテストクラスをどのような順番で実行しても同じ結果になるべきだと言われています。
しかし、どうしても実行する順番を指定しなければならないこともあります。
テストクラス間に意図しない依存関係は存在しないことを保証するため、テストクラスをランダムな順序で実行したい場合もあるでしょう。
また、ビルド時間を最適化するため、実行順序を指定したい場合もあるでしょう。

// * Run previously failing tests and faster tests first: "fail fast" mode
// * With parallel execution enabled, run longer tests first: "shortest test plan execution
//   duration" mode
// * Various other use cases

* 前回失敗したテストを先に実行したい: フェールファストモード
* 並列実行できるなら時間のかかるテストを先に実行したい: テスト実行時間最小化モード
* それ以外のさまざまなユースケース

// To configure test class execution order _globally_ for the entire test suite, use the
// `junit.jupiter.testclass.order.default` <<running-tests-config-params, configuration
// parameter>> to specify the fully qualified class name of the `{ClassOrderer}` you would
// like to use. The supplied class must implement the `ClassOrderer` interface.
テストスイートの _大域的な_ テストクラスの実行順序は、`junit.jupiter.testclass.order.default` という <<running-tests-config-params, 設定パラメータ>> で、JUnit Jupiter が初期値として使用する `{ClassOrderer}` の実装クラスの完全修飾クラス名を指定できます。

// You can implement your own custom `ClassOrderer` or use one of the following built-in
// `ClassOrderer` implementations.
自分で作成した `ClassOrderer` インターフェイスの実装クラスも同じように指定できます。

// * `{ClassOrderer_ClassName}`: sorts test classes _alphanumerically_ based on their fully
//   qualified class names
// * `{ClassOrderer_DisplayName}`: sorts test classes _alphanumerically_ based on their
//   display names (see <<writing-tests-display-name-generator-precedence-rules, display name
//   generation precedence rules>>)
// * `{ClassOrderer_OrderAnnotation}`: sorts test classes _numerically_ based on values
//   specified via the `{Order}` annotation
// * `{ClassOrderer_Random}`: orders test classes _pseudo-randomly_ and supports
//   configuration of a custom _seed_
* `{ClassOrderer_ClassName}`: テストクラスの完全修飾クラス名に基づいて _英数字の昇順_ に並び替えます。
* `{ClassOrderer_DisplayName}`: テストクラスの表示名に基づいて _英数字の昇順_ に並び替えます。<<writing-tests-display-name-generator-precedence-rules, 表示名の決定規則>> も参照してください
* `{ClassOrderer_OrderAnnotation}`: `{Order}` アノテーションに指定した整数値に基づいて _数字の昇順_ に並び替えます。
* `{ClassOrderer_Random}`: _疑似乱数_ に基づいて並び替えます。乱数の _シード_ を指定できます。

// For example, for the `@Order` annotation to be honored on _test classes_, you should
// configure the `{ClassOrderer_OrderAnnotation}` class orderer using the configuration
// parameter with the corresponding fully qualified class name (e.g., in
// `src/test/resources/junit-platform.properties`):
次のコード例は `@Order` アノテーションで _テストクラス_ の実行順序を指定しています。
初期値を `{ClassOrderer_OrderAnnotation}` へ変更するには、プロパティファイル（例えば `src/test/resources/junit-platform.properties`）へ次のように記述します。

[source,properties,indent=0]
----
junit.jupiter.testclass.order.default = \
    org.junit.jupiter.api.ClassOrderer$OrderAnnotation
----

// The configured `ClassOrderer` will be applied to all top-level test classes (including
// `static` nested test classes) and `@Nested` test classes.
`ClassOrder` は、全てのトップレベルテストクラス（`static` 宣言したネストテストクラスも含む）と `@Nested` で修飾したネストテストクラスに指定できます。

// NOTE: Top-level test classes will be ordered relative to each other; whereas, `@Nested`
// test classes will be ordered relative to other `@Nested` test classes sharing the same
// _enclosing class_.
NOTE: トップレベルテストクラスの順序は同じトップレベルテストクラス同士で比較します。同じエンクロージングクラスのネストテストクラスの順序は、同じエンクロージングクラスのネストテストクラス同士で比較します。

// To configure test class execution order _locally_ for `@Nested` test classes, declare the
// `{TestClassOrder}` annotation on the enclosing class for the `@Nested` test classes you
// want to order, and supply a class reference to the `ClassOrderer` implementation you would
// like to use directly in the `@TestClassOrder` annotation. The configured `ClassOrderer`
// will be applied recursively to `@Nested` test classes and their `@Nested` test classes.
// Note that a local `@TestClassOrder` declaration always overrides an inherited
// `@TestClassOrder` declaration or a `ClassOrderer` configured globally via the
// `junit.jupiter.testclass.order.default` configuration parameter.
ネストテストクラスの _局所的な_ 実行順序を指定するには、エンクロージングクラスを `{TestClassOrder}` で修飾します。
そして `@TestClassOrder` アノテーションに `ClassOrder` を実装したクラスのクラス参照を直接指定します。
`ClassOrder` は再帰的にネストテストクラスを探索します。
`@TestClassOrder` の局所的な宣言は、基底クラスから継承した `@TestClassOrder` の宣言で上書きされます。
また、設定パラメータ `junit.jupiter.testclass.order.default` で大域的に宣言した `ClassOrder` で上書きされます。

// The following example demonstrates how to guarantee that `@Nested` test classes are
// executed in the order specified via the `@Order` annotation.
次のコード例は `@Order` アノテーションで _ネストテストクラス_ の実行順序を指定しています。

[source,java,indent=0]
----
include::{testDir}/example/OrderedNestedTestClassesDemo.java[tags=user_guide]
----

[[writing-tests-test-instance-lifecycle]]
=== テストインスタンスのライフサイクル

// In order to allow individual test methods to be executed in isolation and to avoid
// unexpected side effects due to mutable test instance state, JUnit creates a new instance
// of each test class before executing each _test method_ (see
// <<writing-tests-classes-and-methods>>). This "per-method" test instance lifecycle is the
// default behavior in JUnit Jupiter and is analogous to all previous versions of JUnit.
それぞれのテストメソッドが独立して実行できるよう、そして、変更可能なテストインスタンスの状態に基づく予期せぬ副作用を無くすため、JUnit は _テストメソッド_ （<<writing-tests-classes-and-methods>>）を実行するたびに、テストクラスの新しいインスタンスを作るようにしました。
この、メソッド単位（per-method）のインスタンスライフサイクル管理は、JUnit Jupiter の基本的な振る舞いであり、過去の全ての JUnit と同じものです。

// NOTE: Please note that the test class will still be instantiated if a given _test method_
// is _disabled_ via a <<writing-tests-conditional-execution,condition>> (e.g., `@Disabled`,
// `@DisabledOnOs`, etc.) even when the "per-method" test instance lifecycle mode is active.
NOTE: メソッド単位（per-method）のインスタンスライフサイクル管理が有効になっているなら、テストメソッドが _無効_ になっても、テストクラスのインスタンスは作成するので注意してください（<<writing-tests-conditional-execution>> や `@Disabled` アノテーションなど）。

// If you would prefer that JUnit Jupiter execute all test methods on the same test
// instance, annotate your test class with `@TestInstance(Lifecycle.PER_CLASS)`. When using
// this mode, a new test instance will be created once per test class. Thus, if your test
// methods rely on state stored in instance variables, you may need to reset that state in
// `@BeforeEach` or `@AfterEach` methods.
JUnit Jupiter に同じインスタンスで全てのテストメソッドを実行させたいときは、テストクラスを `@TestInstance(Lifecycle.PER_CLASS)` で修飾しましょう。
そうすると、テストクラスのインスタンスを1度しか作らなくなります。
テストメソッドがインスタンス変数に記録した状態へ依存しているなら、`@BeforeEach` や `@AfterEach` のメソッドで状態を初期化しなければなりません。

// The "per-class" mode has some additional benefits over the default "per-method" mode.
// Specifically, with the "per-class" mode it becomes possible to declare `@BeforeAll` and
// `@AfterAll` on non-static methods as well as on interface `default` methods. The
// "per-class" mode therefore also makes it possible to use `@BeforeAll` and `@AfterAll`
// methods in `@Nested` test classes.
クラス単位（per-class）のインスタンスライフサイクル管理にはメソッド単位（per-method）にない利点があります。
それは、`@BeforeAll` や `@AfterAll` のメソッドに `static` 宣言が不要になることです（同様に、インターフェイスの `default` メソッドも不要になります）。
クラス単位（per-class）のインスタンスライフサイクル管理では、ネストテストクラスで `@BeforeAll` と `@AfterAll` を使うこともできます。

// If you are authoring tests using the Kotlin programming language, you may also find it
// easier to implement `@BeforeAll` and `@AfterAll` methods by switching to the "per-class"
// test instance lifecycle mode.
Kotlin でテストを書いているときも、クラス単位（per-class）のインスタンスライフサイクル管理 にしたほうが、`@BeforeAll` や `@AfterAll` をメソッドで実装できるので便利でしょう。

[[writing-tests-test-instance-lifecycle-changing-default]]
==== インスタンスライフサイクル管理の初期値を変更する

// If a test class or test interface is not annotated with `@TestInstance`, JUnit Jupiter
// will use a _default_ lifecycle mode. The standard _default_ mode is `PER_METHOD`;
// however, it is possible to change the _default_ for the execution of an entire test plan.
// To change the default test instance lifecycle mode, set the
// `junit.jupiter.testinstance.lifecycle.default` _configuration parameter_ to the name of
// an enum constant defined in `TestInstance.Lifecycle`, ignoring case. This can be supplied
// as a JVM system property, as a _configuration parameter_ in the
// `LauncherDiscoveryRequest` that is passed to the `Launcher`, or via the JUnit Platform
// configuration file (see <<running-tests-config-params>> for details).
テストクラスやテストインターフェイスを `@TestInstance` で修飾していないとき、JUnit Jupiter は _既定_ のインスタンスライフサイクル管理をします。
本来の _初期値_ は `PER_METHOD` ですが、テスト実行計画全体で変更できます。
インスタンスライフサイクル管理の初期値を変更するには、`junit.jupiter.testinstance.lifecycle.default` という _設定パラメータ_ に、`TestInstance.Lifecycle` の列挙値を設定します（大文字小文字の違いは無視します）。
JVM のシステムプロパティや、`Launcher` に渡す `LauncherDiscoveryRequest` の _設定パラメータ_ 、JUnit Platform の設定ファイル（<<running-tests-config-params>> を参照）で指定することもできます。

// For example, to set the default test instance lifecycle mode to `Lifecycle.PER_CLASS`,
// you can start your JVM with the following system property.
システムプロパティでインスタンスライフサイクル管理の初期値に `Lifecycle.PER_CLASS` を設定するには次のように指定します。

`-Djunit.jupiter.testinstance.lifecycle.default=per_class`

// Note, however, that setting the default test instance lifecycle mode via the JUnit
// Platform configuration file is a more robust solution since the configuration file can be
// checked into a version control system along with your project and can therefore be used
// within IDEs and your build software.
いろいろ指定する方法あありますが、JUnit Platform の設定ファイルで指定するのが最も確実な方法です。
JUnit Platform の設定ファイルはソースコードリポジトリに格納してバージョン管理して、IDE やビルドツールから利用できるようにするといいでしょう。、

// To set the default test instance lifecycle mode to `Lifecycle.PER_CLASS` via the JUnit
// Platform configuration file, create a file named `junit-platform.properties` in the root
// of the class path (e.g., `src/test/resources`) with the following content.
JUnit Platform の設定ファイルでインスタンスライフサイクル管理の初期値に `Lifecycle.PER_CLASS` を設定するには次のように記述します（例えば `rsc/test/resources/junit-platform.properties`）。

[source,properties,indent=0]
----
junit.jupiter.testinstance.lifecycle.default = per_class
----

// WARNING: Changing the _default_ test instance lifecycle mode can lead to unpredictable
// results and fragile builds if not applied consistently. For example, if the build
// configures "per-class" semantics as the default but tests in the IDE are executed using
// "per-method" semantics, that can make it difficult to debug errors that occur on the
// build server. It is therefore recommended to change the default in the JUnit Platform
// configuration file instead of via a JVM system property.
WARNING: インスタンスライフサイクル管理の初期値を不適切な値に変更すると、テストの結果が予測不能になったり、不安定になったりします。
例えば、ビルドツールの初期値をクラス単位（per-class）にしたのに、IDE ではメソッド単位（per-method）でテストを実行していると、ビルドジョブで解析の難しいエラーが発生します。
それゆえに、システムプロパティではなく JUnit Platform の設定ファイルで初期値を変更することをお勧めします。

[[writing-tests-nested]]
=== ネストテストクラス

// `@Nested` tests give the test writer more capabilities to express the relationship among
// several groups of tests. Such nested tests make use of Java's nested classes and
// facilitate hierarchical thinking about the test structure. Here's an elaborate example,
// both as source code and as a screenshot of the execution within an IDE.
`@Nested` アノテーションを使うと、いろいろなグループのテストの関係性をより分かりやすく表現できるようになります。
Java の内部クラスでテストの階層構造を考えられるようになるからです。
次のコード例をIDEで実行した結果は次のとおりです。

// [source,java,indent=0]
// .Nested test suite for testing a stack
[source,java,indent=0]
.内部クラスで構成したスタック型データ構造のテストスイート
----
include::{testDir}/example/TestingAStackDemo.java[tags=user_guide]
----

// When executing this example in an IDE, the test execution tree in the GUI will look
// similar to the following image.
このテストを IDE で実行すると、実行結果は同じような木構造になります。

image::writing-tests_nested_test_ide.png[caption='',title='Executing a nested test in an IDE']

// In this example, preconditions from outer tests are used in inner tests by defining
// hierarchical lifecycle methods for the setup code. For example, `createNewStack()` is a
// `@BeforeEach` lifecycle method that is used in the test class in which it is defined and
// in all levels in the nesting tree below the class in which it is defined.
この場合、内側のテストで階層的なライフサイクルメソッドを定義することで、外側のテストの事前条件を内側のテストで使用しているのが分かります。
`createNewStack()` は `@BeforeEach` で修飾されたライフサイクルメソッドで、メソッドを定義したクラスと、その内側のクラスのテストメソッドを実行するときに使用します。

// The fact that setup code from outer tests is run before inner tests are executed gives you
// the ability to run all tests independently. You can even run inner tests alone without
// running the outer tests, because the setup code from the outer tests is always executed.
外側のテストのセットアップは内側のテストより先に実行するため、結果として全てのテストを独立して実行できることになります。
内側のテストを実行するときは常に外側のテストのセットアップを実行するので、内側のテストだけを実行できるのです。

// NOTE: _Only non-static nested classes_ (i.e. _inner classes_) can serve as `@Nested` test
// classes. Nesting can be arbitrarily deep, and those inner classes are subject to full
// lifecycle support with one exception: `@BeforeAll` and `@AfterAll` methods do not work
// _by default_. The reason is that Java does not allow `static` members in inner classes.
// However, this restriction can be circumvented by annotating a `@Nested` test class with
// `@TestInstance(Lifecycle.PER_CLASS)` (see <<writing-tests-test-instance-lifecycle>>).
NOTE: `@Nested` で修飾できるのは _static でない内部クラス（インナークラス）_ だけです。
どれだけネストが深くなったとしても内部クラスか1つの例外を除いて完全なライフサイクルに対応しています。
例外とは、`@BeforeAll` と `@AfterAll` が _初期設定_ では動作しないことです。
Java の内部クラスは `static` メンバを定義できないからです。
ただし、ネストテストクラスを `@TestInstance(Lifecycle.PER_CLASS)` で修飾すればその例外を回避できます（<<writing-tests-test-instance-lifecycle>> を参照）。

[[writing-tests-dependency-injection]]
=== コンストラクタやメソッドによる依存性の注入

// In all prior JUnit versions, test constructors or methods were not allowed to have
// parameters (at least not with the standard `Runner` implementations). As one of the major
// changes in JUnit Jupiter, both test constructors and methods are now permitted to have
// parameters. This allows for greater flexibility and enables _Dependency Injection_ for
// constructors and methods.
過去の JUnit ではテストクラスのコンストラクタやテストメソッドに引数を定義できませんでした（少なくとも標準の `Runner` ではそうでした）。
JUnit Jupiter における重要な変更点の1つは、テストクラスのコンストラクタやテストメソッドに引数を定義できるようになったことです。
優れた柔軟性をもたらすだけでなく、_依存性の注入_ ができるようになったのです。

// `{ParameterResolver}` defines the API for test extensions that wish to _dynamically_
// resolve parameters at runtime. If a _test class_ constructor, a _test method_, or a
// _lifecycle method_ (see <<writing-tests-classes-and-methods>>) accepts a parameter, the
// parameter must be resolved at runtime by a registered `ParameterResolver`.
`{ParameterResolver}` は JUnit の拡張機能が実行時に _動的に_ パラメータを解決するための API を定義しています。
`ParameterResolver` を登録しておくと、実行時に _テストクラス_ のコンストラクタや _テストメソッド_ あるいは _ライフサイクルメソッド_ の引数を解決してくれるのです（<<writing-tests-classes-and-methods>> を参照）。

// There are currently three built-in resolvers that are registered automatically.
現在は次の3種類の組み込みリゾルバーが自動的に登録されるようになっています。

// * `{TestInfoParameterResolver}`: if a constructor or method parameter is of type
//   `{TestInfo}`, the `TestInfoParameterResolver` will supply an instance of `TestInfo`
//   corresponding to the current container or test as the value for the parameter. The
//   `TestInfo` can then be used to retrieve information about the current container or test
//   such as the display name, the test class, the test method, and associated tags. The
//   display name is either a technical name, such as the name of the test class or test
//   method, or a custom name configured via `@DisplayName`.
// +
// `{TestInfo}` acts as a drop-in replacement for the `TestName` rule from JUnit 4. The
// following demonstrates how to have `TestInfo` injected into a test constructor,
// `@BeforeEach` method, and `@Test` method.
* `{TestInfoParameterResolver}`: コンストラクタやメソッドに `{TestInfo}` 型の引数があれば、`TestInfoParameterResolver` が今のテストコンテナあるいはテストの情報を持つ `TestInfo` のインスタンスを設定します。
  設定された `TestInfo` から、今のテストコンテナやテストの情報（例えば表示名、テストクラス名、テストメソッド名、割り当てられたタグなど）を取得できます。
  表示名はクラス名やメソッド名、あるいは、`@DisplayName` で指定された名前になります。
+
`{TestInfo}` は JUnit 4 の `TestName` ルールを置き換える部品として使用できます。
次のコード例ではテストクラスのコンストラクタと `@BeforeEach` メソッド、テストメソッドに `TestInfo` を注入しています。

[source,java,indent=0]
----
include::{testDir}/example/TestInfoDemo.java[tags=user_guide]
----

// * `{RepetitionInfoParameterResolver}`: if a method parameter in a `@RepeatedTest`,
//   `@BeforeEach`, or `@AfterEach` method is of type `{RepetitionInfo}`, the
//   `RepetitionInfoParameterResolver` will supply an instance of `RepetitionInfo`.
//   `RepetitionInfo` can then be used to retrieve information about the current repetition
//   and the total number of repetitions for the corresponding `@RepeatedTest`. Note,
//   however, that `RepetitionInfoParameterResolver` is not registered outside the context
//   of a `@RepeatedTest`. See <<writing-tests-repeated-tests-examples>>.

// * `{TestReporterParameterResolver}`: if a constructor or method parameter is of type
//   `{TestReporter}`, the `TestReporterParameterResolver` will supply an instance of
//   `TestReporter`. The `TestReporter` can be used to publish additional data about the
//   current test run. The data can be consumed via the `reportingEntryPublished()` method in
//   a `{TestExecutionListener}`, allowing it to be viewed in IDEs or included in reports.
// +
// In JUnit Jupiter you should use `TestReporter` where you used to print information to
// `stdout` or `stderr` in JUnit 4. Using `@RunWith(JUnitPlatform.class)` will output all
// reported entries to `stdout`. In addition, some IDEs print report entries to `stdout` or
// display them in the user interface for test results.
* `{RepetitionInfoParameterResolver}`: `@RepeatedTest, @BeforeEach, @AfterEach` で修飾したメソッドに `{RepetitionInfo}` 型の引数があれば、`RepetitionInfoParameterResolver` が `RepetitionInfo` のインスタンスを設定します。
  設定された `RepetitionInfo` から、今の繰り返し情報と `@RepeatedTest` に指定された繰り返し数の合計値を取得できます。
  `@RepeatedTest` の外側のコンテキストでは `RepetitionInfoParameterResolver` を登録しないので注意してください。<<writing-tests-repeated-tests-examples>> も参照してください。

* `{TestReporterParameterResolver}`: コンストラクタやメソッドに `{TestReporter}` 型の引数があれば, `TestReporterParameterResolver` が `TestReporter` のインスタンスを設定します。
  設定された `TestReporter` で、実行しているテストに関するデータを公開できます。
  公開したデータは `{TestExecutionListener}` の `reportingEntryPublished()` メソッドで取得できるので、IDE に表示したりレポートに出力したりできます。
+
JUnit 4 で標準出力と標準エラー出力へテストの結果を出力していた場合、JUnit Jupiter では `TestReporter` を使わなければいけません。
テストクラスを `@RunWith(JUnitPlatform.class)` で修飾すると、全ての出力を標準出力へ書き込むようになります。
また、IDE によっては、テストの結果を標準出力と UI の両方に出力します。

[source,java,indent=0]
----
include::{testDir}/example/TestReporterDemo.java[tags=user_guide]
----

// NOTE: Other parameter resolvers must be explicitly enabled by registering appropriate
// <<extensions,extensions>> via `@ExtendWith`.
NOTE: 他のパラメータリゾルバーを使いたければ適切な拡張機能を `@ExtendWith` で登録しなければなりません。

// Check out the `{RandomParametersExtension}` for an example of a custom
// `{ParameterResolver}`. While not intended to be production-ready, it demonstrates the
// simplicity and expressiveness of both the extension model and the parameter resolution
// process. `MyRandomParametersTest` demonstrates how to inject random values into `@Test`
// methods.
`{ParameterResolver}` の実装例として `{RandomParametersExtension}` を見てみましょう。
拡張モデルとパラメータ解決処理を説明するため、短く、分かりやすくしています。
また、`MyRandomParametersTest` でその使い方を説明します。

[source,java,indent=0]
----
@ExtendWith(RandomParametersExtension.class)
class MyRandomParametersTest {

    @Test
    void injectsInteger(@Random int i, @Random int j) {
        assertNotEquals(i, j);
    }

    @Test
    void injectsDouble(@Random double d) {
        assertEquals(0.0, d, 1.0);
    }

}
----

// For real-world use cases, check out the source code for the `{MockitoExtension}` and the
// `{SpringExtension}`.
現実的な例は `{MockitoExtension}` や `{SpringExtension}` のソースコードを参照してください。

// When the type of the parameter to inject is the only condition for your
// `{ParameterResolver}`, you can use the generic `{TypeBasedParameterResolver}` base class.
// The `supportsParameters` method is implemented behind the scenes and supports
// parameterized types.
作成した `{ParameterResolver}` が引数の型だけで値を注入するかどうかを判断するなら、総称型の `{TypeBasedParameterResolver}` を基底クラスにするといいでしょう。
`supportsParameters` メソッドが対応する引数の型の情報を隠蔽します。

[[writing-tests-test-interfaces-and-default-methods]]
=== テストインターフェイスとデフォルトメソッド

// JUnit Jupiter allows `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`,
// `@TestTemplate`, `@BeforeEach`, and `@AfterEach` to be declared on interface `default`
// methods. `@BeforeAll` and `@AfterAll` can either be declared on `static` methods in a
// test interface or on interface `default` methods _if_ the test interface or test class is
// annotated with `@TestInstance(Lifecycle.PER_CLASS)` (see
// <<writing-tests-test-instance-lifecycle>>). Here are some examples.
JUnit Jupiter ではインターフェイスのデフォルトメソッドを `@Test, @RepeatedTest, @ParameterizedTest, @TestFactory, @TestTemplate, @BeforeEach, @AfterEach` で修飾できるようになりました。
インターフェイスやクラスを `@TestInstance(Lifecycle.PER_CLASS)` （<<writing-tests-test-instance-lifecycle>> を参照）で修飾しているなら、`static` メソッドやインターフェイスのデフォルトメソッドを `@BeforeAll, @AfterAll` で修飾できます。

[source,java]
----
include::{testDir}/example/testinterface/TestLifecycleLogger.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDynamicTestsDemo.java[tags=user_guide]
----

// `@ExtendWith` and `@Tag` can be declared on a test interface so that classes that
// implement the interface automatically inherit its tags and extensions. See
// <<extensions-lifecycle-callbacks-before-after-execution>> for the source code of the
// <<extensions-lifecycle-callbacks-timing-extension, TimingExtension>>.
テストインターフェイスの実装クラスは、テストインターフェイスを修飾した `@ExtendWith, @Tag` を自動的に継承します。
<<extensions-lifecycle-callbacks-before-after-execution>> の実装例を、<<extensions-lifecycle-callbacks-timing-extension, TimingExtension>> のソースコードで確認しましょう。

[source,java]
----
include::{testDir}/example/testinterface/TimeExecutionLogger.java[tags=user_guide]
----

// In your test class you can then implement these test interfaces to have them applied.
これらのインターフェイスをテストクラスで実装すると次のようになります。

[source,java]
----
include::{testDir}/example/testinterface/TestInterfaceDemo.java[tags=user_guide]
----

// Running the `TestInterfaceDemo` results in output similar to the following:
`TestInterfaceDemo` を実行すると次のような出力が得られるでしょう。

....
INFO  example.TestLifecycleLogger - Before all tests
INFO  example.TestLifecycleLogger - About to execute [dynamicTestsForPalindromes()]
INFO  example.TimingExtension - Method [dynamicTestsForPalindromes] took 19 ms.
INFO  example.TestLifecycleLogger - Finished executing [dynamicTestsForPalindromes()]
INFO  example.TestLifecycleLogger - About to execute [isEqualValue()]
INFO  example.TimingExtension - Method [isEqualValue] took 1 ms.
INFO  example.TestLifecycleLogger - Finished executing [isEqualValue()]
INFO  example.TestLifecycleLogger - After all tests
....

// Another possible application of this feature is to write tests for interface contracts.
// For example, you can write tests for how implementations of `Object.equals` or
// `Comparable.compareTo` should behave as follows.
この機能を応用して、インターフェイスを契約とするテストを作成できます。
例えば、`Object.equals` や `Comparable.compareTo` の実装に関するテストは次のように記述できるでしょう。

[source,java]
----
include::{testDir}/example/defaultmethods/Testable.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/EqualsContract.java[tags=user_guide]
----

[source,java]
----
include::{testDir}/example/defaultmethods/ComparableContract.java[tags=user_guide]
----

// In your test class you can then implement both contract interfaces thereby inheriting the
// corresponding tests. Of course you'll have to implement the abstract methods.
それぞれのインターフェイスをテストクラスで実装すると、それぞれのテストを継承することになります。
もちろん、インターフェイスメソッドは実装しなければなりません。

[source,java]
----
include::{testDir}/example/defaultmethods/StringTests.java[tags=user_guide]
----

// NOTE: The above tests are merely meant as examples and therefore not complete.
NOTE: これらのコード例は説明用で、完全なものではありません。

[[writing-tests-repeated-tests]]
=== 繰り返しテスト

// JUnit Jupiter provides the ability to repeat a test a specified number of times by
// annotating a method with `@RepeatedTest` and specifying the total number of repetitions
// desired. Each invocation of a repeated test behaves like the execution of a regular
// `@Test` method with full support for the same lifecycle callbacks and extensions.
JUnit Jupiter では `@RepeatedTest` でテストを繰り返し実行する回数、あるいは、繰り返し回数の最大値を指定してテストを実行できるようになりました。
繰り返しごとに実行するテストメソッドは、`@Test` で修飾した通常のテストメソッドと完全に同じライフサイクルと拡張機能に対応しています。

// The following example demonstrates how to declare a test named `repeatedTest()` that
// will be automatically repeated 10 times.
次のコード例では、`repeatedTest()` を10回繰り返すようになっています。

[source,java]
----
@RepeatedTest(10)
void repeatedTest() {
    // ...
}
----

// In addition to specifying the number of repetitions, a custom display name can be
// configured for each repetition via the `name` attribute of the `@RepeatedTest`
// annotation. Furthermore, the display name can be a pattern composed of a combination of
// static text and dynamic placeholders. The following placeholders are currently supported.
繰り返し実行する回数を指定するだけでなく、`name` 属性で表示名を変更できるようになっています。
表示名は、文字列リテラルとプレースホルダを組み合わせたパターン文字列です。
現在対応しているプレースホルダは次のとおりです。

// - `{displayName}`: display name of the `@RepeatedTest` method
// - `{currentRepetition}`: the current repetition count
// - `{totalRepetitions}`: the total number of repetitions

- `{displayName}`: `@RepeatedTest` で修飾したメソッド名
- `{currentRepetition}`: 現在の繰り返し回数
- `{totalRepetitions}`: 繰り返し回数の最大値

// The default display name for a given repetition is generated based on the following
// pattern: `"repetition {currentRepetition} of {totalRepetitions}"`. Thus, the display
// names for individual repetitions of the previous `repeatedTest()` example would be:
// `repetition 1 of 10`, `repetition 2 of 10`, etc. If you would like the display name of
// the `@RepeatedTest` method included in the name of each repetition, you can define your
// own custom pattern or use the predefined `RepeatedTest.LONG_DISPLAY_NAME` pattern. The
// latter is equal to `"{displayName} {two-colons} repetition {currentRepetition} of
// {totalRepetitions}"` which results in display names for individual repetitions like
// `repeatedTest() {two-colons} repetition 1 of 10`, `repeatedTest() {two-colons} repetition 2 of 10`, etc.
表示名の初期値は `"repetition {currentRepetition} of {totalRepetitions}"` です。
従って、前のコード例では繰り返しごとの表示名は `repetition 1 of 10`、 `repetition 2 of 10` のようになります。
それぞれの表示名にテストメソッド名を含めたい場合は、独自のパターン文字列を指定するか、定義済みの `RepeatedTest.LONG_DISPLAY_NAME` を指定するといいでしょう。
`RepeatedTest.LONG_DISPLAY_NAME` は `"{displayName} {two-colons} repetition {currentRepetition} of {totalRepetitions}"` と同じ内容で、`repeatedTest() {two-colons} repetition 1 of 10`、 `repeatedTest() {two-colons} repetition 2 of 10` のように出力されます。

// In order to retrieve information about the current repetition and the total number of
// repetitions programmatically, a developer can choose to have an instance of
// `RepetitionInfo` injected into a `@RepeatedTest`, `@BeforeEach`, or `@AfterEach` method.
`@RepeatedTest, @BeforeEach, @AfterEach` で修飾したメソッドの内部から、現在の繰り返し回数や、繰り返し回数の最大値を取得したい場合、メソッド引数に `RepetitionInfo` 型の引数を宣言し、インスタンスを注入させることができます。

[[writing-tests-repeated-tests-examples]]
==== 繰り返しテストの具体例

// The `RepeatedTestsDemo` class at the end of this section demonstrates several examples of
// repeated tests.
繰り返しテストのさまざまな使い方を `RepeatedTestsDemo` クラスで説明していきます。

// The `repeatedTest()` method is identical to example from the previous section; whereas,
// `repeatedTestWithRepetitionInfo()` demonstrates how to have an instance of
// `RepetitionInfo` injected into a test to access the total number of repetitions for the
// current repeated test.
`repeatedTest()` メソッドの使い方は前のセクションで説明したのと同じです。
`repeatedTestWithRepetitionInfo()` メソッドは `RepetitionInfo` でメソッドの中から繰り返し回数などの情報を取得しています。

// The next two methods demonstrate how to include a custom `@DisplayName` for the
// `@RepeatedTest` method in the display name of each repetition. `customDisplayName()`
// combines a custom display name with a custom pattern and then uses `TestInfo` to verify
// the format of the generated display name. `Repeat!` is the `{displayName}` which comes
// from the `@DisplayName` declaration, and `1/1` comes from
// `{currentRepetition}/{totalRepetitions}`. In contrast,
// `customDisplayNameWithLongPattern()` uses the aforementioned predefined
// `RepeatedTest.LONG_DISPLAY_NAME` pattern.
`customDisplayName()` メソッドは `@DisplayName` と `@RepeatedTest` で変更した表示名を `TestInfo` から取得して、生成された名前の形式が合っているか検証しています。
`Repeat!` はプレースホルダの `{displayName}` を `@DisplayName` の値で置換したものです。
`1/1` はプレースホルダの `{currentRepetition}/{totalRepetitions}` を置換したものです。
逆に `customDisplayNameWithLongPattern()` メソッドでは表示名のパターンとして `RepeatedTest.LONG_DISPLAY_NAME` を使っています。

// `repeatedTestInGerman()` demonstrates the ability to translate display names of repeated
// tests into foreign languages -- in this case German, resulting in names for individual
// repetitions such as: `Wiederholung 1 von 5`, `Wiederholung 2 von 5`, etc.
`repeatedTestInGerman()` メソッドは繰り返しテストで表示名をローカライズする方法を示しています。
ここではドイツ語へ翻訳しているので、`Wiederholung 1 von 5`, `Wiederholung 2 von 5` のようになります。

// Since the `beforeEach()` method is annotated with `@BeforeEach` it will get executed
// before each repetition of each repeated test. By having the `TestInfo` and
// `RepetitionInfo` injected into the method, we see that it's possible to obtain
// information about the currently executing repeated test. Executing `RepeatedTestsDemo`
// with the `INFO` log level enabled results in the following output.
`@BeforeEach` で修飾した `beforeEach()` メソッドは、それぞれの繰り返しテストを実行する前に実行します。
メソッド引数に注入した `TestInfo` と `RepetitionInfo` から、実行しているテストメソッドの情報を取得できます。
ログレベルを `INFO` に設定してテストクラス `RepeatedTestsDemo` を実行すると、次のような出力が得られるでしょう。

....
INFO: About to execute repetition 1 of 10 for repeatedTest
INFO: About to execute repetition 2 of 10 for repeatedTest
INFO: About to execute repetition 3 of 10 for repeatedTest
INFO: About to execute repetition 4 of 10 for repeatedTest
INFO: About to execute repetition 5 of 10 for repeatedTest
INFO: About to execute repetition 6 of 10 for repeatedTest
INFO: About to execute repetition 7 of 10 for repeatedTest
INFO: About to execute repetition 8 of 10 for repeatedTest
INFO: About to execute repetition 9 of 10 for repeatedTest
INFO: About to execute repetition 10 of 10 for repeatedTest
INFO: About to execute repetition 1 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 2 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 3 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 4 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 5 of 5 for repeatedTestWithRepetitionInfo
INFO: About to execute repetition 1 of 1 for customDisplayName
INFO: About to execute repetition 1 of 1 for customDisplayNameWithLongPattern
INFO: About to execute repetition 1 of 5 for repeatedTestInGerman
INFO: About to execute repetition 2 of 5 for repeatedTestInGerman
INFO: About to execute repetition 3 of 5 for repeatedTestInGerman
INFO: About to execute repetition 4 of 5 for repeatedTestInGerman
INFO: About to execute repetition 5 of 5 for repeatedTestInGerman
....

[source,java]
----
include::{testDir}/example/RepeatedTestsDemo.java[tags=user_guide]
----

// When using the `ConsoleLauncher` with the unicode theme enabled, execution of
// `RepeatedTestsDemo` results in the following output to the console.
ユニコードテーマを有効にした `ConsoleLauncher` を使うと次のような出力が得られるでしょう。

....
├─ RepeatedTestsDemo ✔
│  ├─ repeatedTest() ✔
│  │  ├─ repetition 1 of 10 ✔
│  │  ├─ repetition 2 of 10 ✔
│  │  ├─ repetition 3 of 10 ✔
│  │  ├─ repetition 4 of 10 ✔
│  │  ├─ repetition 5 of 10 ✔
│  │  ├─ repetition 6 of 10 ✔
│  │  ├─ repetition 7 of 10 ✔
│  │  ├─ repetition 8 of 10 ✔
│  │  ├─ repetition 9 of 10 ✔
│  │  └─ repetition 10 of 10 ✔
│  ├─ repeatedTestWithRepetitionInfo(RepetitionInfo) ✔
│  │  ├─ repetition 1 of 5 ✔
│  │  ├─ repetition 2 of 5 ✔
│  │  ├─ repetition 3 of 5 ✔
│  │  ├─ repetition 4 of 5 ✔
│  │  └─ repetition 5 of 5 ✔
│  ├─ Repeat! ✔
│  │  └─ Repeat! 1/1 ✔
│  ├─ Details... ✔
│  │  └─ Details... {two-colons} repetition 1 of 1 ✔
│  └─ repeatedTestInGerman() ✔
│     ├─ Wiederholung 1 von 5 ✔
│     ├─ Wiederholung 2 von 5 ✔
│     ├─ Wiederholung 3 von 5 ✔
│     ├─ Wiederholung 4 von 5 ✔
│     └─ Wiederholung 5 von 5 ✔
....


[[writing-tests-parameterized-tests]]
=== パラメタライズテスト

// Parameterized tests make it possible to run a test multiple times with different
// arguments. They are declared just like regular `@Test` methods but use the
// `{ParameterizedTest}` annotation instead. In addition, you must declare at least one
// _source_ that will provide the arguments for each invocation and then _consume_ the
// arguments in the test method.
パラメタライズテストは複数の異なる引数でテストメソッドを実行する機能です。
テストメソッドを `@Test` ではなく `{ParameterizedTest}` で修飾します。
メソッドの引数を提供する _ソース_ を少なくとも1つは宣言しなければなりません。
テストメソッドは _ソース_ の提供するそれぞれの値を引数として _消費_ します。

// The following example demonstrates a parameterized test that uses the `@ValueSource`
// annotation to specify a `String` array as the source of arguments.
次のコード例では `@ValueSource` で `String` の配列を与えています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=first_example]
----

// When executing the above parameterized test method, each invocation will be reported
// separately. For instance, the `ConsoleLauncher` will print output similar to the
// following.
パラメタライズテストを実行すると、それぞれのテストメソッドの呼び出しを別々に報告します。
例えば、`ConsoleLauncher` は次のように出力するでしょう。

....
palindromes(String) ✔
├─ [1] candidate=racecar ✔
├─ [2] candidate=radar ✔
└─ [3] candidate=able was I ere I saw elba ✔
....

[[writing-tests-parameterized-tests-setup]]
==== 必要な準備

// In order to use parameterized tests you need to add a dependency on the
// `junit-jupiter-params` artifact. Please refer to <<dependency-metadata>> for details.
パラメタライズテストを実行するには、依存ライブラリに `junit-jupiter-params` を追加しなければなりません。
詳しくは <<dependency-metadata>> を参照してください。

[[writing-tests-parameterized-tests-consuming-arguments]]
==== 引数を消費するということについて

// Parameterized test methods typically _consume_ arguments directly from the configured
// source (see <<writing-tests-parameterized-tests-sources>>) following a one-to-one
// correlation between argument source index and method parameter index (see examples in
// <<writing-tests-parameterized-tests-sources-CsvSource>>). However, a parameterized test
// method may also choose to _aggregate_ arguments from the source into a single object
// passed to the method (see <<writing-tests-parameterized-tests-argument-aggregation>>).
// Additional arguments may also be provided by a `ParameterResolver` (e.g., to obtain an
// instance of `TestInfo`, `TestReporter`, etc.). Specifically, a parameterized test method
// must declare formal parameters according to the following rules.
パラメタライズテストでは基本的に指定した _ソース_ から直接値を _消費_ します。
このとき、_ソース_ から取得した値の（配列の）添え字と、メソッド引数の順序の対応関係は1対1になります（<<writing-tests-parameterized-tests-sources-CsvSource>> を参照）。
しかし、_ソース_ から取得した値を _集約_ して、メソッド引数の1つに渡すこともできます（<<writing-tests-parameterized-tests-argument-aggregation>> を参照）。
また、メソッド引数には `ParameterResolver` が注入する引数（例えば `TestInfo` や `TestReporter` など）を宣言できます。
パラメタライズテストにおけるメソッド引数の宣言規則は次のとおりです。

// * Zero or more _indexed arguments_ must be declared first.
// * Zero or more _aggregators_ must be declared next.
// * Zero or more arguments supplied by a `ParameterResolver` must be declared last.
* 0 個以上の _添え字に対応する引数_ は先頭で宣言しなければなりません。
* 0 個以上の _集約する引数_ はその次に宣言しなければなりません。
* 0 個以上の `ParameterResolver` が注入する引数は最後に宣言しなければなりません。

// In this context, an _indexed argument_ is an argument for a given index in the
// `Arguments` provided by an `ArgumentsProvider` that is passed as an argument to the
// parameterized method at the same index in the method's formal parameter list. An
// _aggregator_ is any parameter of type `ArgumentsAccessor` or any parameter annotated with
// `@AggregateWith`.
「添え字に対応する引数」とは、`ArgumentsProvider` の提供する `Arguments` に対する添え字のことで、添え字に対応する引数へ値を渡します。
「集約する引数」とは、`ArgumentAccessor` 型の引数か、`@AggregateWith` で修飾した引数のことです。

// [NOTE]
// .AutoCloseable arguments
[NOTE]
.AutoCloseable 型の引数について
====
// Arguments that implement `java.lang.AutoCloseable` (or `java.io.Closeable` which extends
// `java.lang.AutoCloseable`) will be automatically closed after `@AfterEach` methods and
// `AfterEachCallback` extensions have been called for the current parameterized test
// invocation.
`java.lang.AutoCloseable` やその派生インターフェイスの `java.io.Closeable` を実装した型の引数は、`@AfterEach` メソッドを実行した後、自動的に閉じます。
また、テストメソッドから `AfterEachCallback` 拡張を呼び出した場合は、テストメソッドを実行した後、自動的に閉じます。

// To prevent this from happening, set the `autoCloseArguments` attribute in
// `@ParameterizedTest` to `false`. Specifically, if an argument that implements
// `AutoCloseable` is reused for multiple invocations of the same parameterized test method,
// you must annotate the method with `@ParameterizedTest(autoCloseArguments = false)` to
// ensure that the argument is not closed between invocations.
この振る舞いを無効化するには `@ParameterizedTest` の `autoCloseArguments` 属性に `false` を設定します。
特に、`AutoCloseable` を実装した引数を同じパラメタライズテストメソッドで何回も再利用するなら、毎回閉じられないように設定しておきましょう。
====

[[writing-tests-parameterized-tests-sources]]
==== 引数の源

// Out of the box, JUnit Jupiter provides quite a few _source_ annotations. Each of the
// following subsections provides a brief overview and an example for each of them. Please
// refer to the Javadoc in the `{params-provider-package}` package for additional
// information.
JUnit Jupiter はいくつか _ソース_ のアノテーションを同梱しています。
このセクションではそれぞれのアノテーションについて簡単な使い方を説明してきます。
詳細は `{params-provider-package}` パッケージの Javadoc を参照してください。

[[writing-tests-parameterized-tests-sources-ValueSource]]
===== @ValueSource

// `@ValueSource` is one of the simplest possible sources. It lets you specify a single
// array of literal values and can only be used for providing a single argument per
// parameterized test invocation.
`@ValueSource` はソースアノテーションの中でも簡単なものの1つです。
配列やリテラル値を、1引数のテストメソッドに渡すことができます。

// The following types of literal values are supported by `@ValueSource`.
`@ValueSource` の対応しているリテラルのデータ型は次のとおりです。

- `short`
- `byte`
- `int`
- `long`
- `float`
- `double`
- `char`
- `boolean`
- `java.lang.String`
- `java.lang.Class`

// For example, the following `@ParameterizedTest` method will be invoked three times, with
// the values `1`, `2`, and `3` respectively.
例えば、次のコード例では `1, 2, 3` それぞれを引数として `@ParameterizedTest` で修飾したテストメソッドを実行します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ValueSource_example]
----

[[writing-tests-parameterized-tests-sources-null-and-empty]]
===== null および空値

// In order to check corner cases and verify proper behavior of our software when it is
// supplied _bad input_, it can be useful to have `null` and _empty_ values supplied to our
// parameterized tests. The following annotations serve as sources of `null` and empty values
// for parameterized tests that accept a single argument.
コーナーケースや _不正な入力_ を与えられたときの振る舞いを確かめるには、パラメタライズテストで `null` や _空値_ を渡せるようにすると便利です。
1引数のテストメソッドへ `null` や空値を渡すためのアノテーションには次のようなものがあります。

// * `{NullSource}`: provides a single `null` argument to the annotated `@ParameterizedTest`
//   method.
//    - `@NullSource` cannot be used for a parameter that has a primitive type.
// * `{EmptySource}`: provides a single _empty_ argument to the annotated `@ParameterizedTest`
//   method for parameters of the following types: `java.lang.String`, `java.util.List`,
//   `java.util.Set`, `java.util.Map`, primitive arrays (e.g., `int[]`, `char[][]`, etc.),
//   object arrays (e.g.,`String[]`, `Integer[][]`, etc.).
//    - Subtypes of the supported types are not supported.
// * `{NullAndEmptySource}`: a _composed annotation_ that combines the functionality of
//   `@NullSource` and `@EmptySource`.
* `{NullSource}`: `@ParameterizedTest` で修飾したメソッドの引数に `null` を渡します。
   - プリミティブ型の引数には使用できません
* `{EmptySource}`: `@ParameterizedTest` で修飾したメソッドの引数に _空値_ を渡します。対応している引数の型は参照型（`java.lang.String, java.util.List, java.util.Set, java.util.Map`）と配列型（`int[]`, `char[][]` など）です。
   - これらのデータ型から派生した型には未対応です。
* `{NullAndEmptySource}`: `@NullSource` と `@EmptySource` の _合成アノテーション_ で、両方の使い方ができます。

// If you need to supply multiple varying types of _blank_ strings to a parameterized test,
// you can achieve that using <<writing-tests-parameterized-tests-sources-ValueSource>> --
// for example, `@ValueSource(strings = {"{nbsp}", "{nbsp}{nbsp}{nbsp}", "\t", "\n"})`.
パラメタライズテストへ _空白_ に相当するさまざま文字列を渡したいときは、<<writing-tests-parameterized-tests-sources-ValueSource>> を使うといいでしょう。
具体的には `@ValueSource(strings = {"{nbsp}", "{nbsp}{nbsp}{nbsp}", "\t", "\n"})` のように記述できます。

// You can also combine `@NullSource`, `@EmptySource`, and `@ValueSource` to test a wider
// range of `null`, _empty_, and _blank_ input. The following example demonstrates how to
// achieve this for strings.
次のコード例のように、`@NullSource` と `@EmptySource` に `@ValueSource` を組み合わせると、`null` や _空値_ や _空白_ を幅広く入力させることができます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=NullAndEmptySource_example1]
----

// Making use of the composed `@NullAndEmptySource` annotation simplifies the above as
// follows.
合成アノテーションの `@NullAndEmptySource` を使うと少し短くなります。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=NullAndEmptySource_example2]
----

// NOTE: Both variants of the `nullEmptyAndBlankStrings(String)` parameterized test method
// result in six invocations: 1 for `null`, 1 for the empty string, and 4 for the explicit
// blank strings supplied via `@ValueSource`.
NOTE: どちらの場合でも `nullEmptyAndBlankStrings(String)` メソッドは6回実行されます。
`null` で1回、空値で1回、`@ValueSource` の提供する空白文字で4回です。

[[writing-tests-parameterized-tests-sources-EnumSource]]
===== @EnumSource

// `@EnumSource` provides a convenient way to use `Enum` constants.
`@EnumSource` を使うと列挙型の定数が使いやすくなります。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example]
----

// The annotation's `value` attribute is optional. When omitted, the declared type of the
// first method parameter is used. The test will fail if it does not reference an enum type.
// Thus, the `value` attribute is required in the above example because the method parameter
// is declared as `TemporalUnit`, i.e. the interface implemented by `ChronoUnit`, which isn't
// an enum type. Changing the method parameter type to `ChronoUnit` allows you to omit the
// explicit enum type from the annotation as follows.
`value` 属性は任意です。
未指定なら先頭のメソッド引数の型を使用します。
先頭のメソッド引数の型が列挙型でなければテストは失敗します。
前のコード例では、先頭のメソッド引数の型 `TemporalUnit` は列挙型ではありません（`ChronoUnit` の実装するインターフェイスです）。
ですので、`@EnumSource` の `value` 属性に列挙型を指定しなければなりません。
引数の型を `ChronoUnit` へ変更すれば、`value` 属性の指定は不要になります。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example_autodetection]
----

// The annotation provides an optional `names` attribute that lets you specify which
// constants shall be used, like in the following example. If omitted, all constants will be
// used.
`names` 属性には使用する定数名を指定できます。
未指定なら全ての定数を使用します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_include_example]
----

// The `@EnumSource` annotation also provides an optional `mode` attribute that enables
// fine-grained control over which constants are passed to the test method. For example, you
// can exclude names from the enum constant pool or specify regular expressions as in the
// following examples.
`mode` 属性を指定するとテストメソッドに渡す定数を細かく制御できます。
次のコード例では指定した名前に一致する定数を除外したり、指定した正規表現がマッチする定数を選択したりします。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_exclude_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_regex_example]
----

[[writing-tests-parameterized-tests-sources-MethodSource]]
===== @MethodSource

// `{MethodSource}` allows you to refer to one or more _factory_ methods of the test class
// or external classes.
`{MethodSource}` では、テストクラスやそれ以外のクラスに定義した、1つ以上の _ファクトリ_ メソッドを指定できます。

// Factory methods within the test class must be `static` unless the test class is annotated
// with `@TestInstance(Lifecycle.PER_CLASS)`; whereas, factory methods in external classes
// must always be `static`. In addition, such factory methods must not accept any arguments.
テストクラスを `@TestInstance(Lifecycle.PER_CLASS)` で修飾している場合を除いて、テストクラス中のファクトリメソッドは `static` 宣言したものにしなければいけません。
一方、外部のクラスに定義したファクトリメソッドは必ず `static` 宣言したものにしなければいけません。
あと、ファクトリメソッドに指定するメソッドは引数を宣言できません。

// Each factory method must generate a _stream_ of _arguments_, and each set of arguments
// within the stream will be provided as the physical arguments for individual invocations
// of the annotated `@ParameterizedTest` method. Generally speaking this translates to a
// `Stream` of `Arguments` (i.e., `Stream<Arguments>`); however, the actual concrete return
// type can take on many forms. In this context, a "stream" is anything that JUnit can
// reliably convert into a `Stream`, such as `Stream`, `DoubleStream`, `LongStream`,
// `IntStream`, `Collection`, `Iterator`, `Iterable`, an array of objects, or an array of
// primitives. The "arguments" within the stream can be supplied as an instance of
// `Arguments`, an array of objects (e.g., `Object[]`), or a single value if the
// parameterized test method accepts a single argument.
ファクトリメソッドは _引数に渡す値_ の _ストリーム_ を生成しなければなりません。
ストリームのそれぞれの要素は `@ParameterizedTest` で修飾したメソッドを呼び出すたびに渡されます。
一般的には `Arguments` の `Stream` つまり `Stream<Arguments>` という形式で表現する場合が多いようです。
ただし、ファクトリメソッドの返り値型は他にもいろいろな型になります。
JUnit は安全に `Stream` へ変換できる型を「ストリーム」と呼びます（それぞれのプリミティブ型に対応する `Stream` や、オブジェクト型の配列、プリミティブ型の配列、`Collection` や `Iterator` や `Iterable` など）。
そして、`Arguments` のインスタンスとして渡せるものならなんでも「ストリームの要素」になります（オブジェクト型の配列や、単一のリテラル値など）。

// If you only need a single parameter, you can return a `Stream` of instances of the
// parameter type as demonstrated in the following example.
テストメソッドの引数が1つだけなら、引数と同じ型の `Stream` を返すファクトリメソッドを使用できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_example]
----

// If you do not explicitly provide a factory method name via `@MethodSource`, JUnit Jupiter
// will search for a _factory_ method that has the same name as the current
// `@ParameterizedTest` method by convention. This is demonstrated in the following example.
`@MethodSource` で明示的にメソッド名を指定したくないときのために、JUnit Jupiter では `@ParameterizedTest` で修飾したメソッド名と同じ名前のメソッドを探索して、 _ファクトリメソッド_ として使うようになっています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=simple_MethodSource_without_value_example]
----

// Streams for primitive types (`DoubleStream`, `IntStream`, and `LongStream`) are also
// supported as demonstrated by the following example.
ファクトリメソッドの返り値型には、プリミティブ型に対応する `Stream` を使用できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=primitive_MethodSource_example]
----

// If a parameterized test method declares multiple parameters, you need to return a
// collection, stream, or array of `Arguments` instances or object arrays as shown below
// (see the Javadoc for `{MethodSource}` for further details on supported return types).
// Note that `arguments(Object...)` is a static factory method defined in the `Arguments`
// interface. In addition, `Arguments.of(Object...)` may be used as an alternative to
// `arguments(Object...)`.
パラメタライズテストに複数の引数を宣言した場合、ファクトリメソッドの返り値型は `Arguments` を要素型とするコレクション、ストリーム、配列にするか、オブジェクト型の配列にしなければなりません（対応している返り値型について詳しくは `{MethodSource}` の Javadoc を参照してください）。
`arguments(Object...)` は `Arguments` インターフェイスに定義した static ファクトリメソッドです。
代わりに `Arguments.of(Object...)` を使うこともできます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=multi_arg_MethodSource_example]
----

// An external, `static` _factory_ method can be referenced by providing its _fully
// qualified method name_ as demonstrated in the following example.
外部のクラスで `static` 宣言した _ファクトリメソッド_ は _完全修飾メソッド名_ で指定できます。

[source,java,indent=0]
----
package example;

include::{testDir}/example/ExternalMethodSourceDemo.java[tags=external_MethodSource_example]
----

[[writing-tests-parameterized-tests-sources-CsvSource]]
===== @CsvSource

// `@CsvSource` allows you to express argument lists as comma-separated values (i.e.,
// `String` literals).
`@CsvSource` を使うと、引数のリストをカンマ区切りで表現できます（例えば文字列リテラル）。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
----

// The default delimiter is a comma (`,`), but you can use another character by setting the
// `delimiter` attribute. Alternatively, the `delimiterString` attribute allows you to use a
// `String` delimiter instead of a single character. However, both delimiter attributes
// cannot be set simultaneously.
既定の区切り文字はカンマ（`,`）ですが、`delimiter` 属性で別の文字を指定できます。
`delimiterString` 属性には区切り文字ではなく区切り文字列を指定できます。
両方の属性を同時に設定することはできません。

// `@CsvSource` uses a single quote `'` as its quote character. See the `'lemon, lime'` value
// in the example above and in the table below. An empty, quoted value `''` results in an
// empty `String` unless the `emptyValue` attribute is set; whereas, an entirely _empty_
// value is interpreted as a `null` reference. By specifying one or more `nullValues`, a
// custom value can be interpreted as a `null` reference (see the `NIL` example in the table
// below). An `ArgumentConversionException` is thrown if the target type of a `null`
// reference is a primitive type.
既定の囲み文字は一重引用符（`'`）です。
この次の具体例にあるとおり、`'lemon, lime'` のように記述できます。
`emptyValue` 属性が未指定なら `''` は空文字列になります。
囲み文字すら無い完全な _空値_ は `null` になります。
`nullValues` 属性に指定した1つ以上の文字列のいずれかに対応する値は `null` になります（この次の具体例で `NIL` の例を参照してください）。
プリミティブ型のメソッド引数に `null` を渡すと `ArgumentConversionException` をスローします。

// NOTE: An _unquoted_ empty value will always be converted to a `null` reference regardless
// of any custom values configured via the `nullValues` attribute.
NOTE: `nullValues` 属性にどんな値を設定しても、_囲み文字で囲んでない_ 空値は常に `null` になります。

// Unless it starts with a quote character, leading and trailing whitespaces of a
// CSV column are trimmed by default. This behavior can be changed by setting the
// `ignoreLeadingAndTrailingWhitespace` attribute to `true`.
既定では、囲み文字があってもなくても、CSV の列の値の前後の空白は除去します。
`ignoreLeadingAndTrailingWhitespace` 属性に `false` を設定すると、空白を除去しなくなります（JUnit Jupiter 5.8 で導入された機能です）。

[cols="50,50"]
// |===
// | Example Input                                                                           | Resulting Argument List

// | `@CsvSource({ "apple, banana" })`                                                       | `"apple"`, `"banana"`
// | `@CsvSource({ "apple, 'lemon, lime'" })`                                                | `"apple"`, `"lemon, lime"`
// | `@CsvSource({ "apple, ''" })`                                                           | `"apple"`, `""`
// | `@CsvSource({ "apple, " })`                                                             | `"apple"`, `null`
// | `@CsvSource(value = { "apple, banana, NIL" }, nullValues = "NIL")`                      | `"apple"`, `"banana"`, `null`
// | `@CsvSource(value = { " apple , banana" }, ignoreLeadingAndTrailingWhitespace = false)` | `" apple "`, `" banana"`
// |===
|===
| サンプルコード                                                                          | 引数に渡される値のリスト

| `@CsvSource({ "apple, banana" })`                                                       | `"apple"`, `"banana"`
| `@CsvSource({ "apple, 'lemon, lime'" })`                                                | `"apple"`, `"lemon, lime"`
| `@CsvSource({ "apple, ''" })`                                                           | `"apple"`, `""`
| `@CsvSource({ "apple, " })`                                                             | `"apple"`, `null`
| `@CsvSource(value = { "apple, banana, NIL" }, nullValues = "NIL")`                      | `"apple"`, `"banana"`, `null`
| `@CsvSource(value = { " apple , banana" }, ignoreLeadingAndTrailingWhitespace = false)` | `" apple "`, `" banana"`
|===

[[writing-tests-parameterized-tests-sources-CsvFileSource]]
===== @CsvFileSource

// `@CsvFileSource` lets you use CSV files from the classpath or the local file system. Each
// line from a CSV file results in one invocation of the parameterized test.
`@CsvFileSource` を使うとクラスパスやローカルファイルシステムに配置した CSV ファイルを使用できます。
CSV ファイルの各行ごとに、パラメタライズテストのテストメソッドを実行します。

// The default delimiter is a comma (`,`), but you can use another character by setting the
// `delimiter` attribute. Alternatively, the `delimiterString` attribute allows you to use a
// `String` delimiter instead of a single character. However, both delimiter attributes
// cannot be set simultaneously.
既定の区切り文字はカンマ（`,`）ですが、`delimiter` 属性で別の文字を指定できます。
`delimiterString` 属性には区切り文字ではなく区切り文字列を指定できます。
両方の属性を同時に設定することはできません。

// .Comments in CSV files
// NOTE: Any line beginning with a `\#` symbol will be interpreted as a comment and will be
// ignored.
.CSVファイル中のコメント行の扱い
NOTE: `\#` で始まる行はコメントと見做して、すべて無視します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvFileSource_example]
----

[source,csv,indent=0]
.two-column.csv
----
include::{testResourcesDir}/two-column.csv[]
----

// In contrast to the syntax used in `@CsvSource`, `@CsvFileSource` uses a double quote `"`
// as the quote character. See the `"United States of America"` value in the example above.
// An empty, quoted value `""` results in an empty `String` unless the `emptyValue` attribute
// is set; whereas, an entirely _empty_ value is interpreted as a `null` reference. By
// specifying one or more `nullValues`, a custom value can be interpreted as a `null`
// reference. An `ArgumentConversionException` is thrown if the target type of a `null`
// reference is a primitive type.
`@CsvSource` と違って、`@CsvFileSource` では囲み文字として二重引用符（`"`）を使います。
前の例では `"United States of America"` のように使っています。
`emptyValue` 属性が未指定なら `""` は空文字列になります。
囲み文字すら無い完全な _空値_ は `null` になります。
`nullValues` 属性に指定した1つ以上の文字列のいずれかに対応する値は `null` になります。
プリミティブ型のメソッド引数に `null` を渡すと `ArgumentConversionException` をスローします。

// NOTE: An _unquoted_ empty value will always be converted to a `null` reference regardless
// of any custom values configured via the `nullValues` attribute.
NOTE: `nullValues` 属性にどんな値を設定しても、_囲み文字で囲んでない_ 空値は常に `null` になります。

// Unless it starts with a quote character, leading and trailing whitespaces of a
// CSV column are trimmed by default. This behavior can be changed by setting the
// `ignoreLeadingAndTrailingWhitespace` attribute to `true`.
既定では、囲み文字があってもなくても、CSV の列の値の前後の空白は除去します。
`ignoreLeadingAndTrailingWhitespace` 属性に `false` を設定すると、空白を除去しなくなります（JUnit Jupiter 5.8 で導入された機能です）。

[[writing-tests-parameterized-tests-sources-ArgumentsSource]]
===== @ArgumentsSource

// `@ArgumentsSource` can be used to specify a custom, reusable `ArgumentsProvider`. Note
// that an implementation of `ArgumentsProvider` must be declared as either a top-level
// class or as a `static` nested class.
`@ArgumentsSource` は自作の再利用可能な `ArgumentsProvider` を指定するために使います。
`ArgumentsProvider` の実装クラスはトップレベルクラスか `static` 宣言した内部クラスにしなければいけません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsSource_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsProvider_example]
----


[[writing-tests-parameterized-tests-argument-conversion]]
==== 引数の変換

[[writing-tests-parameterized-tests-argument-conversion-widening]]
===== ワイドニング変換

// JUnit Jupiter supports
// https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2[Widening Primitive
// Conversion] for arguments supplied to a `@ParameterizedTest`. For example, a
// parameterized test annotated with `@ValueSource(ints = { 1, 2, 3 })` can be declared to
// accept not only an argument of type `int` but also an argument of type `long`, `float`,
// or `double`.
JUnit Jupiter はパラメタライズテストに渡される引数の https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.2[プリミティブ型のワイドニング変換] に対応しています。
例えば、テストメソッドを `@ValueSource(ints = { 1, 2, 3 })` で修飾した場合、メソッド引数の型には `int, long, float, double` が使用できます。

[[writing-tests-parameterized-tests-argument-conversion-implicit]]
===== 暗黙的な型変換

// To support use cases like `@CsvSource`, JUnit Jupiter provides a number of built-in
// implicit type converters. The conversion process depends on the declared type of each
// method parameter.
JUnit Jupiter は `@CsvSource` に必要な暗黙の型変換処理をいくつも提供しています。
メソッド引数の型によって、異なる変換処理を実行するということです。

// For example, if a `@ParameterizedTest` declares a parameter of type `TimeUnit` and the
// actual type supplied by the declared source is a `String`, the string will be
// automatically converted into the corresponding `TimeUnit` enum constant.
例えば、パラメタライズテストのメソッド引数の型が `TimeUnit` で、ソースのデータ型が `String` なら、`TimeUnit` 列挙型の対応する定数へ自動的に変換します。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_conversion_example]
----

// `String` instances are implicitly converted to the following target types.
`String` からは、次のようなメソッド引数の型へ暗黙的に型変換します。

// NOTE: Decimal, hexadecimal, and octal `String` literals will be converted to their
// integral types: `byte`, `short`, `int`, `long`, and their boxed counterparts.
NOTE: `String` リテラルで10進数記法、16進数記法、8進数記法の数値を指定した場合、`byte, short, int, long` の対応するプリミティブ型か、プリミティブ型に対応するラッパークラスへ変換します。

[[writing-tests-parameterized-tests-argument-conversion-implicit-table]]
[cols="10,90"]
|===
| Target Type | Example

| `boolean`/`Boolean`        | `"true"`                                 -> `true`
| `byte`/`Byte`              | `"15"`, `"0xF"`, or `"017"`              -> `(byte) 15`
| `char`/`Character`         | `"o"`                                    -> `'o'`
| `short`/`Short`            | `"15"`, `"0xF"`, or `"017"`              -> `(short) 15`
| `int`/`Integer`            | `"15"`, `"0xF"`, or `"017"`              -> `15`
| `long`/`Long`              | `"15"`, `"0xF"`, or `"017"`              -> `15L`
| `float`/`Float`            | `"1.0"`                                  -> `1.0f`
| `double`/`Double`          | `"1.0"`                                  -> `1.0d`
// | `Enum` subclass            | `"SECONDS"`                              -> `TimeUnit.SECONDS`
| `Enum` の派生クラス        | `"SECONDS"`                              -> `TimeUnit.SECONDS`
| `java.io.File`             | `"/path/to/file"`                        -> `new File("/path/to/file")`
// | `java.lang.Class`          | `"java.lang.Integer"`                    -> `java.lang.Integer.class` _(use `$` for nested classes, e.g. `"java.lang.Thread$State"`)_
| `java.lang.Class`          | `"java.lang.Integer"`                    -> `java.lang.Integer.class` _（内部クラスを指定するときは `$` を使う。例えば `"java.lang.Thread$State"`）_
// | `java.lang.Class`          | `"byte"`                                 -> `byte.class` _(primitive types are supported)_
| `java.lang.Class`          | `"byte"`                                 -> `byte.class` _（プリミティブ型に対応しています）_
// | `java.lang.Class`          | `"char[]"`                               -> `char[].class` _(array types are supported)_
| `java.lang.Class`          | `"char[]"`                               -> `char[].class` _（配列型に対応しています）_
| `java.math.BigDecimal`     | `"123.456e789"`                          -> `new BigDecimal("123.456e789")`
| `java.math.BigInteger`     | `"1234567890123456789"`                  -> `new BigInteger("1234567890123456789")`
| `java.net.URI`             | `"https://junit.org/"`                   -> `URI.create("https://junit.org/")`
| `java.net.URL`             | `"https://junit.org/"`                   -> `new URL("https://junit.org/")`
| `java.nio.charset.Charset` | `"UTF-8"`                                -> `Charset.forName("UTF-8")`
| `java.nio.file.Path`       | `"/path/to/file"`                        -> `Paths.get("/path/to/file")`
| `java.time.Duration`       | `"PT3S"`                                 -> `Duration.ofSeconds(3)`
| `java.time.Instant`        | `"1970-01-01T00:00:00Z"`                 -> `Instant.ofEpochMilli(0)`
| `java.time.LocalDateTime`  | `"2017-03-14T12:34:56.789"`              -> `LocalDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000)`
| `java.time.LocalDate`      | `"2017-03-14"`                           -> `LocalDate.of(2017, 3, 14)`
| `java.time.LocalTime`      | `"12:34:56.789"`                         -> `LocalTime.of(12, 34, 56, 789_000_000)`
| `java.time.MonthDay`       | `"--03-14"`                              -> `MonthDay.of(3, 14)`
| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"`             -> `OffsetDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.OffsetTime`     | `"12:34:56.789Z"`                        -> `OffsetTime.of(12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.Period`         | `"P2M6D"`                                -> `Period.of(0, 2, 6)`
| `java.time.YearMonth`      | `"2017-03"`                              -> `YearMonth.of(2017, 3)`
| `java.time.Year`           | `"2017"`                                 -> `Year.of(2017)`
| `java.time.ZonedDateTime`  | `"2017-03-14T12:34:56.789Z"`             -> `ZonedDateTime.of(2017, 3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)`
| `java.time.ZoneId`         | `"Europe/Berlin"`                        -> `ZoneId.of("Europe/Berlin")`
| `java.time.ZoneOffset`     | `"+02:30"`                               -> `ZoneOffset.ofHoursMinutes(2, 30)`
| `java.util.Currency`       | `"JPY"`                                  -> `Currency.getInstance("JPY")`
| `java.util.Locale`         | `"en"`                                   -> `new Locale("en")`
| `java.util.UUID`           | `"d043e930-7b3b-48e3-bdbe-5a3ccfb833db"` -> `UUID.fromString("d043e930-7b3b-48e3-bdbe-5a3ccfb833db")`
|===

[[writing-tests-parameterized-tests-argument-conversion-implicit-fallback]]
====== 文字列からオブジェクトへ変換するときの代替処理

// In addition to implicit conversion from strings to the target types listed in the above
// table, JUnit Jupiter also provides a fallback mechanism for automatic conversion from a
// `String` to a given target type if the target type declares exactly one suitable _factory
// method_ or a _factory constructor_ as defined below.
JUnit Jupiter は文字列からメソッド引数の型への型変換（前のセクションで表に列挙した）だけでなく、文字列からの変換処理が未定義の場合の代替処理として、自動的に単一の _ファクトリメソッド_ あるいは、単一の _ファクトリコンストラクタ_ を探索し、実行できます。

// - __factory method__: a non-private, `static` method declared in the target type that
//   accepts a single `String` argument and returns an instance of the target type. The name
//   of the method can be arbitrary and need not follow any particular convention.
// - __factory constructor__: a non-private constructor in the target type that accepts a
//   single `String` argument. Note that the target type must be declared as either a
//   top-level class or as a `static` nested class.
- __ファクトリメソッド__: 可視性は `package` 以上。`static` 宣言している。引数は `String` 1つ。返り値は対象データ型のインスタンスである、対象データ型に定義したメソッド。メソッド名は自由です。
- __ファクトリコンストラクタ__: 可視性は `package` 以上。引数は `String` 1 つ。対象データ型はトップレベルクラスか `static` 宣言したインナークラスにしなければいけません。

// NOTE: If multiple _factory methods_ are discovered, they will be ignored. If a _factory
// method_ and a _factory constructor_ are discovered, the factory method will be used
// instead of the constructor.
NOTE: _ファクトリメソッド_ を複数発見したときは何も見つからなかったものとします。_ファクトリメソッド_ と _ファクトリコンストラクタ_ が見つかったときはファクトリメソッドを優先して使用します。

// For example, in the following `@ParameterizedTest` method, the `Book` argument will be
// created by invoking the `Book.fromTitle(String)` factory method and passing `"42 Cats"`
// as the title of the book.
次のコード例は、ファクトリメソッド `Book.fromTitle(String)` で `"42 Cats"` から作成した `Book` のインスタンスをテストメソッドに渡しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=implicit_fallback_conversion_example_Book]
----

[[writing-tests-parameterized-tests-argument-conversion-explicit]]
===== 明示的な型変換

// Instead of relying on implicit argument conversion you may explicitly specify an
// `ArgumentConverter` to use for a certain parameter using the `@ConvertWith` annotation
// like in the following example. Note that an implementation of `ArgumentConverter` must be
// declared as either a top-level class or as a `static` nested class.
暗黙的な型変換に頼れない場合は、メソッド引数を `@ConvertWith` で修飾し、`ArgumentConverter` を指定することでデータ型を変換します。
`ArgumentConverter` の実装クラスはトップレベルクラスか `static` 宣言したインナークラスにしなければいけません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example_ToStringArgumentConverter]
----

// If the converter is only meant to convert one type to another, you can extend
// `TypedArgumentConverter` to avoid boilerplate type checks.
データ型を変換するだけなら、`TypedArgumentConverter` を継承すれば、定型的な型チェックを省略できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_conversion_example_TypedArgumentConverter]
----

// Explicit argument converters are meant to be implemented by test and extension authors.
// Thus, `junit-jupiter-params` only provides a single explicit argument converter that may
// also serve as a reference implementation: `JavaTimeArgumentConverter`. It is used via the
// composed annotation `JavaTimeConversionPattern`.
引数の明示的な型変換を実装するのは、テストや拡張機能の作者の責任です。
それゆえに、`junit-jupiter-params` では参照実装として `JavaTimeArgumentConverter` だけを提供しています。
合成アノテーションの `JavaTimeConversionPattern` と一緒に使います。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_java_time_converter]
----

[[writing-tests-parameterized-tests-argument-aggregation]]
==== 引数の集約

// By default, each _argument_ provided to a `@ParameterizedTest` method corresponds to a
// single method parameter. Consequently, argument sources which are expected to supply a
// large number of arguments can lead to large method signatures.
既定では、パラメタライズテストに渡すそれぞれの _引数_ は、1つ1つのメソッド引数に対応します。
つまり、複数の引数をかたまりとして提供するソースには、それだけ多くのメソッド引数が必要になるのです。

// In such cases, an `{ArgumentsAccessor}` can be used instead of multiple parameters. Using
// this API, you can access the provided arguments through a single argument passed to your
// test method. In addition, type conversion is supported as discussed in
// <<writing-tests-parameterized-tests-argument-conversion-implicit>>.
そういう場合はメソッド引数を複数宣言する代わりに `{ArgumentsAccessor}` を使用します。
この API を使用すると、複数の引数を単一のメソッド引数に渡すことができるようになります。
また、データ型の変換は <<writing-tests-parameterized-tests-argument-conversion-implicit>> と同様に行われます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAccessor_example]
----

// _An instance of `ArgumentsAccessor` is automatically injected into any parameter of type
// `ArgumentsAccessor`._
_ `ArgumentsAccessor` 型の引数には自動的に `ArgumentsAccessor` のインスタンスが注入されます。_

[[writing-tests-parameterized-tests-argument-aggregation-custom]]
===== 独自の集約

// Apart from direct access to a `@ParameterizedTest` method's arguments using an
// `ArgumentsAccessor`, JUnit Jupiter also supports the usage of custom, reusable
// _aggregators_.
パラメタライズテストの中で直接 `ArgumentsAccessor` から引数へアクセスする代わりに、独自の再利用可能な _アグリゲーター_ を使用できるようになっています。

// To use a custom aggregator, implement the `{ArgumentsAggregator}` interface and register
// it via the `@AggregateWith` annotation on a compatible parameter in the
// `@ParameterizedTest` method. The result of the aggregation will then be provided as an
// argument for the corresponding parameter when the parameterized test is invoked. Note
// that an implementation of `ArgumentsAggregator` must be declared as either a top-level
// class or as a `static` nested class.
独自のアグリゲーターをパラメタライズテストで使用するには、互換性のあるデータ型のメソッド引数を `@AggregateWith` で修飾し、`{ArgumentsAggregator}` インターフェイスの実装クラスを指定します。
テストメソッドを実行するとき、メソッド引数には集約した結果が渡されます。
`ArgumentsAggregator` の実装クラスはトップレベルクラスか `static` 宣言したインナークラスにしなければいけません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_example_PersonAggregator]
----

// If you find yourself repeatedly declaring `@AggregateWith(MyTypeAggregator.class)` for
// multiple parameterized test methods across your codebase, you may wish to create a custom
// _composed annotation_ such as `@CsvToMyType` that is meta-annotated with
// `@AggregateWith(MyTypeAggregator.class)`. The following example demonstrates this in
// action with a custom `@CsvToPerson` annotation.
コードベースのあちこちで、テストメソッドの複数の引数を `@AggregateWith(MyTypeAggregator.class)` で修飾しているような場合、`@AggregateWith(MyTypeAggregator.class)` のメタアノテーションとなる `@CsvToMyType` のような _合成アノテーション_ が欲しくなるでしょう。
次のコード例は `PersonAggregator` を使用する `@CsvToPerson` アノテーションを定義しています。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_with_custom_annotation_example]
----

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_with_custom_annotation_example_CsvToPerson]
----


[[writing-tests-parameterized-tests-display-names]]
==== 表示名の変更

// By default, the display name of a parameterized test invocation contains the invocation
// index and the `String` representation of all arguments for that specific invocation.
// Each of them is preceded by the parameter name (unless the argument is only available via
// an `ArgumentsAccessor` or `ArgumentAggregator`), if present in the bytecode (for Java,
// test code must be compiled with the `-parameters` compiler flag).
パラメタライズテストの表示名には、呼び出し回数を表す数値と、全てのメソッド引数の文字列表現が含まれています。
`ArgumentsAccessor` や `ArgumentAggregator` 以外のメソッド引数の値の前には、バイトコードに含まれている引数名が指定されています（テストコードをコンパイルするときに `-parameters` フラグを指定した場合です）。

// However, you can customize invocation display names via the `name` attribute of the
// `@ParameterizedTest` annotation like in the following example.
しかし、`@ParameterizedTest` の `name` 属性に指定した文字列パターンで表示名は変更できます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=custom_display_names]
----

// When executing the above method using the `ConsoleLauncher` you will see output similar to
// the following.
前のコード例を `ConsoleLauncher` で実行すると、次のように出力されます。

....
Display name of container ✔
├─ 1 ==> the rank of 'apple' is 1 ✔
├─ 2 ==> the rank of 'banana' is 2 ✔
└─ 3 ==> the rank of 'lemon, lime' is 3 ✔
....

// Please note that `name` is a `MessageFormat` pattern. Thus, a single quote (`'`) needs to be represented as a doubled single quote (`''`) in order to be displayed.
`name` 属性に指定できるのは `MessageFormat` が対応している文字列パターンです。
一重引用符（`'`）を使いたいときは2つ続けて（`''`）のようにしなければなりません。

// The following placeholders are supported within custom display names.
表示名の文字列パターンが対応しているプレースホルダは次のとおりです。

[cols="20,80"]
// |===
// | Placeholder              | Description

// | `{displayName}`          | the display name of the method
// | `{index}`                | the current invocation index (1-based)
// | `{arguments}`            | the complete, comma-separated arguments list
// | `{argumentsWithNames}`   | the complete, comma-separated arguments list with parameter names
// | `{0}`, `{1}`, ...        | an individual argument
// |===
|===
| プレースホルダ           | 内容

| `{displayName}`          | メソッド名
| `{index}`                | 1から数え始める呼び出し回数
| `{arguments}`            | カンマ区切りにした引数の値
| `{argumentsWithNames}`   | カンマ区切りにした引数の名前と値
| `{0}`, `{1}`, ...        | 位置に対応する引数の値
|===

// NOTE: When including arguments in display names, their string representations are truncated
// if they exceed the configured maximum length. The limit is configurable via the
// `junit.jupiter.params.displayname.argument.maxlength` configuration parameter and defaults
// to 512 characters.
NOTE: 引数を表示名に含めるとき、最大文字列長を超過するなら文字列表現は短縮されます。最大文字列長は `junit.jupiter.params.displayname.argument.maxlength` で指定できます。初期値は 512 文字です。

// When using `@MethodSource` or `@ArgumentSource`, you can give names to arguments. This
// name will be used if the argument is included in the invocation display name, like in
// the example below.
`@MethodSource` や `@ArgumentSource` を使うときは引数に名前を指定できます。
表示名の文字列パターンに引数の名前が含まれているときは、指定した名前が使われます。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=named_arguments]
----

....
A parameterized test with named arguments ✔
├─ 1: An important file ✔
└─ 2: Another file ✔
....

// If you'd like to set default name pattern for all parameterized tests in your project, you can add the following
// configuration to `junit-platform.properties`
プロジェクトに含まれる全てのパラメタライズテストで使用する表示名の文字列パターンを指定するには、`junit-platform.properties` を次のように記述します。

[source,properties,indent=0]
----
junit.jupiter.params.displayname.default = {index}
----

// the display name for a parameterized method is determined according to the following precedence rules:
パラメタライズテストの表示名を決定する規則は次のとおりです。

// 1. `name` of `@ParameterizedTest`, if present
// 2. the value of `junit.jupiter.params.displayname.default` (from junit-platform.properties), if present
// 3. `DEFAULT_DISPLAY_NAME` constant defined in `@ParameterizedTest`

1. `@ParameterizedTest` の `name` 属性の値
2. （存在するなら）`junit-platform.properties` で指定された `junit.jupiter.params.displayname.default` の値
3. `@ParameterizedTest` に定義された定数 `DEFAULT_DISPLAY_NAME` の値

[[writing-tests-parameterized-tests-lifecycle-interop]]
==== ライフサイクルと相互運用性

// Each invocation of a parameterized test has the same lifecycle as a regular `@Test`
// method. For example, `@BeforeEach` methods will be executed before each invocation.
// Similar to <<writing-tests-dynamic-tests>>, invocations will appear one by one in the
// test tree of an IDE. You may at will mix regular `@Test` methods and `@ParameterizedTest`
// methods within the same test class.
パラメタライズテストのそれぞれの呼び出しには、普通の `@Test` メソッドを呼び出すのと同じライフサイクルが伴います。
例えば、`@BeforeEach` は毎回呼び出されるということです。
<<writing-tests-dynamic-tests>> と同様に、IDE からはそれぞれの呼び出し結果が1つのツリーにぶら下がるように見えることになります。
同じテストクラスで `@ParameterizedTest` と普通の `@Test` を混ぜて使用できます。

// You may use `ParameterResolver` extensions with `@ParameterizedTest` methods. However,
// method parameters that are resolved by argument sources need to come first in the
// argument list. Since a test class may contain regular tests as well as parameterized
// tests with different parameter lists, values from argument sources are not resolved for
// lifecycle methods (e.g. `@BeforeEach`) and test class constructors.
`@ParameterizedTest` と `ParameterResolver` 拡張を組み合わせて使用するとしても、メソッド引数の前のほうには `@ArgumentSource` で解決する引数を定義しなければなりません。
テストクラスにパラメタライズテストと普通のテストメソッドを定義している、かつ、普通のテストメソッドにはパラメタライズテストと異なる引数を定義しているとしたら、普通のテストメソッドを実行するとき、`@BeforeEach` などのライフサイクルメソッドやテストクラスのコンストラクタでは、`@ArgumentSource` による引数の解決は行われません。

[source,java,indent=0]
----
include::{testDir}/example/ParameterizedTestDemo.java[tags=ParameterResolver_example]
----

[[writing-tests-test-templates]]
=== テストのテンプレート化

// A `{TestTemplate}` method is not a regular test case but rather a template for test
// cases. As such, it is designed to be invoked multiple times depending on the number of
// invocation contexts returned by the registered providers. Thus, it must be used in
// conjunction with a registered `{TestTemplateInvocationContextProvider}` extension. Each
// invocation of a test template method behaves like the execution of a regular `@Test`
// method with full support for the same lifecycle callbacks and extensions. Please refer to
// <<extensions-test-templates>> for usage examples.
`{TestTemplate}` で修飾したメソッドは、普通のテストメソッドではなくテンプレートとして使われます。
登録したプロバイダーの返す呼び出しコンテキストの数と同じだけ呼び出す前提で設計します。
つまり、定義済みの `{TestTemplateInvocationContextProvider}` 拡張と組み合わせて使用しなければなりません。
それぞれの呼び出しは、普通の `@Test` メソッドと完全に同じライフサイクルメソッドと拡張機能に対応しています。
具体的な使い方は <<extensions-test-templates>> を参照してください。

// NOTE: <<writing-tests-repeated-tests>> and <<writing-tests-parameterized-tests>> are
// built-in specializations of test templates.
NOTE: <<writing-tests-repeated-tests>> と <<writing-tests-parameterized-tests>> はテストのテンプレート化機能で実装されています。

[[writing-tests-dynamic-tests]]
=== 実行時にテストを生成する

// The standard `@Test` annotation in JUnit Jupiter described in
// <<writing-tests-annotations>> is very similar to the `@Test` annotation in JUnit 4. Both
// describe methods that implement test cases. These test cases are static in the sense that
// they are fully specified at compile time, and their behavior cannot be changed by
// anything happening at runtime. _Assumptions provide a basic form of dynamic behavior but
// are intentionally rather limited in their expressiveness._
JUnit Jupiter における基本的な `@Test` アノテーション（<<writing-tests-annotations>> を参照）は、JUnit 4 の `@Test` と非常によく似た機能を提供します。
あるメソッドがテストを実装したものであることを示しているのです。
これらのテストはコンパイル時に確定するため、ある意味静的なものであり、実行時に振る舞いを変更できません。
_仮定（Assumption）は動的な振る舞いの基本的な形態ではありますが、その表現力は意図的に制限されています。_

// In addition to these standard tests a completely new kind of test programming model has
// been introduced in JUnit Jupiter. This new kind of test is a _dynamic test_ which is
// generated at runtime by a factory method that is annotated with `@TestFactory`.
JUnit Jupiter では、これまでの標準的なテストとは全く異なる新しいテストプログラミングモデルとして _動的テスト_ を導入しました。
`@TestFactory` で修飾したファクトリメソッドで、実行時にテストメソッドを生成するのです。

// In contrast to `@Test` methods, a `@TestFactory` method is not itself a test case but
// rather a factory for test cases. Thus, a dynamic test is the product of a factory.
// Technically speaking, a `@TestFactory` method must return a single `DynamicNode` or a
// `Stream`, `Collection`, `Iterable`, `Iterator`, or array of `DynamicNode` instances.
// Instantiable subclasses of `DynamicNode` are `DynamicContainer` and `DynamicTest`.
// `DynamicContainer` instances are composed of a _display name_ and a list of dynamic child
// nodes, enabling the creation of arbitrarily nested hierarchies of dynamic nodes.
// `DynamicTest` instances will be executed lazily, enabling dynamic and even
// non-deterministic generation of test cases.
普通のテストメソッドと違って、`@TestFactory` で修飾したメソッドはテストメソッドではなく、ファクトリメソッドなのです。
ファクトリメソッドで、動的テストを生成するのです。
具体的には、`@TestFactory` で修飾したファクトリメソッドの返り値は、単独の `DynamicNode` か、`DynamicNode` を要素とする `Stream, Collection, Iterable, Iterator` あるいは配列にします。
`DynamicNode` の派生クラス `DynamicContainer` および `DynamicTest` はインスタンス化可能です。
`DynamicContainer` は _表示名_ と `DynamicNode` のリストを組み合わせたもので、任意の入れ子構造を作成できます。
`DynamicTest` は遅延評価（実行）するインスタンスで、実行時に、非決定論的なテストを表現できます。

// Any `Stream` returned by a `@TestFactory` will be properly closed by calling
// `stream.close()`, making it safe to use a resource such as `Files.lines()`.
`@TestFactory` メソッドの返り値が `Stream` の場合、`Files.lines()` のようにリソースを安全に使うため、`stream.close()` で閉じないといけいません。

// As with `@Test` methods, `@TestFactory` methods must not be `private` or `static` and may
// optionally declare parameters to be resolved by `ParameterResolvers`.
`@Test` メソッドと同じく、`@TestFactory` メソッドの可視性は `private` にできません。
また、`static` 宣言することもできません。
さらに、`ParameterResolvers` でメソッド引数を解決できます。

// A `DynamicTest` is a test case generated at runtime. It is composed of a _display name_
// and an `Executable`. `Executable` is a `@FunctionalInterface` which means that the
// implementations of dynamic tests can be provided as _lambda expressions_ or _method
// references_.
`DynamicTest` は実行時に生成するテストケースで、_表示名_ と `Executable` を組み合わせたものです。
`Executable` は `@FunctionalInterface` の実装クラスのことで、動的クラスにおいては _ラムダ式_ や _メソッド参照_ として記述できます。

// .Dynamic Test Lifecycle
// WARNING: The execution lifecycle of a dynamic test is quite different than it is for a
// standard `@Test` case. Specifically, there are no lifecycle callbacks for individual
// dynamic tests. This means that `@BeforeEach` and `@AfterEach` methods and their
// corresponding extension callbacks are executed for the `@TestFactory` method but not for
// each _dynamic test_. In other words, if you access fields from the test instance within a
// lambda expression for a dynamic test, those fields will not be reset by callback methods
// or extensions between the execution of individual dynamic tests generated by the same
// `@TestFactory` method.
.動的テストのライフサイクル
WARNING: 動的テストのライフサイクルは普通のテストメソッドとは大きく異なります。特に違うのは、動的テストにはライフサイクルメソッドの呼び出しが伴わないことです。
つまり、`@TestFactory` メソッドを呼び出すときは `@BeforeEach` や `@AfterEach` メソッド（および関連する拡張機能）も呼び出されるのですが、動的テスト自体を実行するときは呼び出されないのです。
言い換えると、動的テストの実装であるラムダ式からテストクラスのインスタンスフィールドへアクセスするとしても、同じ `@TestFactory` メソッドの生成したそれぞれの動的テストを呼び出している間に、フィールドを初期化するライフサイクルメソッドは呼び出されないのです。

// As of JUnit Jupiter {jupiter-version}, dynamic tests must always be created by factory
// methods; however, this might be complemented by a registration facility in a later
// release.
JUnit Jupiter 5.8.0 の時点では、ファクトリメソッドでしか動的テストを生成できませんが、将来的には登録方式でも生成できるようになるでしょう。

[[writing-tests-dynamic-tests-examples]]
==== 動的テストの具体例

// The following `DynamicTestsDemo` class demonstrates several examples of test factories
// and dynamic tests.
次のコード例では `DynamicTestsDemo` クラスにより動的テストのいろいろな使い方を紹介します。

// The first method returns an invalid return type. Since an invalid return type cannot be
// detected at compile time, a `JUnitException` is thrown when it is detected at runtime.
最初のメソッドは返り値の型が間違っているのですが、コンパイル時に検出できないので、実行時に `JUnitException` をスローします。

// The next six methods are very simple examples that demonstrate the generation of a
// `Collection`, `Iterable`, `Iterator`, array, or `Stream` of `DynamicTest` instances. Most of
// these examples do not really exhibit dynamic behavior but merely demonstrate the
// supported return types in principle. However, `dynamicTestsFromStream()` and
// `dynamicTestsFromIntStream()` demonstrate how easy it is to generate dynamic tests for a
// given set of strings or a range of input numbers.
2つ目から続く6つのメソッドは、`DynamicTest` を要素とする `Collection, Iterable, Iterator, 配列, Stream` を返り値の型にしています。
特に動的な振る舞いを説明するものではありませんが、対応している返り値の型は分かると思います。
`dynamicTestsFromStream()` や `dynamicTestsFromIntStream()` を見れば、複数の文字列や、数値の範囲に基づく動的なテストを簡単に生成できるのが分かります。

// The next method is truly dynamic in nature. `generateRandomNumberOfTests()` implements an
// `Iterator` that generates random numbers, a display name generator, and a test executor
// and then provides all three to `DynamicTest.stream()`. Although the non-deterministic
// behavior of `generateRandomNumberOfTests()` is of course in conflict with test
// repeatability and should thus be used with care, it serves to demonstrate the
// expressiveness and power of dynamic tests.
`generateRandomNumberOfTests()` は動的テストの本来の性質を活用しています。
乱数を生成する `Iterator`、表示名を生成するラムダ式、テストロジックを実装したラムダ式を `DynamicTest.stream()` へ渡しています。
どの辺が本来の性質なのかというと、実行するたびに結果が変化するところです。
動的テストの表現力を証明するためのコード例なので、実際に使用する場合は注意してください。

// The next method is similar to `generateRandomNumberOfTests()` in terms of flexibility;
// however, `dynamicTestsFromStreamFactoryMethod()` generates a stream of dynamic tests from
// an existing `Stream` via the `DynamicTest.stream()` factory method.
`generateRandomNumberOfTests()` と同じように柔軟性を活用しているのが `dynamicTestsFromStreamFactoryMethod()` です。
ファクトリメソッドの `DynamicTest.stream()` へ `Stream` を渡しているのが違うところです。

// For demonstration purposes, the `dynamicNodeSingleTest()` method generates a single
// `DynamicTest` instead of a stream, and the `dynamicNodeSingleContainer()` method generates
// a nested hierarchy of dynamic tests utilizing `DynamicContainer`.
`dynamicNodeSingleTest()` が単一の `DynamicTest` を返すようになっているのはあくまでも説明用です。
`dynamicNodeSingleContainer()` では、`DynamicContainer` で動的テストの入れ子構造を作成しています。

[source,java]
----
include::{testDir}/example/DynamicTestsDemo.java[tags=user_guide]
----

[[writing-tests-dynamic-tests-uri-test-source]]
==== 動的テストのための URI テストソース

// The JUnit Platform provides `TestSource`, a representation of the source of a test or
// container used to navigate to its location by IDEs and build tools.
JUnit Platform の提供する `TestSource` は、テストやテストコンテナを表現するインターフェイスです。
テストメソッドの作成位置や取得元を IDE およびビルドツールに教えるために使用します。

// The `TestSource` for a dynamic test or dynamic container can be constructed from a
// `java.net.URI` which can be supplied via the `DynamicTest.dynamicTest(String, URI,
// Executable)` or `DynamicContainer.dynamicContainer(String, URI, Stream)` factory method,
// respectively. The `URI` will be converted to one of the following `TestSource`
// implementations.
動的テスト（あるいは動的テストコンテナ）の `TestSource` を作成するときは、 `DynamicTest.dynamicTest(String, URI, Executable)` や `DynamicTest.dynbamicContainer(String, URI, Stream)` のようにファクトリメソッドへ `java.net.URI` を渡すようにします。
JUnit Jupiter は `URI` を解釈して次のいずれかの実装クラスを生成します。

`ClasspathResourceSource` ::
  `URI` のプロトコルスキームが `classpath` のとき。例えば `classpath:/test/foo.xml?line=20,column=2`
// If the `URI` contains the `classpath` scheme -- for example,
// `classpath:/test/foo.xml?line=20,column=2`.

`DirectorySource` ::
  `URI` がファイルシステム上のディレクトリを指しているとき。
// If the `URI` represents a directory present in the file system.

`FileSource` ::
  `URI` がファイルシステム上のファイルを指しているとき。
// If the `URI` represents a file present in the file system.

`MethodSource` ::
  `URI` のプロトコルスキームが `method` で、位置が完全修飾メソッド名（FQMN：Fully Qualified Method Name）のとき。例えば `method:org.junit.Foo#bar(Java.lang.String, java.lang.String[])`
  FQMN の形式については `DiscoverySelectors.selectMethod(String)` の Javadoc を参照してください。
// If the `URI` contains the `method` scheme and the fully qualified method name (FQMN) --
// for example, `method:org.junit.Foo#bar(java.lang.String, java.lang.String[])`. Please
// refer to the Javadoc for `DiscoverySelectors.selectMethod(String)` for the supported
// formats for a FQMN.

`ClassSource` ::
  `URI` のプロトコルスキームが `class` で、位置が完全修飾クラス名（FQCN：Fully Qualified Class Name）のとき。例えば `class:org.junit.Foo#line=42`
// If the `URI` contains the `class` scheme and the fully qualified class name --
// for example, `class:org.junit.Foo?line=42`.

`UriSource` ::
  上記のどれにも該当しないとき。
// If none of the above `TestSource` implementations are applicable.


[[writing-tests-declarative-timeouts]]
=== タイムアウト

// The `@Timeout` annotation allows one to declare that a test, test factory, test template,
// or lifecycle method should fail if its execution time exceeds a given duration. The time
// unit for the duration defaults to seconds but is configurable.
テストメソッド、テストファクトリメソッド、テストテンプレート、ライフサイクルメソッドのいずれかを `@Timeout` で修飾すると、指定した時間を過ぎても終了しなかったら失敗させることができるようになります。
時間単位の初期値は秒ですが、自由に変更できます。


// The following example shows how `@Timeout` is applied to lifecycle and test methods.
次のコード例は `@Timeout` の使い方を説明しています。

[source,java]
----
include::{testDir}/example/TimeoutDemo.java[tags=user_guide]
----

// Contrary to the `assertTimeoutPreemptively()` assertion, the execution of the annotated
// method proceeds in the main thread of the test. If the timeout is exceeded, the main
// thread is interrupted from another thread. This is done to ensure interoperability with
// frameworks such as Spring that make use of mechanisms that are sensitive to the currently
// running thread — for example, `ThreadLocal` transaction management.
`assertTimeoutPreemptively()` と違って、修飾したメソッドの実行時間は、テストの主スレッドが計測します。
メソッドの実行時間が指定した時間を超過したら、他のスレッドから主スレッドに対して割り込みを発生させます。
どうしてこういう仕組みにしているのかというと、Spring Framework のように、テストメソッドを実行しているスレッドの `ThreadLocal` でトランザクション状態を管理している場合があるからです。

// To apply the same timeout to all test methods within a test class and all of its `@Nested`
// classes, you can declare the `@Timeout` annotation at the class level. It will then be
// applied to all test, test factory, and test template methods within that class and its
// `@Nested` classes unless overridden by a `@Timeout` annotation on a specific method or
// `@Nested` class. Please note that `@Timeout` annotations declared at the class level are
// not applied to lifecycle methods.
トップレベルクラスを `@Timeout` で修飾すれば、（`@Nested` クラスで定義したメソッドも含めて）全てのテストメソッド、テストファクトリ、テストテンプレートに同じ時間制限を適用できます。
それぞれのメソッド（あるいは `@Nested` クラス）で時間制限を上書きするには `@Timeout` で修飾します。
クラスを修飾した場合、ライフサイクルメソッドに時間制限は適用されない点に注意してください。

// Declaring `@Timeout` on a `@TestFactory` method checks that the factory method returns
// within the specified duration but does not verify the execution time of each individual
// `DynamicTest` generated by the factory. Please use
// `assertTimeout()` or `assertTimeoutPreemptively()` for that purpose.
テストファクトリを `@Timeout` で修飾しても、テストファクトリを実行する時間、つまり、動的テストを生成する時間だけがチェックされます。
それぞれの動的テストで実行時間を制限するには `assertTimeout()` や `assertTimeoutPreemptively()` を使用してください。

// If `@Timeout` is present on a `@TestTemplate` method — for example, a `@RepeatedTest` or
// `@ParameterizedTest` — each invocation will have the given timeout applied to it.
`@RepeatedTest` や `@ParameterizedTest` などのテストテンプレートについては、それぞれのテストメソッドについて `@Timeout` で指定した時間制限が適用されます。

// The following <<running-tests-config-params, configuration parameters>> can be used to
// specify global timeouts for all methods of a certain category unless they or an enclosing
// test class is annotated with `@Timeout`:
次の <<running-tests-config-params, 設定パラメータ>> を設定すると、テストメソッドやライフサイクルメソッドの種類に応じて、`@Timeout` を指定しなかったメソッドのタイムアウト時間を変更できます。

`junit.jupiter.execution.timeout.default`::
    全てのテストメソッドとライフサイクルメソッドのタイムアウト時間。
//    Default timeout for all testable and lifecycle methods
`junit.jupiter.execution.timeout.testable.method.default`::
    全てのテストメソッドのタイムアウト時間。
//    Default timeout for all testable methods
`junit.jupiter.execution.timeout.test.method.default`::
    `@Test` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@Test` methods
`junit.jupiter.execution.timeout.testtemplate.method.default`::
    `@TestTemplate` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@TestTemplate` methods
`junit.jupiter.execution.timeout.testfactory.method.default`::
    `@TestFactory` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@TestFactory` methods
`junit.jupiter.execution.timeout.lifecycle.method.default`::
    全てのライフサイクルメソッドのタイムアウト時間。
//    Default timeout for all lifecycle methods
`junit.jupiter.execution.timeout.beforeall.method.default`::
    `@BeforeAll` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@BeforeAll` methods
`junit.jupiter.execution.timeout.beforeeach.method.default`::
    `@BeforeEach` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@BeforeEach` methods
`junit.jupiter.execution.timeout.aftereach.method.default`::
    `@AfterEach` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@AfterEach` methods
`junit.jupiter.execution.timeout.afterall.method.default`::
    `@AfterAll` で修飾したメソッドのタイムアウト時間。
//    Default timeout for `@AfterAll` methods

// More specific configuration parameters override less specific ones. For example,
// `junit.jupiter.execution.timeout.test.method.default` overrides
// `junit.jupiter.execution.timeout.testable.method.default` which overrides
// `junit.jupiter.execution.timeout.default`.
より抽象度の低い設定項目は、抽象度の高い設定項目の値を上書きします。
具体的には、`junit.jupiter.execution.timeout.test.method.default` は `junit.jupiter.execution.timeout.testable.method.default` を上書きし、`junit.jupiter.execution.timeout.testable.method.default` は `junit.jupiter.execution.timeout.default` を上書きします。

// The values of such configuration parameters must be in the following, case-insensitive
// format: `<number> [ns|μs|ms|s|m|h|d]`. The space between the number and the unit may be
// omitted. Specifying no unit is equivalent to using seconds.
設定パラメータに記述する値の形式は `<number> [ns|μs|ms|s|m|h|d]` です（大文字小文字は区別しません）。
数値と時間単位の間の空白は無視します。
時間単位を指定しなかった場合は秒として解釈します。

// .Example timeout configuration parameter values
.設定パラメータにおけるタイムアウト時間の設定例
[cols="20,80"]
// |===
// | Parameter value | Equivalent annotation

// | `42`            | `@Timeout(42)`
// | `42 ns`         | `@Timeout(value = 42, unit = NANOSECONDS)`
// | `42 μs`         | `@Timeout(value = 42, unit = MICROSECONDS)`
// | `42 ms`         | `@Timeout(value = 42, unit = MILLISECONDS)`
// | `42 s`          | `@Timeout(value = 42, unit = SECONDS)`
// | `42 m`          | `@Timeout(value = 42, unit = MINUTES)`
// | `42 h`          | `@Timeout(value = 42, unit = HOURS)`
// | `42 d`          | `@Timeout(value = 42, unit = DAYS)`
// |===
|===
| 設定値          | アノテーションで同じ結果になる記述

| `42`            | `@Timeout(42)`
| `42 ns`         | `@Timeout(value = 42, unit = NANOSECONDS)`
| `42 μs`         | `@Timeout(value = 42, unit = MICROSECONDS)`
| `42 ms`         | `@Timeout(value = 42, unit = MILLISECONDS)`
| `42 s`          | `@Timeout(value = 42, unit = SECONDS)`
| `42 m`          | `@Timeout(value = 42, unit = MINUTES)`
| `42 h`          | `@Timeout(value = 42, unit = HOURS)`
| `42 d`          | `@Timeout(value = 42, unit = DAYS)`
|===


[[writing-tests-declarative-timeouts-polling]]
==== ポーリングテストで @Timeout を使用する

// When dealing with asynchronous code, it is common to write tests that poll while waiting
// for something to happen before performing any assertions. In some cases you can rewrite
// the logic to use a `CountDownLatch` or another synchronization mechanism, but sometimes
// that is not possible — for example, if the subject under test sends a message to a channel
// in an external message broker and assertions cannot be performed until the message has
// been successfully sent through the channel. Asynchronous tests like these require some
// form of timeout to ensure they don't hang the test suite by executing indefinitely, as
// would be the case if an asynchronous message never gets successfully delivered.
非同期処理を実行するコードでは、結果に対するアサーションを実行する前に、定期的に結果を確認するようなテストを書く場合があります。
そういうロジックは `CountDownLatch` のような同期のための仕組みで実装できる場合もありますが、できない場合が問題です。
例えば、テスト対象のコードが外部のメッセージブローカーのチャンネルにメッセージを送信する場合、送信が成功（完了）するまでアサーションを実行できません。
非同期処理をテストするコードでは、テストスイート全体がハングアップしないようタイムアウト時間を設定しなければなりません。

// By configuring a timeout for an asynchronous test that polls, you can ensure that the test
// does not execute indefinitely. The following example demonstrates how to achieve this with
// JUnit Jupiter's `@Timeout` annotation. This technique can be used to implement "poll
// until" logic very easily.
非同期処理のテストで定期的に結果を確認するためにタイムアウト時間を設定すれば、テストが永遠に止まらないことを避けられます。
次のコード例のように、`@Timeout` で「指定した時間まで待ち続ける」ロジックを簡単に記述できます。

[source,java]
----
include::{testDir}/example/PollingTimeoutDemo.java[tags=user_guide,indent=0]
----

// NOTE: If you need more control over polling intervals and greater flexibility with
// asynchronous tests, consider using a dedicated library such as
// link:https://github.com/awaitility/awaitility[Awaitility].
NOTE: 非同期処理のテストにおいて、定期的な確認時間を指定する以上の柔軟性が必要なときは、外部ライブラリの https://github.com/awaitility/awaitility[Awaitility] を検討してください。

[[writing-tests-declarative-timeouts-mode]]
==== 全体で @Timeout を無効化する

// When stepping through your code in a debug session, a fixed timeout limit may influence
// the result of the test, e.g. mark the test as failed although all assertions were met.
テスト対象のソースコードをデバッガで調べていると、タイムアウト時間を固定値にしたテストが失敗になってしまう場合があります。

// JUnit Jupiter supports the `junit.jupiter.execution.timeout.mode` configuration parameter
// to configure when timeouts are applied. There are three modes: `enabled`, `disabled`,
// and `disabled_on_debug`. The default mode is `enabled`.
// A VM runtime is considered to run in debug mode when one of its input parameters starts
// with `-agentlib:jdwp`. This heuristic is queried by the `disabled_on_debug` mode.
JUnit Jupiter の設定パラメータ `junit.jupiter.execution.timeout.mode` には3種類の値（`enabled, disabled, disabled_on_debug`）を指定できます。初期値は `enabled` です。
`disabled_on_debug` にすると、JVM をデバッグモードで実行しているかどうかを `-agentlib:jdwp` フラグの有無で判断します。

[[writing-tests-parallel-execution]]
=== 並列実行

// .Parallel test execution is an experimental feature
// WARNING: You're invited to give it a try and provide feedback to the JUnit team so they
// can improve and eventually <<api-evolution, promote>> this feature.
.並列実行機能は実験的な機能です
WARNING: JUnit チームがこの機能を改善して、正式機能へ <<api-evolution, 昇格>> できるよう、試用してフィードバックを提供してください。

// By default, JUnit Jupiter tests are run sequentially in a single thread. Running tests in
// parallel -- for example, to speed up execution -- is available as an opt-in feature since
// version 5.3. To enable parallel execution, set the
// `junit.jupiter.execution.parallel.enabled` configuration parameter to `true` -- for
// example, in `junit-platform.properties` (see <<running-tests-config-params>> for other
// options).
JUnit Jupiter はテストを1スレッドで逐次的に実行します。
5.3 から導入された並列実行機能は、テスト実行時間を短縮するための機能で、使用するには明示的な設定が必要でした。
設定パラメータの `junit.jupiter.execution.parallel.enabled` を `true` 指定しなければなりません。
設定する場所は `Junit-platform.properties` です（他の設定項目については <<running-tests-config-params>> を参照してください）。

// Please note that enabling this property is only the first step required to execute tests
// in parallel. If enabled, test classes and methods will still be executed sequentially by
// default. Whether or not a node in the test tree is executed concurrently is controlled by
// its execution mode. The following two modes are available.
この設定項目を有効化するのは、テストを並列実行するための最初の一歩にすぎません。
設定項目を有効化しただけではテストの実行方法は変わりません。
テストツリーを構成するどのノードを並行して実行するかは、実行モードによって異なります。
実行モードに指定できる値は次の2つです。

`SAME_THREAD`::
  強制的に親ノードと同じスレッドで実行します。
  例えば、テストメソッドに指定した場合、同じテストクラスの全ての `@BeforeAll` と `@AfterAll` は同じスレッドで実行します。
//  Force execution in the same thread used by the parent. For example, when used on a test
//  method, the test method will be executed in the same thread as any `@BeforeAll` or
//  `@AfterAll` methods of the containing test class.

`CONCURRENT`::
  リソースロックにより同じスレッドでの実行を強制されない限り、並行して実行します。
//  Execute concurrently unless a resource lock forces execution in the same thread.

// By default, nodes in the test tree use the `SAME_THREAD` execution mode. You can change
// the default by setting the `junit.jupiter.execution.parallel.mode.default` configuration
// parameter. Alternatively, you can use the `{Execution}` annotation to change the
// execution mode for the annotated element and its subelements (if any) which allows you to
// activate parallel execution for individual test classes, one by one.
基本的にテストツリーのノードの実行モードは `SAME_THREAD` になっています。
これは設定パラメータの `junit.jupiter.execution.parallel.mode.default` で変更できます。
実行モードは `{Execution}` アノテーションでも変更できます。
このアノテーションで修飾した要素やその子要素は、それぞれのテストクラスの中で並列に実行するようになります。

[source,properties]
// .Configuration parameters to execute all tests in parallel
.設定例：全てのテストを並列に実行する
----
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent
----

// The default execution mode is applied to all nodes of the test tree with a few notable
// exceptions, namely test classes that use the `Lifecycle.PER_CLASS` mode or a
// `{MethodOrderer}` (except for `{MethodOrderer_Random}`). In the former case, test authors
// have to ensure that the test class is thread-safe; in the latter, concurrent execution
// might conflict with the configured execution order. Thus, in both cases, test methods in
// such test classes are only executed concurrently if the `@Execution(CONCURRENT)`
// annotation is present on the test class or method.
一部の例外を除いて、既定の実行モードは全てのノードに適用されます。
例外は、インスタンスライフサイクル管理がクラス単位（per-class）になっているテストクラスと、`@TestMethodOrder` で {MethodOrderer_Random}` 以外の `{MethodOrder}` を指定しているテストクラスです。
前者の場合、テストの作成者はテストクラスがスレッド安全であることを保証しなければなりません。
後者の場合、並行実行と実行順序の指定が矛盾してしまいます。
それゆえに、どちらの場合もテストクラスやテストメソッドが `@Execution(CONCURRENT)` で修飾されている場合だけ、並行して実行するようになっています。

// All nodes of the test tree that are configured with the `CONCURRENT` execution mode will
// be executed fully in parallel according to the provided
// <<writing-tests-parallel-execution-config, configuration>> while observing the
// declarative <<writing-tests-parallel-execution-synchronization, synchronization>>
// mechanism. Please note that <<running-tests-capturing-output>> needs to be enabled
// separately.
宣言的な <<writing-tests-parallel-execution-synchronization, 同期化機構>> が使われているとしても、テストツリーの全てのノードの実行モードが `CONCURRENT` になっているなら、<<writing-tests-parallel-execution-config, 設定パラメータ>> に応じて全てを並行して実行します。
<<running-tests-capturing-output>> は独立して有効化しなければなりません。

// In addition, you can configure the default execution mode for top-level classes by setting
// the `junit.jupiter.execution.parallel.mode.classes.default` configuration parameter. By
// combining both configuration parameters, you can configure classes to run in parallel but
// their methods in the same thread:
さらに、トップレベルクラスの既定の実行モードを `junit.jupiter.execution.parallel.mode.classes.default` で変更できます。
両方の設定項目を組み合わせれば、テストクラスは並列に実行するけど、テストメソッドは同じスレッドで実行させることができます。

[source,properties]
// .Configuration parameters to execute top-level classes in parallel but methods in same thread
.設定例：トップレベルクラスは並列に実行し、テストメソッドは同じスレッドで実行する
----
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = same_thread
junit.jupiter.execution.parallel.mode.classes.default = concurrent
----

// The opposite combination will run all methods within one class in parallel, but top-level
// classes will run sequentially:
逆に、同じテストクラスのテストメソッドは並列に実行するけど、トップレベルクラスは逐次的に実行させることもできます。

[source,properties]
// .Configuration parameters to execute top-level classes sequentially but their methods in parallel
.設定例：トップレベルクラスは逐次的に実行し、テストメソッドは並列に実行する
----
junit.jupiter.execution.parallel.enabled = true
junit.jupiter.execution.parallel.mode.default = concurrent
junit.jupiter.execution.parallel.mode.classes.default = same_thread
----

// The following diagram illustrates how the execution of two top-level test classes `A` and
// `B` with two test methods per class behaves for all four combinations of
// `junit.jupiter.execution.parallel.mode.default` and
// `junit.jupiter.execution.parallel.mode.classes.default` (see labels in first column).
次の図は、設定パラメータ `junit.jupiter.execution.parallel.mode.default` と `junit.jupiter.execution.parallel.mode.classes.default` の値の全ての（4種類の）組み合わせについて、2つのトップレベルクラス `A` と `B` それぞれに定義した2つのテストメソッドがどのように実行させるかを示しています。

////
Source: https://mermaidjs.github.io/mermaid-live-editor/#/view/eyJjb2RlIjoiZ2FudHRcbiAgICBkYXRlRm9ybWF0ICBZWVlZLU1NLUREXG5cbiAgICBzZWN0aW9uIChzYW1lX3RocmVhZCwgc2FtZV90aHJlYWQpXG4gICAgQS50ZXN0MSgpIDphc3MxLCAyMDE5LTAxLTAxLCAxZFxuICAgIEEudGVzdDIoKSA6YXNzMiwgYWZ0ZXIgYXNzMSwgMWRcbiAgICBCLnRlc3QxKCkgOmJzczEsIGFmdGVyIGFzczIsIDFkXG4gICAgQi50ZXN0MigpIDpic3MyLCBhZnRlciBic3MxLCAxZFxuXG4gICAgc2VjdGlvbiAoc2FtZV90aHJlYWQsIGNvbmN1cnJlbnQpXG4gICAgQS50ZXN0MSgpIDphc2MxLCAyMDE5LTAxLTAxLCAxZFxuICAgIEEudGVzdDIoKSA6YXNjMiwgYWZ0ZXIgYXNjMSwgMWRcbiAgICBCLnRlc3QxKCkgOmJzYzEsIDIwMTktMDEtMDEsIDFkXG4gICAgQi50ZXN0MigpIDpic2MyLCBhZnRlciBic2MxLCAxZFxuXG4gICAgc2VjdGlvbiAoY29uY3VycmVudCwgc2FtZV90aHJlYWQpXG4gICAgQS50ZXN0MSgpIDphY3MxLCAyMDE5LTAxLTAxLCAxZFxuICAgIEEudGVzdDIoKSA6YWNzMiwgMjAxOS0wMS0wMSwgMWRcbiAgICBCLnRlc3QxKCkgOmJjczEsIGFmdGVyIGFjczIsIDFkXG4gICAgQi50ZXN0MigpIDpiY3MyLCBhZnRlciBhY3MyLCAxZFxuXG4gICAgc2VjdGlvbiAoY29uY3VycmVudCwgY29uY3VycmVudClcbiAgICBBLnRlc3QxKCkgOmFjYzEsIDIwMTktMDEtMDEsIDFkXG4gICAgQS50ZXN0MigpIDphY2MyLCAyMDE5LTAxLTAxLCAxZFxuICAgIEIudGVzdDEoKSA6YmNjMSwgMjAxOS0wMS0wMSwgMWRcbiAgICBCLnRlc3QyKCkgOmJjYzIsIDIwMTktMDEtMDEsIDFkXG4iLCJtZXJtYWlkIjp7InRoZW1lIjoibmV1dHJhbCIsImdhbnR0Ijp7ImxlZnRQYWRkaW5nIjoyMjUsImJhckdhcCI6NSwiZ3JpZExpbmVTdGFydFBhZGRpbmciOjEwLCJiYXJIZWlnaHQiOjMwLCJmb250U2l6ZSI6MTV9LCJ0aGVtZUNTUyI6Ii50YXNrVGV4dCwgLnNlY3Rpb25UaXRsZSB7IGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJzsgZm9udC1zaXplOjE1cHggfSAuZ3JpZCAudGljayB0ZXh0IHsgZGlzcGxheTpub25lIH0gLmdyaWQgLnRpY2s6bnRoLWNoaWxkKDJuKzEpIHsgZGlzcGxheTpub25lIH0ifX0

gantt
    dateFormat  YYYY-MM-DD

    section (same_thread, same_thread)
    A.test1() :ass1, 2019-01-01, 1d
    A.test2() :ass2, after ass1, 1d
    B.test1() :bss1, after ass2, 1d
    B.test2() :bss2, after bss1, 1d

    section (same_thread, concurrent)
    A.test1() :asc1, 2019-01-01, 1d
    A.test2() :asc2, after asc1, 1d
    B.test1() :bsc1, 2019-01-01, 1d
    B.test2() :bsc2, after bsc1, 1d

    section (concurrent, same_thread)
    A.test1() :acs1, 2019-01-01, 1d
    A.test2() :acs2, 2019-01-01, 1d
    B.test1() :bcs1, after acs2, 1d
    B.test2() :bcs2, after acs2, 1d

    section (concurrent, concurrent)
    A.test1() :acc1, 2019-01-01, 1d
    A.test2() :acc2, 2019-01-01, 1d
    B.test1() :bcc1, 2019-01-01, 1d
    B.test2() :bcc2, 2019-01-01, 1d

////
image::writing-tests_execution_mode.svg[caption='',title='Default execution mode configuration combinations']

// If the `junit.jupiter.execution.parallel.mode.classes.default` configuration parameter is
// not explicitly set, the value for `junit.jupiter.execution.parallel.mode.default` will be
// used instead.
設定パラメータ `junit.jupiter.execution.parallel.mode.classes.default` を指定しなかったときは、代わりに `junit.jupiter.execution.parallel.mode.default` の設定値を使用します。

[[writing-tests-parallel-execution-config]]
==== 設定方法

// Properties such as the desired parallelism and the maximum pool size can be configured
// using a `{ParallelExecutionConfigurationStrategy}`. The JUnit Platform provides two
// implementations out of the box: `dynamic` and `fixed`. Alternatively, you may implement a
// `custom` strategy.
並列度とスレッドプールサイズの最大値は `{ParallelExecutionConfigurationStrategy}` で設定します。
JUnit Platform は `dynamic` と `fixed` という2種類の実装を提供しています。
自分で作成する場合は `custom` を指定します。

To select a strategy, set the `junit.jupiter.execution.parallel.config.strategy`
configuration parameter to one of the following options.
設定パラメータ `junit.jupiter.execution.parallel.config.strategy` に指定できるのは次の値です。

`dynamic`::
  利用できるCPU数（CPUコア数）に、設定パラメータ `junit.jupiter.execution.parallel.config.dynamic.factor` の値（初期値は `1` ）を乗じた値を並列度とします。
//  Computes the desired parallelism based on the number of available processors/cores
//  multiplied by the `junit.jupiter.execution.parallel.config.dynamic.factor`
//  configuration parameter (defaults to `1`).

`fixed`::
  設定パラメータ `junit.jupiter.execution.parallel.config.fixed.parallelism` で並列度を指定します。
//  Uses the mandatory `junit.jupiter.execution.parallel.config.fixed.parallelism`
//  configuration parameter as the desired parallelism.

`custom`::
  `{ParallelExecutionConfigurationStrategy}` の実装クラス（の完全修飾クラス名）を設定パラメータの `junit.jupiter.execution.parallel.config.custom.class` に指定します。
//  Allows you to specify a custom `{ParallelExecutionConfigurationStrategy}`
//  implementation via the mandatory `junit.jupiter.execution.parallel.config.custom.class`
//  configuration parameter to determine the desired configuration.

// If no configuration strategy is set, JUnit Jupiter uses the `dynamic` configuration
// strategy with a factor of `1`. Consequently, the desired parallelism will be equal to the
// number of available processors/cores.
未設定の場合、係数 `1` の `dynamic` が指定されたものとします。
つまり、並列度はCPU数（CPUコア数）と等しくなります。

// .Parallelism does not imply maximum number of concurrent threads
// NOTE: JUnit Jupiter does not guarantee that the number of concurrently executing tests
// will not exceed the configured parallelism. For example, when using one of the
// synchronization mechanisms described in the next section, the `ForkJoinPool` that is used
// behind the scenes may spawn additional threads to ensure execution continues with
// sufficient parallelism. Thus, if you require such guarantees in a test class, please use
// your own means of controlling concurrency.
.並列度は並行動作するスレッド数の最大値そのものではありません
NOTE: 並行して実行するテストの数（スレッド数）は、並列度の設定値を超過する場合があります（JUnit Jupiter は設定値を超過しないことを保証しません）。
例えば、次のセクションで説明している同期化機構 `ForkJoinPool` では、設定した並列度を満たすだけのテストを実行し続けるために、並列度を越える数のスレッドを生成する場合があります。
したがって、テストを実行するリソースをきちんと制御したければ、並列度を制御するロジックを自分で作成しなければなりません。

[[writing-tests-parallel-execution-synchronization]]
==== 同期化

// In addition to controlling the execution mode using the `{Execution}` annotation, JUnit
// Jupiter provides another annotation-based declarative synchronization mechanism. The
// `{ResourceLock}` annotation allows you to declare that a test class or method uses a
// specific shared resource that requires synchronized access to ensure reliable test
// execution. The shared resource is identified by a unique name which is a `String`. The
// name can be user-defined or one of the predefined constants in `{Resources}`:
// `SYSTEM_PROPERTIES`, `SYSTEM_OUT`, `SYSTEM_ERR`, `LOCALE`, or `TIME_ZONE`.
JUnit Jupiter は、実行モードを制御する `{Execution}` アノテーションに加えて、宣言的に同期させるための `{ResourceLock}` アノテーションを提供しています。
テストクラスやテストメソッドなど、同期アクセスの必要な共有リソースを `{ResourceLock}` で修飾することで、安全に実行できることを保証します。
共有リソースを区別する名前は文字列で指定します。
独自の文字列を指定するか、`{Resources}` の定義済み定数 `SYSTEM_PROPERTIES, SYSTEM_OUT, SYSTEM_ERR, LOCALE, TIME_ZONE` を使用できます。

// If the tests in the following example were run in parallel _without_ the use of
// {ResourceLock}, they would be _flaky_. Sometimes they would pass, and at other times they
// would fail due to the inherent race condition of writing and then reading the same JVM
// System Property.
次のコード例に登場するテストを `{ResourceLock}` を _使わないで_ 並列に実行すると、実行結果が _フレーキー（flaky）_ になってしまいます。
JVM の同じシステムプロパティの読み書きには潜在的に競合状態があるため、ある時は成功し、ある時は失敗するようになってしまうのです。

// When access to shared resources is declared using the `{ResourceLock}` annotation, the
// JUnit Jupiter engine uses this information to ensure that no conflicting tests are run in
// parallel.
共有リソースにアクセスするテストクラスやテストメソッドは `{ResourceLock}` で修飾します。
JUnit Jupiter はこのアノテーションを参照して、並列に実行するテストが衝突しないことを保証します。

[NOTE]
// .Running tests in isolation
.テストを独立して実行する
====
// If most of your test classes can be run in parallel without any synchronization but you
// have some test classes that need to run in isolation, you can mark the latter with the
// `{Isolated}` annotation. Tests in such classes are executed sequentially without any other
// tests running at the same time.
ほとんどのテストクラスは同期化せずに実行できるけど、一部のテストクラスは独立して実行させたい場合、後者のテストクラスを `{Isolated}` で修飾するといいでしょう。
そうすれば、他のクラスは同時に（並行して）実行しつつ、`{Isonated}` で修飾したテストクラスだけは逐次的に実行できます。
====

// In addition to the `String` that uniquely identifies the shared resource, you may specify
// an access mode. Two tests that require `READ` access to a shared resource may run in
// parallel with each other but not while any other test that requires `READ_WRITE` access
// to the same shared resource is running.
文字列で指定した名前だけでなく、アクセスモードを指定して共有リソースを識別できます。
共有リソースに読み取りアクセス（`READ`）をする2つのテストは並列に実行できるけど、読み取りアクセスと書き込みアクセスの両方（`READ_WRITE`）が必要な2つのテストは並列に実行できません。

[source,java]
----
include::{testDir}/example/SharedResourcesDemo.java[tags=user_guide]
----

[[writing-tests-built-in-extensions]]
=== 組み込みの拡張機能

// While the JUnit team encourages reusable extensions to be packaged and maintained in
// separate libraries, the JUnit Jupiter API artifact includes a few user-facing extension
// implementations that are considered so generally useful that users shouldn't have to add
// another dependency.
JUnit チームとしては、再利用可能な拡張機能を別のライブラリで提供することを推奨しています。
ですが、JUnit Jupiter API のアーティファクトには、ユーザーが頻繁に使用するであろう便利な拡張機能を同梱しています（依存ライブラリを追加しなくても使用できます）。

[[writing-tests-built-in-extensions-TempDirectory]]
==== 一時ディレクトリ

// .`@TempDir` is an experimental feature
// WARNING: You're invited to give it a try and provide feedback to the JUnit team so they
// can improve and eventually <<api-evolution, promote>> this feature.
.一時ディレクトリ `@TempDir` は実験的な機能です
WARNING: JUnit チームがこの機能を改善して、正式機能へ <<api-evolution, 昇格>> できるよう、試用してフィードバックを提供してください。

// The built-in `{TempDirectory}` extension is used to create and clean up a temporary
// directory for an individual test or all tests in a test class. It is registered by
// default. To use it, annotate a field of type `java.nio.file.Path` or `java.io.File` with
// `{TempDir}` or add a parameter of type `java.nio.file.Path` or `java.io.File` annotated
// with `@TempDir` to a lifecycle method or test method.
`{TempDirectory}` 拡張機能は、一時的にテストが使用するディレクトリの作成と後始末をするための拡張機能です。
テストメソッド単位や、テストクラス単位で使用できます。
始めから登録されている拡張機能です。
`java.nio.file.Path` や `java.io.File` のフィールドを `{TempDir}` で修飾して使用します。
また、テストメソッドやライフサイクルメソッドについて、`java.nio.file.Path` や `java.io.File` の引数を `{TempDir}` で修飾して使用します。

// For example, the following test declares a parameter annotated with `@TempDir` for a
// single test method, creates and writes to a file in the temporary directory, and checks
// its content.
次のコード例では、テストメソッドの引数を `@TempDir` で修飾しています。
作成された一時ディレクトリにファイルを作成し、その内容を確認しているのが分かります。

// [source,java,indent=0]
// .A test method that requires a temporary directory
[source,java,indent=0]
.一時ディレクトリを使用するテストメソッド
----
include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_parameter_injection]
----

// You can inject multiple temporary directories by specifying multiple annotated parameters.
複数の引数を修飾すれば、複数の一時ディレクトリを作成し、注入できます。

// [source,java,indent=0]
// .A test method that requires multiple temporary directories
[source,java,indent=0]
.複数の一時ディレクトリを使用するテストメソッド
----
include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_multiple_directories]
----

// WARNING: To revert to the old behavior of using a single temporary directory for the
// entire test class or method (depending on which level the annotation is used), you can set
// the `junit.jupiter.tempdir.scope` configuration parameter to `per_context`. However,
// please note that this option is deprecated and will be removed in a future release.
WARNING: テストクラス全体あるいはテストメソッド（アノテーションで修飾する場所によって異なります）に対して単一の一時ディレクトリを提供する、という昔の振る舞いに戻すときは、設定パラメータ `junit.jupiter.tempdir.scope` に `per_context` を設定します。
この設定パラメータは将来のリリースで廃止予定です。

// `@TempDir` is not supported on constructor parameters. If you wish to retain a single
// reference to a temp directory across lifecycle methods and the current test method, please
// use field injection by annotating an instance field with `@TempDir`.
コンストラクタ引数では `@TempDir` を使用できません。
ライフサイクルメソッドと特定のテストメソッドで同じ一時ディレクトリを使用するときは、テストクラスのインスタンスフィールドを `@TempDir` で修飾してください。

// The following example stores a _shared_ temporary directory in a `static` field. This
// allows the same `sharedTempDir` to be used in all lifecycle methods and test methods of
// the test class. For better isolation, you should use an instance field so that each test
// method uses a separate directory.
次のコード例では `static` フィールドの一時ディレクトリを _共有_ ディレクトリとして使うようになっています。
こうすると、テストクラスの全てのライフサイクルメソッドとテストメソッドは同じ `sharedTempDir` へアクセスできます。
インスタンスフィールドを使えば、それぞれテストメソッドが別のディレクトリを使うようにできるので、隔離性は高まります。

[source,java,indent=0]
.A test class that shares a temporary directory across test methods
----
include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_field_injection]
----
